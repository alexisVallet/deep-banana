<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Data.HList.Label3</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Data-HList-Label3.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Data-HList-Label3.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">HList-0.4.1.0: Heterogeneous lists</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Data.HList.Label3</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Public constructors for labels</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>The HList library</p><p>(C) 2004-2006, Oleg Kiselyov, Ralf Laemmel, Keean Schupke</p><p>A model of labels as needed for extensible records. As before,
   all the information about labels is recorded in their type, so
   the labels of records may be purely phantom. In general,
   Labels are exclusively type-level entities and have no run-time
   representation.</p><p>Record labels are triplets of type-level naturals, namespace,
   and description. The namespace part helps avoid confusions between
   labels from different Haskell modules. The description is
   an arbitrary nullary type constructor.</p><p>For the sake of printing, the description is required to be the
   instance of Show. One must make sure that the show functions does
   not examine the value, as descr is purely phantom. Here's an
   example of the good Label description:</p><pre>    data MyLabelDescr; instance Show MyLabelDescr where show _ = &quot;descr&quot;</pre><p>which are automated by makeLabels3 from <a href="Data-HList-MakeLabel.html">Data.HList.MakeLabel</a>.</p><p>This model even allows the labels in a record to belong to different
   namespaces. To this end, the model employs the predicate for type
   equality.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span> <a href="#t:Lbl">Lbl</a> x ns desc</li><li class="src short"><a href="#v:firstLabel">firstLabel</a> :: ns -&gt; desc -&gt; <a href="Data-HList-FakePrelude.html#t:Label">Label</a> (<a href="Data-HList-Label3.html#t:Lbl">Lbl</a> <a href="Data-HList-FakePrelude.html#v:HZero">HZero</a> ns desc)</li><li class="src short"><a href="#v:nextLabel">nextLabel</a> :: <a href="Data-HList-FakePrelude.html#t:Label">Label</a> (<a href="Data-HList-Label3.html#t:Lbl">Lbl</a> x ns desc) -&gt; desc' -&gt; <a href="Data-HList-FakePrelude.html#t:Label">Label</a> (<a href="Data-HList-Label3.html#t:Lbl">Lbl</a> (<a href="Data-HList-FakePrelude.html#v:HSucc">HSucc</a> x) ns desc')</li><li class="src short"><span class="keyword">type family</span> <a href="#t:MapLabel">MapLabel</a> xs :: [*]</li><li class="src short"><span class="keyword">type family</span> <a href="#t:AddLabel">AddLabel</a> x :: *</li></ul></div><div id="interface"><h1>Documentation</h1><div class="doc"><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let label3 = Label :: Label (Lbl HZero () ())
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let label6 = Label :: Label &quot;6&quot;
</code></strong></pre></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Lbl" class="def">Lbl</a> x ns desc <a href="src/Data-HList-Label3.html#Lbl" class="link">Source</a></p><div class="subs instances"><p id="control.i:Lbl" class="caption collapser" onclick="toggleSection('i:Lbl')">Instances</p><div id="section.i:Lbl" class="show"><table><tr><td class="src">(<a href="Data-HList-FakePrelude.html#t:HEqBy">HEqBy</a> * <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> <a href="Data-HList-HSort.html#t:HLeFn">HLeFn</a> n m b, (~) * ns ns') =&gt; <a href="Data-HList-FakePrelude.html#t:HEqBy">HEqBy</a> * * <a href="Data-HList-HSort.html#t:HLeFn">HLeFn</a> (<a href="Data-HList-Label3.html#t:Lbl">Lbl</a> n ns desc) (<a href="Data-HList-Label3.html#t:Lbl">Lbl</a> m ns' desc') b</td><td class="doc"><p>Data.HList.Label3 labels can only be compared if they belong
 to the same namespace.</p></td></tr><tr><td class="src">(~) * (<a href="Data-HList-FakePrelude.html#t:Label">Label</a> k t) (<a href="Data-HList-FakePrelude.html#t:Label">Label</a> * (<a href="Data-HList-Label3.html#t:Lbl">Lbl</a> ix ns n)) =&gt; <a href="Data-HList-FakePrelude.html#t:SameLabels">SameLabels</a> * * (<a href="Data-HList-FakePrelude.html#t:Label">Label</a> k t) (<a href="Data-HList-Label3.html#t:Lbl">Lbl</a> ix ns n)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="../base-4.7.0.2/Text-Show.html#t:Show">Show</a> desc =&gt; <a href="Data-HList-FakePrelude.html#t:ShowLabel">ShowLabel</a> * (<a href="Data-HList-Label3.html#t:Lbl">Lbl</a> x ns desc)</td><td class="doc"><p>Equality on labels (descriptions are ignored)
 Use generic instance</p><p>Show label</p></td></tr><tr><td class="src"><a href="../base-4.7.0.2/Text-Show.html#t:Show">Show</a> desc =&gt; <a href="../base-4.7.0.2/Text-Show.html#t:Show">Show</a> (<a href="Data-HList-FakePrelude.html#t:Label">Label</a> * (<a href="Data-HList-Label3.html#t:Lbl">Lbl</a> x ns desc))</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="../base-4.7.0.2/Data-Typeable-Internal.html#t:Typeable">Typeable</a> (<a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> -&gt; * -&gt; * -&gt; *) <a href="Data-HList-Label3.html#t:Lbl">Lbl</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">((~) (* -&gt; * -&gt; *) to (<a href="Data-HList-Labelable.html#t:LabeledTo">LabeledTo</a> <a href="../base-4.7.0.2/GHC-TypeLits.html#t:Symbol">Symbol</a> x), <a href="Data-HList-Labelable.html#t:ToSym">ToSym</a> (to p q) x) =&gt; <a href="Data-HList-HListPrelude.html#t:HExtend">HExtend</a> (to p q) (<a href="../base-4.7.0.2/Data-Proxy.html#t:Proxy">Proxy</a> [*] ((:) * (<a href="Data-HList-Label3.html#t:Lbl">Lbl</a> n ns desc) xs))</td><td class="doc"><p>if the proxy has Data.HList.Label3.<a href="Lbl.html">Lbl</a>, then everything has to be
 wrapped in Label to make the kinds match up.</p></td></tr><tr><td class="src"><a href="Data-HList-HListPrelude.html#t:HExtend">HExtend</a> (<a href="Data-HList-FakePrelude.html#t:Label">Label</a> * (<a href="Data-HList-Label3.html#t:Lbl">Lbl</a> n ns desc)) (<a href="../base-4.7.0.2/Data-Proxy.html#t:Proxy">Proxy</a> [<a href="../base-4.7.0.2/GHC-TypeLits.html#t:Symbol">Symbol</a>] ((:) <a href="../base-4.7.0.2/GHC-TypeLits.html#t:Symbol">Symbol</a> x xs))</td><td class="doc"><p>Mixing two label kinds means we have to include <code><a href="Data-HList-FakePrelude.html#t:Label">Label</a></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let r = label3 .*. label6 .*. emptyProxy
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:t r
</code></strong>r :: Proxy '[Label (Lbl 'HZero () ()), Label &quot;6&quot;]
</pre></td></tr><tr><td class="src"><a href="Data-HList-HListPrelude.html#t:HExtend">HExtend</a> (<a href="Data-HList-FakePrelude.html#t:Label">Label</a> * (<a href="Data-HList-Label3.html#t:Lbl">Lbl</a> n ns desc)) (<a href="../base-4.7.0.2/Data-Proxy.html#t:Proxy">Proxy</a> [*] ((:) * (<a href="Data-HList-Label3.html#t:Lbl">Lbl</a> n' ns' desc') xs))</td><td class="doc"><p>If possible, Label is left off:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let q = label3 .*. label3 .*. emptyProxy
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:t q
</code></strong>q :: Proxy '[Lbl 'HZero () (), Lbl 'HZero () ()]
</pre></td></tr><tr><td class="src"><span class="keyword">type</span> <a href="Data-HList-FakePrelude.html#t:ZipTagged">ZipTagged</a> * ((:) * (<a href="Data-HList-Label3.html#t:Lbl">Lbl</a> ix ns n) ts) ((:) * v vs) = (:) * (<a href="../tagged-0.7.3/Data-Tagged.html#t:Tagged">Tagged</a> * (<a href="Data-HList-Label3.html#t:Lbl">Lbl</a> ix ns n) v) (<a href="Data-HList-FakePrelude.html#t:ZipTagged">ZipTagged</a> * ts vs)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="Data-HList-HListPrelude.html#t:HExtendR">HExtendR</a> (to p q) (<a href="../base-4.7.0.2/Data-Proxy.html#t:Proxy">Proxy</a> [*] ((:) * (<a href="Data-HList-Label3.html#t:Lbl">Lbl</a> n ns desc) xs))</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="Data-HList-HListPrelude.html#t:HExtendR">HExtendR</a> (<a href="Data-HList-FakePrelude.html#t:Label">Label</a> * (<a href="Data-HList-Label3.html#t:Lbl">Lbl</a> n ns desc)) (<a href="../base-4.7.0.2/Data-Proxy.html#t:Proxy">Proxy</a> [<a href="../base-4.7.0.2/GHC-TypeLits.html#t:Symbol">Symbol</a>] ((:) <a href="../base-4.7.0.2/GHC-TypeLits.html#t:Symbol">Symbol</a> x xs)) = <a href="../base-4.7.0.2/Data-Proxy.html#t:Proxy">Proxy</a> [*] ((:) * (<a href="Data-HList-FakePrelude.html#t:Label">Label</a> * (<a href="Data-HList-Label3.html#t:Lbl">Lbl</a> n ns desc)) (<a href="Data-HList-Label3.html#t:MapLabel">MapLabel</a> <a href="../base-4.7.0.2/GHC-TypeLits.html#t:Symbol">Symbol</a> ((:) <a href="../base-4.7.0.2/GHC-TypeLits.html#t:Symbol">Symbol</a> x xs)))</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="Data-HList-HListPrelude.html#t:HExtendR">HExtendR</a> (<a href="Data-HList-FakePrelude.html#t:Label">Label</a> * (<a href="Data-HList-Label3.html#t:Lbl">Lbl</a> n ns desc)) (<a href="../base-4.7.0.2/Data-Proxy.html#t:Proxy">Proxy</a> [*] ((:) * (<a href="Data-HList-Label3.html#t:Lbl">Lbl</a> n' ns' desc') xs)) = <a href="../base-4.7.0.2/Data-Proxy.html#t:Proxy">Proxy</a> [*] ((:) * (<a href="Data-HList-Label3.html#t:Lbl">Lbl</a> n ns desc) ((:) * (<a href="Data-HList-Label3.html#t:Lbl">Lbl</a> n' ns' desc') xs))</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:1">Public constructors for labels</h1><div class="top"><p class="src"><a name="v:firstLabel" class="def">firstLabel</a> :: ns -&gt; desc -&gt; <a href="Data-HList-FakePrelude.html#t:Label">Label</a> (<a href="Data-HList-Label3.html#t:Lbl">Lbl</a> <a href="Data-HList-FakePrelude.html#v:HZero">HZero</a> ns desc) <a href="src/Data-HList-Label3.html#firstLabel" class="link">Source</a></p><div class="doc"><p>Construct the first label</p></div></div><div class="top"><p class="src"><a name="v:nextLabel" class="def">nextLabel</a> :: <a href="Data-HList-FakePrelude.html#t:Label">Label</a> (<a href="Data-HList-Label3.html#t:Lbl">Lbl</a> x ns desc) -&gt; desc' -&gt; <a href="Data-HList-FakePrelude.html#t:Label">Label</a> (<a href="Data-HList-Label3.html#t:Lbl">Lbl</a> (<a href="Data-HList-FakePrelude.html#v:HSucc">HSucc</a> x) ns desc') <a href="src/Data-HList-Label3.html#nextLabel" class="link">Source</a></p><div class="doc"><p>Construct the next label</p></div></div><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:MapLabel" class="def">MapLabel</a> xs :: [*] <a href="src/Data-HList-Label3.html#MapLabel" class="link">Source</a></p><div class="doc"><p>similar to Data.HList.Record.Labels1, but avoids producing Label (Label x)</p></div><div class="subs instances"><p id="control.i:MapLabel" class="caption collapser" onclick="toggleSection('i:MapLabel')">Instances</p><div id="section.i:MapLabel" class="show"><table><tr><td class="src"><span class="keyword">type</span> <a href="Data-HList-Label3.html#t:MapLabel">MapLabel</a> k ([] k) = [] *</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="Data-HList-Label3.html#t:MapLabel">MapLabel</a> k ((:) k x xs) = (:) * (<a href="Data-HList-Label3.html#t:AddLabel">AddLabel</a> k x) (<a href="Data-HList-Label3.html#t:MapLabel">MapLabel</a> k xs)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:AddLabel" class="def">AddLabel</a> x :: * <a href="src/Data-HList-Label3.html#AddLabel" class="link">Source</a></p><div class="subs equations"><p class="caption">Equations</p><table><tr><td class="src"><a href="Data-HList-Label3.html#t:AddLabel">AddLabel</a> (<a href="Data-HList-FakePrelude.html#t:Label">Label</a> x) = <a href="Data-HList-FakePrelude.html#t:Label">Label</a> x</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-Label3.html#t:AddLabel">AddLabel</a> x = <a href="Data-HList-FakePrelude.html#t:Label">Label</a> x</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.15.0.2</p></div></body></html>