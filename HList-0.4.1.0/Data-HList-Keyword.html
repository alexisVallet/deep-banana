<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Data.HList.Keyword</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Data-HList-Keyword.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Data-HList-Keyword.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">HList-0.4.1.0: Heterogeneous lists</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Data.HList.Keyword</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">main</a><ul><li><a href="#g:2">another label type</a></li></ul></li><li><a href="#g:3">types for user error</a></li><li><a href="#g:4">demo</a><ul><li><a href="#g:5">setup data types</a></li></ul></li><li><a href="#g:6">Implementation details</a><ul><li><a href="#g:7">producing lists from a function's arguments</a></li><li><a href="#g:8">collecting arguments</a></li><li><a href="#g:9">merging default with supplied arguments</a></li></ul></li><li><a href="#g:10">original introduction</a></li><li><a href="#g:11">todo</a></li><li><a href="#g:12">internal for type signature prettiness</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>The public interface is exposed in <a href="Data-HList-CommonMain.html#t:Kw">CommonMain#Kw</a></p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">class</span> <a href="#t:Kw">Kw</a> fn arg_def r <span class="keyword">where</span><ul class="subs"><li><a href="#v:kw">kw</a> :: <a href="Data-HList-HList.html#t:HList">HList</a> (fn : arg_def) -&gt; r</li></ul></li><li class="src short"><span class="keyword">class</span> <a href="#t:IsKeyFN">IsKeyFN</a> t flag | t -&gt; flag</li><li class="src short"><a href="#v:recToKW">recToKW</a> :: <span class="keyword">forall</span> a b. (<a href="Data-HList-HList.html#t:HMapCxt">HMapCxt</a> <a href="Data-HList-HList.html#t:HList">HList</a> <a href="Data-HList-Keyword.html#t:TaggedToKW">TaggedToKW</a> a b, <a href="Data-HList-HList.html#t:HConcat">HConcat</a> b) =&gt; <a href="Data-HList-Record.html#t:Record">Record</a> a -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> (<a href="Data-HList-HList.html#t:HConcatR">HConcatR</a> b)</li><li class="src short"><span class="keyword">data</span> <a href="#t:K">K</a> s c = <a href="#v:K">K</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:ErrReqdArgNotFound">ErrReqdArgNotFound</a> x</li><li class="src short"><span class="keyword">data</span> <a href="#t:ErrUnexpectedKW">ErrUnexpectedKW</a> x</li><li class="src short"><span class="keyword">class</span> <a href="#t:KWApply">KWApply</a> f arg_values r <span class="keyword">where</span><ul class="subs"><li><a href="#v:kwapply">kwapply</a> :: f -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> arg_values -&gt; r</li></ul></li><li class="src short"><span class="keyword">class</span> <a href="#t:KWApply-39-">KWApply'</a> flag f arg_values r <span class="keyword">where</span><ul class="subs"><li><a href="#v:kwapply-39-">kwapply'</a> :: <a href="../base-4.7.0.2/Data-Proxy.html#t:Proxy">Proxy</a> flag -&gt; f -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> arg_values -&gt; r</li></ul></li><li class="src short"><span class="keyword">newtype</span> <a href="#t:Arg">Arg</a> arg_types arg_values = <a href="#v:Arg">Arg</a> (<a href="Data-HList-HList.html#t:HList">HList</a> arg_values)</li><li class="src short"><a href="#v:reflect_fk">reflect_fk</a> :: <a href="Data-HList-Keyword.html#t:ReflectFK">ReflectFK</a> fn kws =&gt; fn -&gt; <a href="Data-HList-Keyword.html#t:Arg">Arg</a> kws []</li><li class="src short"><span class="keyword">class</span> <a href="#t:ReflectFK">ReflectFK</a> f kws</li><li class="src short"><span class="keyword">class</span> <a href="#t:ReflectFK-39-">ReflectFK'</a> flag f kws</li><li class="src short"><span class="keyword">class</span> <a href="#t:KW">KW</a> f arg_desc arg_def r <span class="keyword">where</span><ul class="subs"><li><a href="#v:kwdo">kwdo</a> :: f -&gt; arg_desc -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> arg_def -&gt; r</li></ul></li><li class="src short"><span class="keyword">class</span> <a href="#t:KW-39-">KW'</a> rflag f arg_desc arg_def r <span class="keyword">where</span><ul class="subs"><li><a href="#v:kw-39-">kw'</a> :: <a href="../base-4.7.0.2/Data-Proxy.html#t:Proxy">Proxy</a> rflag -&gt; f -&gt; arg_desc -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> arg_def -&gt; r</li></ul></li><li class="src short"><span class="keyword">class</span> <a href="#t:KWAcc">KWAcc</a> arg_desc kw a f arg_def r <span class="keyword">where</span><ul class="subs"><li><a href="#v:kwaccum">kwaccum</a> :: arg_desc -&gt; kw -&gt; a -&gt; f -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> arg_def -&gt; r</li></ul></li><li class="src short"><span class="keyword">class</span> <a href="#t:KWMerge">KWMerge</a> arg_needed arg_values arg_def f r <span class="keyword">where</span><ul class="subs"><li><a href="#v:kwmerge">kwmerge</a> :: <a href="Data-HList-Keyword.html#t:Arg">Arg</a> arg_needed arg_values -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> arg_def -&gt; f -&gt; r</li></ul></li><li class="src short"><span class="keyword">class</span> <a href="#t:KWMerge-39-">KWMerge'</a> kw list atail arg_values arg_def f r <span class="keyword">where</span><ul class="subs"><li><a href="#v:kwmerge-39-">kwmerge'</a> :: kw -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> list -&gt; <a href="Data-HList-Keyword.html#t:Arg">Arg</a> atail arg_values -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> arg_def -&gt; f -&gt; r</li></ul></li><li class="src short"><span class="keyword">class</span> <a href="#t:KWMerge-39--39-">KWMerge''</a> flag kw list atail arg_values arg_def f r <span class="keyword">where</span><ul class="subs"><li><a href="#v:kwmerge-39--39-">kwmerge''</a> :: <a href="../base-4.7.0.2/Data-Proxy.html#t:Proxy">Proxy</a> flag -&gt; kw -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> list -&gt; <a href="Data-HList-Keyword.html#t:Arg">Arg</a> atail arg_values -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> arg_def -&gt; f -&gt; r</li></ul></li><li class="src short"><span class="keyword">class</span> <a href="#t:HDelete">HDelete</a> e l l'</li><li class="src short"><span class="keyword">class</span> <a href="#t:HDelete-39-">HDelete'</a> flag e l l'</li><li class="src short"><span class="keyword">data</span> <a href="#t:TaggedToKW">TaggedToKW</a></li></ul></div><div id="interface"><h1 id="g:1">main</h1><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:Kw" class="def">Kw</a> fn arg_def r <span class="keyword">where</span> <a href="src/Data-HList-Keyword.html#Kw" class="link">Source</a></p><div class="doc"><p><code>kw</code> takes a <code><a href="Data-HList-HList.html#t:HList">HList</a></code> whose first element is a function, and the rest
of the elements are default values.
A useful trick is to have a final argument <code>()</code> which is not
eaten up by a label (A only takes 1 argument). That way when you supply
the () it knows there are no more arguments (?).</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>data A = A
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>instance IsKeyFN (A -&gt; a -&gt; b) True
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let f A a () = a + 1
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let f' = f .*. A .*. 1 .*. HNil
</code></strong></pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>kw f' A 0 ()
</code></strong>1
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>kw f' ()
</code></strong>2
</pre></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:kw" class="def">kw</a> :: <a href="Data-HList-HList.html#t:HList">HList</a> (fn : arg_def) -&gt; r <a href="src/Data-HList-Keyword.html#kw" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:Kw" class="caption collapser" onclick="toggleSection('i:Kw')">Instances</p><div id="section.i:Kw" class="show"><table><tr><td class="src">(<a href="Data-HList-Keyword.html#t:KW-39-">KW'</a> <a href="../base-4.7.0.2/Data-Bool.html#t:Bool">Bool</a> rflag fn akws arg_def r, (~) * akws (<a href="Data-HList-Keyword.html#t:Arg">Arg</a> [*] kws ([] *)), <a href="Data-HList-Keyword.html#t:ReflectFK-39-">ReflectFK'</a> * [*] flag fn kws, <a href="Data-HList-Keyword.html#t:IsKeyFN">IsKeyFN</a> r rflag, <a href="Data-HList-Keyword.html#t:IsKeyFN">IsKeyFN</a> fn flag) =&gt; <a href="Data-HList-Keyword.html#t:Kw">Kw</a> fn arg_def r</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:IsKeyFN" class="def">IsKeyFN</a> t flag | t -&gt; flag <a href="src/Data-HList-TypeEqO.html#IsKeyFN" class="link">Source</a></p><div class="doc"><p>All our keywords must be registered</p></div><div class="subs instances"><p id="control.i:IsKeyFN" class="caption collapser" onclick="toggleSection('i:IsKeyFN')">Instances</p><div id="section.i:IsKeyFN" class="show"><table><tr><td class="src">(~) <a href="../base-4.7.0.2/Data-Bool.html#t:Bool">Bool</a> <a href="../base-4.7.0.2/Data-Bool.html#v:False">False</a> flag =&gt; <a href="Data-HList-Keyword.html#t:IsKeyFN">IsKeyFN</a> t flag</td><td class="doc"><p>overlapping/fallback case</p></td></tr><tr><td class="src"><a href="Data-HList-Keyword.html#t:IsKeyFN">IsKeyFN</a> (<a href="Data-HList-FakePrelude.html#t:Label">Label</a> <a href="../base-4.7.0.2/GHC-TypeLits.html#t:Symbol">Symbol</a> s -&gt; a -&gt; b) <a href="../base-4.7.0.2/Data-Bool.html#v:True">True</a></td><td class="doc"><p>labels that impose no restriction on the type of the (single) argument
 which follows</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let testF (_ :: Label &quot;a&quot;) (a :: Int) () = a+1
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>kw (hBuild testF) (Label :: Label &quot;a&quot;) 5 ()
</code></strong>6
</pre></td></tr><tr><td class="src">(~) * r (c -&gt; b) =&gt; <a href="Data-HList-Keyword.html#t:IsKeyFN">IsKeyFN</a> (<a href="Data-HList-Keyword.html#t:K">K</a> k s c -&gt; r) <a href="../base-4.7.0.2/Data-Bool.html#v:True">True</a></td><td class="doc"><p>The purpose of this instance is to be able to use the same Symbol
 (type-level string) at different types. If they are supposed to be the same,
 then use <code><a href="Data-HList-FakePrelude.html#t:Label">Label</a></code> instead of <code><a href="Data-HList-Keyword.html#t:K">K</a></code></p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let kA = K :: forall t. K &quot;a&quot; t
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let testF (K :: K &quot;a&quot; Int) a1 (K :: K &quot;a&quot; Integer) a2 () = a1-fromIntegral a2
</code></strong></pre><p>therefore the following options works:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>kw (hBuild testF) kA (5 :: Int) kA (3 :: Integer) ()
</code></strong>2
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>kw (hBuild testF) (K :: K &quot;a&quot; Integer) 3 (K :: K &quot;a&quot; Int) 5 ()
</code></strong>2
</pre><p>But you cannot leave off all <code>Int</code> or <code>Integer</code> annotations.</p></td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:recToKW" class="def">recToKW</a> :: <span class="keyword">forall</span> a b. (<a href="Data-HList-HList.html#t:HMapCxt">HMapCxt</a> <a href="Data-HList-HList.html#t:HList">HList</a> <a href="Data-HList-Keyword.html#t:TaggedToKW">TaggedToKW</a> a b, <a href="Data-HList-HList.html#t:HConcat">HConcat</a> b) =&gt; <a href="Data-HList-Record.html#t:Record">Record</a> a -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> (<a href="Data-HList-HList.html#t:HConcatR">HConcatR</a> b) <a href="src/Data-HList-Keyword.html#recToKW" class="link">Source</a></p><div class="doc"><p>convert a <code><a href="Data-HList-Record.html#t:Record">Record</a></code> into a list that can supply
default arguments for <code><a href="Data-HList-Keyword.html#v:kw">kw</a></code></p><p>A bit of setup:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XQuasiQuotes
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import Data.HList.RecordPuns
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let f (_ :: Label &quot;a&quot;) a (_ :: Label &quot;b&quot;) b () = a `div` b
</code></strong></pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let a = 2; b = 1; f' = f .*. recToKW [pun| a b |]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>kw f' ()
</code></strong>2
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>kw f' (Label :: Label &quot;a&quot;) 10 ()
</code></strong>10
</pre></div></div><h2 id="g:2">another label type</h2><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:K" class="def">K</a> s c <a href="src/Data-HList-Keyword.html#K" class="link">Source</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:K" class="def">K</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:K" class="caption collapser" onclick="toggleSection('i:K')">Instances</p><div id="section.i:K" class="show"><table><tr><td class="src">(~) * r (c -&gt; b) =&gt; <a href="Data-HList-Keyword.html#t:IsKeyFN">IsKeyFN</a> (<a href="Data-HList-Keyword.html#t:K">K</a> k s c -&gt; r) <a href="../base-4.7.0.2/Data-Bool.html#v:True">True</a></td><td class="doc"><p>The purpose of this instance is to be able to use the same Symbol
 (type-level string) at different types. If they are supposed to be the same,
 then use <code><a href="Data-HList-FakePrelude.html#t:Label">Label</a></code> instead of <code><a href="Data-HList-Keyword.html#t:K">K</a></code></p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let kA = K :: forall t. K &quot;a&quot; t
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let testF (K :: K &quot;a&quot; Int) a1 (K :: K &quot;a&quot; Integer) a2 () = a1-fromIntegral a2
</code></strong></pre><p>therefore the following options works:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>kw (hBuild testF) kA (5 :: Int) kA (3 :: Integer) ()
</code></strong>2
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>kw (hBuild testF) (K :: K &quot;a&quot; Integer) 3 (K :: K &quot;a&quot; Int) 5 ()
</code></strong>2
</pre><p>But you cannot leave off all <code>Int</code> or <code>Integer</code> annotations.</p></td></tr></table></div></div></div><h1 id="g:3">types for user error</h1><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:ErrReqdArgNotFound" class="def">ErrReqdArgNotFound</a> x <a href="src/Data-HList-Keyword.html#ErrReqdArgNotFound" class="link">Source</a></p></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:ErrUnexpectedKW" class="def">ErrUnexpectedKW</a> x <a href="src/Data-HList-Keyword.html#ErrUnexpectedKW" class="link">Source</a></p></div><h1 id="g:4">demo</h1><h2 id="g:5">setup data types</h2><div class="doc"><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XDataKinds -XFlexibleInstances -XMultiParamTypeClasses
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XScopedTypeVariables -XOverlappingInstances -XTypeFamilies
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -fcontext-stack=100
</code></strong></pre><p>We will be using an example inspired by a graphics toolkit -- the area
which really benefits from keyword arguments. We first define our
labels and useful datatypes</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>data Color = Color
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>data Size  = Size
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>data Origin  = Origin
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>data RaisedBorder = RaisedBorder
</code></strong></pre><p>The number of arguments each keyword must be specified by an <code><a href="Data-HList-Keyword.html#t:IsKeyFN">IsKeyFN</a></code>
instance.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>instance IsKeyFN (Color-&gt;a-&gt;b)  True
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>instance IsKeyFN (Size-&gt;a-&gt;b)   True
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>instance (a ~ (Int,Int)) =&gt; IsKeyFN (Origin-&gt;a-&gt;b) True
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>instance IsKeyFN (RaisedBorder-&gt;a-&gt;b) True
</code></strong></pre><p>Note that if a keyword is always followed by a certain type, that
can be specified above using an instance like the one for Origin.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>data CommonColor = Red | Green | Blue deriving Show
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>data RGBColor = RGBColor Int Int Int deriving Show
</code></strong></pre><p>and two functions:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:{
</code></strong>let make_square Size n Origin (x0,y0) Color (color::CommonColor) =
       unwords [&quot;Square:&quot;, show (n :: Int), &quot;at&quot;, show (x0,y0), show color] ++ &quot;\n&quot;
:}
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:{
</code></strong>let make_rect Size (nx,ny) Origin (x0,y0) Color (color::RGBColor)
        RaisedBorder border =
       unwords [&quot;Rectangle:&quot;, show (nx,ny), &quot;at&quot;, show (x0,y0),
            show color, if border then &quot;raised border&quot; else &quot;&quot;] ++ &quot;\n&quot;
:}
</pre></div><h1 id="g:6">Implementation details</h1><div class="doc"><p>One of the key tools of the implementation is <code><a href="Data-HList-Keyword.html#v:kwapply">kwapply</a></code>, which applies
a function to a polymorphic collection of that function's arguments.
The order of the arguments in the collection is irrelevant. The
contraption kwapply can handle polymorphic functions with arbitrary
number of labeled arguments.</p><p>For example, if we define</p><pre>f1 Size n = show n
f2 Size n Color m = unwords [&quot;size:&quot;, show n, &quot;color:&quot;, show m]
f3 Origin x Color m Size n =
    unwords [&quot;origin:&quot;, show x, &quot;size:&quot;, show n, &quot;color:&quot;,show m]</pre><p>then we can run</p><pre>katest1  = kwapply f1 (Size .*. () .*. HNil)
katest11 = kwapply f1 (Size .*. &quot;Large&quot; .*. HNil)

katest2  = kwapply f2 (Size .*. (1::Int) .*. Color .*. Red .*. HNil)
katest21 = kwapply f2 (Color .*. Red .*. Size .*. (1::Int) .*.  HNil)

katest3  = kwapply f3 (Size .*. (1::Int) .*. Origin .*. (2.0::Float) .*.
                 Color .*. Red .*. HNil)</pre></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:KWApply" class="def">KWApply</a> f arg_values r <span class="keyword">where</span> <a href="src/Data-HList-Keyword.html#KWApply" class="link">Source</a></p><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:kwapply" class="def">kwapply</a> :: f -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> arg_values -&gt; r <a href="src/Data-HList-Keyword.html#kwapply" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:KWApply" class="caption collapser" onclick="toggleSection('i:KWApply')">Instances</p><div id="section.i:KWApply" class="show"><table><tr><td class="src">(~) * r r' =&gt; <a href="Data-HList-Keyword.html#t:KWApply">KWApply</a> r ([] *) r'</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-HList-FakePrelude.html#t:HEq">HEq</a> * kw kw' flag, <a href="Data-HList-Keyword.html#t:KWApply-39-">KWApply'</a> <a href="../base-4.7.0.2/Data-Bool.html#t:Bool">Bool</a> flag (kw -&gt; a -&gt; f') ((:) * kw' ((:) * a' tail)) r) =&gt; <a href="Data-HList-Keyword.html#t:KWApply">KWApply</a> (kw -&gt; a -&gt; f') ((:) * kw' ((:) * a' tail)) r</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:KWApply-39-" class="def">KWApply'</a> flag f arg_values r <span class="keyword">where</span> <a href="src/Data-HList-Keyword.html#KWApply%27" class="link">Source</a></p><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:kwapply-39-" class="def">kwapply'</a> :: <a href="../base-4.7.0.2/Data-Proxy.html#t:Proxy">Proxy</a> flag -&gt; f -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> arg_values -&gt; r <a href="src/Data-HList-Keyword.html#kwapply%27" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:KWApply-39-" class="caption collapser" onclick="toggleSection('i:KWApply-39-')">Instances</p><div id="section.i:KWApply-39-" class="show"><table><tr><td class="src">((~) [*] (<a href="Data-HList-HList.html#t:HAppendListR">HAppendListR</a> * tail ((:) * kw ((:) * v ([] *)))) l', <a href="Data-HList-HList.html#t:HAppendList">HAppendList</a> tail ((:) * kw ((:) * v ([] *))), <a href="Data-HList-Keyword.html#t:KWApply">KWApply</a> f l' r) =&gt; <a href="Data-HList-Keyword.html#t:KWApply-39-">KWApply'</a> <a href="../base-4.7.0.2/Data-Bool.html#t:Bool">Bool</a> <a href="../base-4.7.0.2/Data-Bool.html#v:False">False</a> f ((:) * kw ((:) * v tail)) r</td><td class="doc"><p>Rotate the arg list ...</p></td></tr><tr><td class="src">((~) * v' v, <a href="Data-HList-Keyword.html#t:KWApply">KWApply</a> f' tail r) =&gt; <a href="Data-HList-Keyword.html#t:KWApply-39-">KWApply'</a> <a href="../base-4.7.0.2/Data-Bool.html#t:Bool">Bool</a> <a href="../base-4.7.0.2/Data-Bool.html#v:True">True</a> (kw -&gt; v -&gt; f') ((:) * kw ((:) * v' tail)) r</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">newtype</span> <a name="t:Arg" class="def">Arg</a> arg_types arg_values <a href="src/Data-HList-Keyword.html#Arg" class="link">Source</a></p><div class="doc"><p>The datatype Arg below is to maintain the state of keyword
accumulation: which keywords we need, and which keyword and values we
have already got.
arg_types is the phantom HList of keywords that are yet to be satisfied.
arg_values is the <code>HList (kw .*. kw_value .*. etc)</code>
of already found keywords and their values.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Arg" class="def">Arg</a> (<a href="Data-HList-HList.html#t:HList">HList</a> arg_values)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:Arg" class="caption collapser" onclick="toggleSection('i:Arg')">Instances</p><div id="section.i:Arg" class="show"><table><tr><td class="src"><a href="Data-HList-Keyword.html#t:KWMerge">KWMerge</a> k arg_needed arg_values arg_def f r =&gt; <a href="Data-HList-Keyword.html#t:KW-39-">KW'</a> <a href="../base-4.7.0.2/Data-Bool.html#t:Bool">Bool</a> <a href="../base-4.7.0.2/Data-Bool.html#v:False">False</a> f (<a href="Data-HList-Keyword.html#t:Arg">Arg</a> k arg_needed arg_values) arg_def r</td><td class="doc"><p>If the continuation r does not promise any more keyword
arguments, apply the defaults </p></td></tr><tr><td class="src"><a href="../base-4.7.0.2/Text-Show.html#t:Show">Show</a> (<a href="Data-HList-HList.html#t:HList">HList</a> vals) =&gt; <a href="../base-4.7.0.2/Text-Show.html#t:Show">Show</a> (<a href="Data-HList-Keyword.html#t:Arg">Arg</a> k tys vals)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-HList-Keyword.html#t:HDelete">HDelete</a> k * kw arg_types arg_types', <a href="Data-HList-Keyword.html#t:KW">KW</a> f (<a href="Data-HList-Keyword.html#t:Arg">Arg</a> [k] arg_types' ((:) * kw ((:) * a arg_values))) arg_def r) =&gt; <a href="Data-HList-Keyword.html#t:KWAcc">KWAcc</a> (<a href="Data-HList-Keyword.html#t:Arg">Arg</a> [k] arg_types arg_values) kw a f arg_def r</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h2 id="g:7">producing lists from a function's arguments</h2><div class="top"><p class="src"><a name="v:reflect_fk" class="def">reflect_fk</a> :: <a href="Data-HList-Keyword.html#t:ReflectFK">ReflectFK</a> fn kws =&gt; fn -&gt; <a href="Data-HList-Keyword.html#t:Arg">Arg</a> kws [] <a href="src/Data-HList-Keyword.html#reflect_fk" class="link">Source</a></p><div class="doc"><p>that reflects on a user-supplied function. It converts the *type* of a
user function to a collection of keywords required by that
function. This and the previous contraptions may be used to define an
<code>extended</code> version of some user function that takes more arguments --
without the need to enumerate all arguments of the original
function. We thus infringe on the area of object and module systems.</p><p>The rest of the implementation is just to convert `kw fn defaults'
into the application of kwapply.</p><p>Another key contraption is</p></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:ReflectFK" class="def">ReflectFK</a> f kws <a href="src/Data-HList-Keyword.html#ReflectFK" class="link">Source</a></p><div class="doc"><p>Reflection on a function:
Given a function, return the type list of its keywords</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:t reflect_fk (undefined::Size-&gt;Int-&gt;Color-&gt;CommonColor-&gt;String)
</code></strong>reflect_fk (undefined::Size-&gt;Int-&gt;Color-&gt;CommonColor-&gt;String)
  :: Arg '[Size, Color] '[]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:t reflect_fk (undefined::Size-&gt;Int-&gt;()-&gt;Int)
</code></strong>reflect_fk (undefined::Size-&gt;Int-&gt;()-&gt;Int) :: Arg '[Size] '[]
</pre></div><div class="subs instances"><p id="control.i:ReflectFK" class="caption collapser" onclick="toggleSection('i:ReflectFK')">Instances</p><div id="section.i:ReflectFK" class="show"><table><tr><td class="src">(<a href="Data-HList-Keyword.html#t:IsKeyFN">IsKeyFN</a> f flag, <a href="Data-HList-Keyword.html#t:ReflectFK-39-">ReflectFK'</a> * [*] flag f kws) =&gt; <a href="Data-HList-Keyword.html#t:ReflectFK">ReflectFK</a> * f kws</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:ReflectFK-39-" class="def">ReflectFK'</a> flag f kws <a href="src/Data-HList-Keyword.html#ReflectFK%27" class="link">Source</a></p><div class="subs instances"><p id="control.i:ReflectFK-39-" class="caption collapser" onclick="toggleSection('i:ReflectFK-39-')">Instances</p><div id="section.i:ReflectFK-39-" class="show"><table><tr><td class="src">(~) [k] ([] k) nil =&gt; <a href="Data-HList-Keyword.html#t:ReflectFK-39-">ReflectFK'</a> k [k] <a href="../base-4.7.0.2/Data-Bool.html#v:False">False</a> f nil</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">((~) [*] kkws ((:) * kw kws), <a href="Data-HList-Keyword.html#t:ReflectFK">ReflectFK</a> * rest kws) =&gt; <a href="Data-HList-Keyword.html#t:ReflectFK-39-">ReflectFK'</a> * [*] <a href="../base-4.7.0.2/Data-Bool.html#v:True">True</a> (kw -&gt; a -&gt; rest) kkws</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h2 id="g:8">collecting arguments</h2><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:KW" class="def">KW</a> f arg_desc arg_def r <span class="keyword">where</span> <a href="src/Data-HList-Keyword.html#KW" class="link">Source</a></p><div class="doc"><p>The main class: collect and apply the keyword arguments</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:kwdo" class="def">kwdo</a> :: f -&gt; arg_desc -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> arg_def -&gt; r <a href="src/Data-HList-Keyword.html#kwdo" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:KW" class="caption collapser" onclick="toggleSection('i:KW')">Instances</p><div id="section.i:KW" class="show"><table><tr><td class="src">(<a href="Data-HList-Keyword.html#t:IsKeyFN">IsKeyFN</a> r rflag, <a href="Data-HList-Keyword.html#t:KW-39-">KW'</a> <a href="../base-4.7.0.2/Data-Bool.html#t:Bool">Bool</a> rflag f arg_desc arg_def r) =&gt; <a href="Data-HList-Keyword.html#t:KW">KW</a> f arg_desc arg_def r</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:KW-39-" class="def">KW'</a> rflag f arg_desc arg_def r <span class="keyword">where</span> <a href="src/Data-HList-Keyword.html#KW%27" class="link">Source</a></p><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:kw-39-" class="def">kw'</a> :: <a href="../base-4.7.0.2/Data-Proxy.html#t:Proxy">Proxy</a> rflag -&gt; f -&gt; arg_desc -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> arg_def -&gt; r <a href="src/Data-HList-Keyword.html#kw%27" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:KW-39-" class="caption collapser" onclick="toggleSection('i:KW-39-')">Instances</p><div id="section.i:KW-39-" class="show"><table><tr><td class="src">(<a href="Data-HList-Keyword.html#t:KWAcc">KWAcc</a> arg_desc kw a f arg_def r, (~) * (kw -&gt; a -&gt; r) kwar) =&gt; <a href="Data-HList-Keyword.html#t:KW-39-">KW'</a> <a href="../base-4.7.0.2/Data-Bool.html#t:Bool">Bool</a> <a href="../base-4.7.0.2/Data-Bool.html#v:True">True</a> f arg_desc arg_def kwar</td><td class="doc"><p>Otherwise, collect the supplied keyword and its value, and recurse for
more: </p></td></tr><tr><td class="src"><a href="Data-HList-Keyword.html#t:KWMerge">KWMerge</a> k arg_needed arg_values arg_def f r =&gt; <a href="Data-HList-Keyword.html#t:KW-39-">KW'</a> <a href="../base-4.7.0.2/Data-Bool.html#t:Bool">Bool</a> <a href="../base-4.7.0.2/Data-Bool.html#v:False">False</a> f (<a href="Data-HList-Keyword.html#t:Arg">Arg</a> k arg_needed arg_values) arg_def r</td><td class="doc"><p>If the continuation r does not promise any more keyword
arguments, apply the defaults </p></td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:KWAcc" class="def">KWAcc</a> arg_desc kw a f arg_def r <span class="keyword">where</span> <a href="src/Data-HList-Keyword.html#KWAcc" class="link">Source</a></p><div class="doc"><p>Add the real argument to the Arg structure, and continue</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:kwaccum" class="def">kwaccum</a> :: arg_desc -&gt; kw -&gt; a -&gt; f -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> arg_def -&gt; r <a href="src/Data-HList-Keyword.html#kwaccum" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:KWAcc" class="caption collapser" onclick="toggleSection('i:KWAcc')">Instances</p><div id="section.i:KWAcc" class="show"><table><tr><td class="src">(<a href="Data-HList-Keyword.html#t:HDelete">HDelete</a> k * kw arg_types arg_types', <a href="Data-HList-Keyword.html#t:KW">KW</a> f (<a href="Data-HList-Keyword.html#t:Arg">Arg</a> [k] arg_types' ((:) * kw ((:) * a arg_values))) arg_def r) =&gt; <a href="Data-HList-Keyword.html#t:KWAcc">KWAcc</a> (<a href="Data-HList-Keyword.html#t:Arg">Arg</a> [k] arg_types arg_values) kw a f arg_def r</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h2 id="g:9">merging default with supplied arguments</h2><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:KWMerge" class="def">KWMerge</a> arg_needed arg_values arg_def f r <span class="keyword">where</span> <a href="src/Data-HList-Keyword.html#KWMerge" class="link">Source</a></p><div class="doc"><p>Add the needed arguments from arg_def to arg_values and continue
with kwapply.</p><p>That is, we try to satisfy the missing arguments from the defaults.
It will be a type error if some required arguments are missing </p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:kwmerge" class="def">kwmerge</a> :: <a href="Data-HList-Keyword.html#t:Arg">Arg</a> arg_needed arg_values -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> arg_def -&gt; f -&gt; r <a href="src/Data-HList-Keyword.html#kwmerge" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:KWMerge" class="caption collapser" onclick="toggleSection('i:KWMerge')">Instances</p><div id="section.i:KWMerge" class="show"><table><tr><td class="src"><a href="Data-HList-Keyword.html#t:KWApply">KWApply</a> f arg_values r =&gt; <a href="Data-HList-Keyword.html#t:KWMerge">KWMerge</a> [k] ([] k) arg_values arg_def f r</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-Keyword.html#t:KWMerge-39-">KWMerge'</a> [*] kw arg_def atail arg_values arg_def f r =&gt; <a href="Data-HList-Keyword.html#t:KWMerge">KWMerge</a> [*] ((:) * kw atail) arg_values arg_def f r</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:KWMerge-39-" class="def">KWMerge'</a> kw list atail arg_values arg_def f r <span class="keyword">where</span> <a href="src/Data-HList-Keyword.html#KWMerge%27" class="link">Source</a></p><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:kwmerge-39-" class="def">kwmerge'</a> :: kw -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> list -&gt; <a href="Data-HList-Keyword.html#t:Arg">Arg</a> atail arg_values -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> arg_def -&gt; f -&gt; r <a href="src/Data-HList-Keyword.html#kwmerge%27" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:KWMerge-39-" class="caption collapser" onclick="toggleSection('i:KWMerge-39-')">Instances</p><div id="section.i:KWMerge-39-" class="show"><table><tr><td class="src">(<a href="Data-HList-FakePrelude.html#t:Fail">Fail</a> * (<a href="Data-HList-Keyword.html#t:ErrReqdArgNotFound">ErrReqdArgNotFound</a> * kw), (~) * nff (<a href="Data-HList-Keyword.html#t:ErrReqdArgNotFound">ErrReqdArgNotFound</a> * kw)) =&gt; <a href="Data-HList-Keyword.html#t:KWMerge-39-">KWMerge'</a> k kw ([] *) atail arg_values arg_def f nff</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-HList-FakePrelude.html#t:HEq">HEq</a> * kw kw' flag, <a href="Data-HList-Keyword.html#t:KWMerge-39--39-">KWMerge''</a> k flag kw ((:) * kw' etc) atail arg_values arg_def f r) =&gt; <a href="Data-HList-Keyword.html#t:KWMerge-39-">KWMerge'</a> k kw ((:) * kw' etc) atail arg_values arg_def f r</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:KWMerge-39--39-" class="def">KWMerge''</a> flag kw list atail arg_values arg_def f r <span class="keyword">where</span> <a href="src/Data-HList-Keyword.html#KWMerge%27%27" class="link">Source</a></p><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:kwmerge-39--39-" class="def">kwmerge''</a> :: <a href="../base-4.7.0.2/Data-Proxy.html#t:Proxy">Proxy</a> flag -&gt; kw -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> list -&gt; <a href="Data-HList-Keyword.html#t:Arg">Arg</a> atail arg_values -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> arg_def -&gt; f -&gt; r <a href="src/Data-HList-Keyword.html#kwmerge%27%27" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:KWMerge-39--39-" class="caption collapser" onclick="toggleSection('i:KWMerge-39--39-')">Instances</p><div id="section.i:KWMerge-39--39-" class="show"><table><tr><td class="src"><a href="Data-HList-Keyword.html#t:KWMerge-39-">KWMerge'</a> k kw tail atail arg_values arg_def f r =&gt; <a href="Data-HList-Keyword.html#t:KWMerge-39--39-">KWMerge''</a> k <a href="../base-4.7.0.2/Data-Bool.html#v:False">False</a> kw ((:) * kw' ((:) * v' tail)) atail arg_values arg_def f r</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-HList-Keyword.html#t:KWMerge">KWMerge</a> k atail ((:) * kw ((:) * v arg_values)) arg_def f r =&gt; <a href="Data-HList-Keyword.html#t:KWMerge-39--39-">KWMerge''</a> k <a href="../base-4.7.0.2/Data-Bool.html#v:True">True</a> kw ((:) * kw ((:) * v tail)) atail arg_values arg_def f r</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:HDelete" class="def">HDelete</a> e l l' <a href="src/Data-HList-Keyword.html#HDelete" class="link">Source</a></p><div class="doc"><p>Delete e from l to yield l' The element e must occur in l</p></div><div class="subs instances"><p id="control.i:HDelete" class="caption collapser" onclick="toggleSection('i:HDelete')">Instances</p><div id="section.i:HDelete" class="show"><table><tr><td class="src">(<a href="Data-HList-FakePrelude.html#t:Fail">Fail</a> * (<a href="Data-HList-Keyword.html#t:ErrUnexpectedKW">ErrUnexpectedKW</a> k1 e), (~) [k] r ([] k)) =&gt; <a href="Data-HList-Keyword.html#t:HDelete">HDelete</a> k k e ([] k) r</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-HList-FakePrelude.html#t:HEq">HEq</a> k e e' flag, <a href="Data-HList-Keyword.html#t:HDelete-39-">HDelete'</a> k [k] [k] flag e ((:) k e' tail) l') =&gt; <a href="Data-HList-Keyword.html#t:HDelete">HDelete</a> k k e ((:) k e' tail) l'</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:HDelete-39-" class="def">HDelete'</a> flag e l l' <a href="src/Data-HList-Keyword.html#HDelete%27" class="link">Source</a></p><div class="subs instances"><p id="control.i:HDelete-39-" class="caption collapser" onclick="toggleSection('i:HDelete-39-')">Instances</p><div id="section.i:HDelete-39-" class="show"><table><tr><td class="src">(<a href="Data-HList-Keyword.html#t:HDelete">HDelete</a> k1 k e tail tail', (~) [k1] e'tail ((:) k1 e' tail')) =&gt; <a href="Data-HList-Keyword.html#t:HDelete-39-">HDelete'</a> k [k] [k] <a href="../base-4.7.0.2/Data-Bool.html#v:False">False</a> e ((:) k e' tail) e'tail</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(~) [k] tail' tail =&gt; <a href="Data-HList-Keyword.html#t:HDelete-39-">HDelete'</a> k [k] [k] <a href="../base-4.7.0.2/Data-Bool.html#v:True">True</a> e ((:) k e tail) tail'</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:10">original introduction</h1><div class="doc"><pre>From oleg-at-okmij.org Fri Aug 13 14:58:35 2004
To: haskell@haskell.org
Subject: Keyword arguments
From: oleg-at-pobox.com
Message-ID: &lt;20040813215834.F1FF3AB7E@Adric.metnet.navy.mil&gt;
Date: Fri, 13 Aug 2004 14:58:34 -0700 (PDT)
Status: OR</pre><p>We show the Haskell implementation of keyword arguments, which goes
well beyond records (e.g., in permitting the re-use of
labels). Keyword arguments indeed look just like regular, positional
arguments. However, keyword arguments may appear in any
order. Furthermore, one may associate defaults with some keywords; the
corresponding arguments may then be omitted. It is a type error to
omit a required keyword argument. The latter property is in stark
contrast with the conventional way of emulating keyword arguments via
records. Also in marked contrast with records, keyword labels may be
reused throughout the code with no restriction; the same label may be
associated with arguments of different types in different
functions. Labels of Haskell records may not be re-used.  Our solution
is essentially equivalent to keyword arguments of DSSSL Scheme or
labels of OCaml.</p><p>Keyword argument functions are naturally polyvariadic: Haskell does
support varargs! Keyword argument functions may be polymorphic. As
usual, functions with keyword arguments may be partially applied. On
the downside, sometimes one has to specify the type of the return
value of the function (if the keyword argument function has no
signature -- the latter is the norm, see below) -- provided that the
compiler cannot figure the return type out on its own. This is usually
only the case when we use keyword functions at the top level (GHCi
prompt).</p><p>Our solution requires no special extensions to Haskell and works with
the existing Haskell compilers; it is tested on GHC 6.0.1. The
overlapping instances extension is not necessary (albeit it is
convenient).</p><p>The gist of our implementation is the realization that the type of a
function is a polymorphic collection of its argument types -- a
collection that we can traverse. This message thus illustrates a
limited form of the reflection on a function.</p><p>Our implementation is a trivial extension of the strongly-typed
polymorphic open records described in
    <a href="http://homepages.cwi.nl/~ralf/HList/">http://homepages.cwi.nl/~ralf/HList/</a></p><p>In fact, the implementation relies on the HList library.  To run the
code (which this message is), one needs to download the HList library
from the above site.</p><p>The HList paper discusses the issue of labels in some detail. The
paper gives three different representations. One of them needs no
overlapping instances and is very portable. In this message, we chose
a representation that relies on generic type equality and therefore
needs overlapping instances as implemented in GHC. Again, this is
merely an outcome of our non-deterministic choice. It should be
emphasized that other choices are possible, which do not depend on
overlapping instances at all. Please see the HList paper for details.</p></div><h1 id="g:11">todo</h1><div class="doc"><dl><dt><code>better instances for Symbol</code></dt><dd></dd></dl><p>There isn't a pair <code>(K2 &quot;Origin&quot; (Int, Int))</code> <code>(K &quot;hi&quot;)</code> that behaves just like Origin below.
something is possible between constraintkinds. See <code><a href="Data-HList-FakePrelude.html#t:Fun">Fun</a></code></p><pre>instance (a ~ (Int,Int)) =&gt; IsKeyFN (Origin-&gt;a-&gt;b) True</pre><dl><dt><code>wildcard/catchall</code></dt><dd></dd></dl><p>like in R. This would be a special keyword for keyword args that didn't match.
They would be put in a HList/Record argument like <code>...</code></p><dl><dt><code>investigate first-classness of varargs</code></dt><dd>for whatever reason you can't have  <code>f = kw fn blah</code> and then pass more arguments
on to fn. This is bad. It used to work (in the ghc6.0 days and probably up to
6.12). Some convenience functions/operators should be added which do the same
thing as:</dd></dl><pre>fn `hAppendList` hBuild a b c d e</pre></div><h1 id="g:12">internal for type signature prettiness</h1><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:TaggedToKW" class="def">TaggedToKW</a> <a href="src/Data-HList-Keyword.html#TaggedToKW" class="link">Source</a></p><div class="subs instances"><p id="control.i:TaggedToKW" class="caption collapser" onclick="toggleSection('i:TaggedToKW')">Instances</p><div id="section.i:TaggedToKW" class="show"><table><tr><td class="src">((~) * x (<a href="../tagged-0.7.3/Data-Tagged.html#t:Tagged">Tagged</a> k l v), (~) * y (<a href="Data-HList-HList.html#t:HList">HList</a> ((:) * (<a href="Data-HList-FakePrelude.html#t:Label">Label</a> k l) ((:) * v ([] *))))) =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> <a href="Data-HList-Keyword.html#t:TaggedToKW">TaggedToKW</a> x y</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.15.0.2</p></div></body></html>