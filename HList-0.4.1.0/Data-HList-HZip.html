<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Data.HList.HZip</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Data-HList-HZip.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Data-HList-HZip.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">HList-0.4.1.0: Heterogeneous lists</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Data.HList.HZip</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">zip</a><ul><li><a href="#g:2">functional dependency</a></li><li><a href="#g:3">type family</a></li><li><a href="#g:4">utility type functions</a></li></ul></li><li><a href="#g:5">transpose</a><ul><li><a href="#g:6">helpers</a></li></ul></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>The HList library</p><p>(C) 2004, Oleg Kiselyov, Ralf Laemmel, Keean Schupke</p><p>Zipping and unzipping for (conceptually) lists of pairs.</p><p>Provides two alternative implementations</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">class</span> (<a href="Data-HList-HZip.html#t:HZipR">HZipR</a> (<a href="Data-HList-HZip.html#t:MapFst">MapFst</a> z) (<a href="Data-HList-HZip.html#t:MapSnd">MapSnd</a> z) ~ z) =&gt; <a href="#t:HUnZip">HUnZip</a> z <span class="keyword">where</span><ul class="subs"><li><span class="keyword">type</span> <a href="#t:MapFst">MapFst</a> z :: [*]</li><li><span class="keyword">type</span> <a href="#t:MapSnd">MapSnd</a> z :: [*]</li><li><a href="#v:hZip2">hZip2</a> :: <a href="Data-HList-HList.html#t:HList">HList</a> (<a href="Data-HList-HZip.html#t:MapFst">MapFst</a> z) -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> (<a href="Data-HList-HZip.html#t:MapSnd">MapSnd</a> z) -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> z</li><li><a href="#v:hUnzip2">hUnzip2</a> :: <a href="Data-HList-HList.html#t:HList">HList</a> z -&gt; (<a href="Data-HList-HList.html#t:HList">HList</a> (<a href="Data-HList-HZip.html#t:MapFst">MapFst</a> z), <a href="Data-HList-HList.html#t:HList">HList</a> (<a href="Data-HList-HZip.html#t:MapSnd">MapSnd</a> z))</li></ul></li><li class="src short"><span class="keyword">type family</span> <a href="#t:HZipR">HZipR</a> x y :: [*]</li><li class="src short"><span class="keyword">type family</span> <a href="#t:Fst">Fst</a> a</li><li class="src short"><span class="keyword">type family</span> <a href="#t:Snd">Snd</a> a</li><li class="src short"><a href="#v:hTranspose">hTranspose</a> :: (<a href="Data-HList-HZip.html#t:HZip3">HZip3</a> a b c, <a href="Data-HList-HList.html#t:HFoldr">HFoldr</a> <a href="Data-HList-HZip.html#t:HZipF">HZipF</a> (<a href="Data-HList-HList.html#t:HList">HList</a> es) l (<a href="Data-HList-HList.html#t:HList">HList</a> b), <a href="Data-HList-HList.html#t:HReplicateFD">HReplicateFD</a> n (<a href="Data-HList-HList.html#t:HList">HList</a> ([] *)) es, <a href="Data-HList-HList.html#t:HLengthEq1">HLengthEq1</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> a n, <a href="Data-HList-HList.html#t:HLengthEq2">HLengthEq2</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> a n, <a href="Data-HList-FakePrelude.html#t:SameLength-39-">SameLength'</a> * * (<a href="Data-HList-HList.html#t:HReplicateR">HReplicateR</a> * n ()) a) =&gt; <a href="Data-HList-HList.html#t:HList">HList</a> ((:) * (<a href="Data-HList-HList.html#t:HList">HList</a> a) l) -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> c</li><li class="src short"><span class="keyword">class</span> <a href="#t:HZip3">HZip3</a> x y l | x y -&gt; l, l -&gt; x y <span class="keyword">where</span><ul class="subs"><li><a href="#v:hZip3">hZip3</a> :: <a href="Data-HList-HList.html#t:HList">HList</a> x -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> y -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l</li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:HZipF">HZipF</a> = <a href="#v:HZipF">HZipF</a></li></ul></div><div id="interface"><h1 id="g:1">zip</h1><h2 id="g:2">functional dependency</h2><div class="doc"><p>moved to <a href="Data-HList-HList.html">Data.HList.HList</a> to avoid an orphan instance</p></div><h2 id="g:3">type family</h2><div class="doc"><p><code><a href="Data-HList-HZip.html#v:hZip2">hZip2</a></code> can be written as a standalone function, with an appropriate
 type family to calculate the result type. However, that does not seem to
 be the case for <code><a href="Data-HList-HZip.html#v:hUnzip2">hUnzip2</a></code>, so to re-use some type functions the two are
 in the same class.</p></div><div class="top"><p class="src"><span class="keyword">class</span> (<a href="Data-HList-HZip.html#t:HZipR">HZipR</a> (<a href="Data-HList-HZip.html#t:MapFst">MapFst</a> z) (<a href="Data-HList-HZip.html#t:MapSnd">MapSnd</a> z) ~ z) =&gt; <a name="t:HUnZip" class="def">HUnZip</a> z <span class="keyword">where</span> <a href="src/Data-HList-HZip.html#HUnZip" class="link">Source</a></p><div class="doc"><p>HZipR in the superclass constraint doesn't hurt, but it doesn't seem to be
 necessary</p></div><div class="subs associated-types"><p class="caption">Associated Types</p><p class="src"><span class="keyword">type</span> <a name="t:MapFst" class="def">MapFst</a> z :: [*] <a href="src/Data-HList-HZip.html#MapFst" class="link">Source</a></p><p class="src"><span class="keyword">type</span> <a name="t:MapSnd" class="def">MapSnd</a> z :: [*] <a href="src/Data-HList-HZip.html#MapSnd" class="link">Source</a></p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:hZip2" class="def">hZip2</a> :: <a href="Data-HList-HList.html#t:HList">HList</a> (<a href="Data-HList-HZip.html#t:MapFst">MapFst</a> z) -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> (<a href="Data-HList-HZip.html#t:MapSnd">MapSnd</a> z) -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> z <a href="src/Data-HList-HZip.html#hZip2" class="link">Source</a></p><p class="src"><a name="v:hUnzip2" class="def">hUnzip2</a> :: <a href="Data-HList-HList.html#t:HList">HList</a> z -&gt; (<a href="Data-HList-HList.html#t:HList">HList</a> (<a href="Data-HList-HZip.html#t:MapFst">MapFst</a> z), <a href="Data-HList-HList.html#t:HList">HList</a> (<a href="Data-HList-HZip.html#t:MapSnd">MapSnd</a> z)) <a href="src/Data-HList-HZip.html#hUnzip2" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:HUnZip" class="caption collapser" onclick="toggleSection('i:HUnZip')">Instances</p><div id="section.i:HUnZip" class="show"><table><tr><td class="src"><a href="Data-HList-HZip.html#t:HUnZip">HUnZip</a> ([] *)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">((~) * z (x, y), <a href="Data-HList-HZip.html#t:HUnZip">HUnZip</a> zs) =&gt; <a href="Data-HList-HZip.html#t:HUnZip">HUnZip</a> ((:) * z zs)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:HZipR" class="def">HZipR</a> x y :: [*] <a href="src/Data-HList-HZip.html#HZipR" class="link">Source</a></p><div class="doc"><p>calculates something like:</p><pre>[a] -&gt; [b] -&gt; [(a,b)]</pre><p>can be used to give another type for <code><a href="Data-HList-HZip.html#v:hZip2">hZip2</a></code></p><pre>hZip2 :: HList a -&gt; HList b -&gt; HList (HZipR a b)</pre></div><div class="subs instances"><p id="control.i:HZipR" class="caption collapser" onclick="toggleSection('i:HZipR')">Instances</p><div id="section.i:HZipR" class="show"><table><tr><td class="src"><span class="keyword">type</span> <a href="Data-HList-HZip.html#t:HZipR">HZipR</a> ([] *) ([] *) = [] *</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="Data-HList-HZip.html#t:HZipR">HZipR</a> ((:) * x xs) ((:) * y ys) = (:) * (x, y) (<a href="Data-HList-HZip.html#t:HZipR">HZipR</a> xs ys)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h2 id="g:4">utility type functions</h2><div class="doc"><p>do they belong somewhere else?</p></div><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:Fst" class="def">Fst</a> a <a href="src/Data-HList-HZip.html#Fst" class="link">Source</a></p><div class="subs instances"><p id="control.i:Fst" class="caption collapser" onclick="toggleSection('i:Fst')">Instances</p><div id="section.i:Fst" class="show"><table><tr><td class="src"><span class="keyword">type</span> <a href="Data-HList-HZip.html#t:Fst">Fst</a> (a, b) = a</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:Snd" class="def">Snd</a> a <a href="src/Data-HList-HZip.html#Snd" class="link">Source</a></p><div class="subs instances"><p id="control.i:Snd" class="caption collapser" onclick="toggleSection('i:Snd')">Instances</p><div id="section.i:Snd" class="show"><table><tr><td class="src"><span class="keyword">type</span> <a href="Data-HList-HZip.html#t:Snd">Snd</a> (a, b) = b</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:5">transpose</h1><div class="top"><p class="src"><a name="v:hTranspose" class="def">hTranspose</a> :: (<a href="Data-HList-HZip.html#t:HZip3">HZip3</a> a b c, <a href="Data-HList-HList.html#t:HFoldr">HFoldr</a> <a href="Data-HList-HZip.html#t:HZipF">HZipF</a> (<a href="Data-HList-HList.html#t:HList">HList</a> es) l (<a href="Data-HList-HList.html#t:HList">HList</a> b), <a href="Data-HList-HList.html#t:HReplicateFD">HReplicateFD</a> n (<a href="Data-HList-HList.html#t:HList">HList</a> ([] *)) es, <a href="Data-HList-HList.html#t:HLengthEq1">HLengthEq1</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> a n, <a href="Data-HList-HList.html#t:HLengthEq2">HLengthEq2</a> <a href="Data-HList-FakePrelude.html#t:HNat">HNat</a> a n, <a href="Data-HList-FakePrelude.html#t:SameLength-39-">SameLength'</a> * * (<a href="Data-HList-HList.html#t:HReplicateR">HReplicateR</a> * n ()) a) =&gt; <a href="Data-HList-HList.html#t:HList">HList</a> ((:) * (<a href="Data-HList-HList.html#t:HList">HList</a> a) l) -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> c <a href="src/Data-HList-HZip.html#hTranspose" class="link">Source</a></p><div class="doc"><p>this transpose requires equal-length HLists inside a HList:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import Data.HList.HListPrelude
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let ex = (1 .*. 2 .*. HNil) .*. ('a' .*. 'b' .*. HNil) .*. ( 3 .*. 5 .*. HNil) .*. HNil
</code></strong></pre><p>The original list:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>ex
</code></strong>H[H[1,2],H['a','b'],H[3,5]]
</pre><p>And transposed:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>hTranspose ex
</code></strong>H[H[1,'a',3],H[2,'b',5]]
</pre></div></div><h2 id="g:6">helpers</h2><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:HZip3" class="def">HZip3</a> x y l | x y -&gt; l, l -&gt; x y <span class="keyword">where</span> <a href="src/Data-HList-HZip.html#HZip3" class="link">Source</a></p><div class="doc"><p>same as <code>HZip</code> but HCons the elements of x onto y. This might be doable as
 a <code>hMap f (hZip x y)</code>, but that one doesn't propagate types as easily it
 seems.</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:hZip3" class="def">hZip3</a> :: <a href="Data-HList-HList.html#t:HList">HList</a> x -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> y -&gt; <a href="Data-HList-HList.html#t:HList">HList</a> l <a href="src/Data-HList-HZip.html#hZip3" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:HZip3" class="caption collapser" onclick="toggleSection('i:HZip3')">Instances</p><div id="section.i:HZip3" class="show"><table><tr><td class="src"><a href="Data-HList-HZip.html#t:HZip3">HZip3</a> ([] *) ([] *) ([] *)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">((~) * (<a href="Data-HList-HList.html#t:HList">HList</a> ((:) * x y)) z, <a href="Data-HList-HZip.html#t:HZip3">HZip3</a> xs ys zs) =&gt; <a href="Data-HList-HZip.html#t:HZip3">HZip3</a> ((:) * x xs) ((:) * (<a href="Data-HList-HList.html#t:HList">HList</a> y) ys) ((:) * z zs)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:HZipF" class="def">HZipF</a> <a href="src/Data-HList-HZip.html#HZipF" class="link">Source</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:HZipF" class="def">HZipF</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:HZipF" class="caption collapser" onclick="toggleSection('i:HZipF')">Instances</p><div id="section.i:HZipF" class="show"><table><tr><td class="src">(<a href="Data-HList-HZip.html#t:HZip3">HZip3</a> a b c, (~) * x (<a href="Data-HList-HList.html#t:HList">HList</a> a, <a href="Data-HList-HList.html#t:HList">HList</a> b), (~) * y (<a href="Data-HList-HList.html#t:HList">HList</a> c)) =&gt; <a href="Data-HList-FakePrelude.html#t:ApplyAB">ApplyAB</a> <a href="Data-HList-HZip.html#t:HZipF">HZipF</a> x y</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.15.0.2</p></div></body></html>