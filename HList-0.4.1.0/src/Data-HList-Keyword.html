<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>Data/HList/Keyword.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a>
<a name="line-2"></a><span class='hs-comment'>{- | Description: keyword arguments
<a name="line-3"></a>
<a name="line-4"></a>The public interface is exposed in &lt;Data-HList-CommonMain.html#t:Kw CommonMain#Kw&gt;
<a name="line-5"></a>
<a name="line-6"></a>-}</span>
<a name="line-7"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>HList</span><span class='hs-varop'>.</span><span class='hs-conid'>Keyword</span> <span class='hs-layout'>(</span>
<a name="line-8"></a>
<a name="line-9"></a>  <span class='hs-comment'>-- * main</span>
<a name="line-10"></a>  <span class='hs-conid'>Kw</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-11"></a>  <span class='hs-conid'>IsKeyFN</span><span class='hs-layout'>,</span>
<a name="line-12"></a>
<a name="line-13"></a>  <span class='hs-varid'>recToKW</span><span class='hs-layout'>,</span>
<a name="line-14"></a>
<a name="line-15"></a>  <span class='hs-comment'>-- ** another label type</span>
<a name="line-16"></a>  <span class='hs-conid'>K</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-17"></a>
<a name="line-18"></a>  <span class='hs-comment'>-- * types for user error</span>
<a name="line-19"></a>  <span class='hs-conid'>ErrReqdArgNotFound</span><span class='hs-layout'>,</span>
<a name="line-20"></a>  <span class='hs-conid'>ErrUnexpectedKW</span><span class='hs-layout'>,</span>
<a name="line-21"></a>
<a name="line-22"></a>
<a name="line-23"></a>  <span class='hs-comment'>-- * demo</span>
<a name="line-24"></a>  <span class='hs-comment'>-- ** setup data types</span>
<a name="line-25"></a>  <span class='hs-comment'>-- $setup</span>
<a name="line-26"></a>  <span class='hs-comment'>-- $ex2</span>
<a name="line-27"></a>
<a name="line-28"></a>  <span class='hs-comment'>-- * Implementation details</span>
<a name="line-29"></a>  <span class='hs-comment'>-- $imploutline</span>
<a name="line-30"></a>  <span class='hs-conid'>KWApply</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-31"></a>  <span class='hs-conid'>KWApply'</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-32"></a>  <span class='hs-conid'>Arg</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-33"></a>
<a name="line-34"></a>
<a name="line-35"></a>
<a name="line-36"></a>  <span class='hs-comment'>-- ** producing lists from a function's arguments</span>
<a name="line-37"></a>  <span class='hs-varid'>reflect_fk</span><span class='hs-layout'>,</span>
<a name="line-38"></a>  <span class='hs-conid'>ReflectFK</span><span class='hs-layout'>,</span>
<a name="line-39"></a>  <span class='hs-conid'>ReflectFK'</span><span class='hs-layout'>,</span>
<a name="line-40"></a>
<a name="line-41"></a>
<a name="line-42"></a>  <span class='hs-comment'>-- ** collecting arguments</span>
<a name="line-43"></a>  <span class='hs-conid'>KW</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-44"></a>  <span class='hs-conid'>KW'</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-45"></a>  <span class='hs-conid'>KWAcc</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-46"></a>
<a name="line-47"></a>  <span class='hs-comment'>-- ** merging default with supplied arguments</span>
<a name="line-48"></a>  <span class='hs-conid'>KWMerge</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-49"></a>  <span class='hs-conid'>KWMerge'</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-50"></a>  <span class='hs-conid'>KWMerge''</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-51"></a>
<a name="line-52"></a>  <span class='hs-conid'>HDelete</span><span class='hs-layout'>,</span> <span class='hs-conid'>HDelete'</span><span class='hs-layout'>,</span>
<a name="line-53"></a>
<a name="line-54"></a>
<a name="line-55"></a>  <span class='hs-comment'>-- * original introduction</span>
<a name="line-56"></a>  <span class='hs-comment'>-- $originalIntro</span>
<a name="line-57"></a>
<a name="line-58"></a>
<a name="line-59"></a>  <span class='hs-comment'>-- * todo</span>
<a name="line-60"></a>  <span class='hs-comment'>-- $todo</span>
<a name="line-61"></a>
<a name="line-62"></a>  <span class='hs-comment'>-- * internal for type signature prettiness</span>
<a name="line-63"></a>  <span class='hs-conid'>TaggedToKW</span><span class='hs-layout'>,</span>
<a name="line-64"></a>  <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-65"></a>
<a name="line-66"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC</span><span class='hs-varop'>.</span><span class='hs-conid'>TypeLits</span>
<a name="line-67"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>HList</span><span class='hs-varop'>.</span><span class='hs-conid'>FakePrelude</span>
<a name="line-68"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>HList</span><span class='hs-varop'>.</span><span class='hs-conid'>TypeEqO</span>
<a name="line-69"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>HList</span><span class='hs-varop'>.</span><span class='hs-conid'>HListPrelude</span>
<a name="line-70"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>HList</span><span class='hs-varop'>.</span><span class='hs-conid'>HList</span>
<a name="line-71"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>HList</span><span class='hs-varop'>.</span><span class='hs-conid'>Record</span>
<a name="line-72"></a>
<a name="line-73"></a><span class='hs-comment'>{- $setup
<a name="line-74"></a>
<a name="line-75"></a> &gt;&gt;&gt; :set -XDataKinds -XFlexibleInstances -XMultiParamTypeClasses
<a name="line-76"></a> &gt;&gt;&gt; :set -XScopedTypeVariables -XOverlappingInstances -XTypeFamilies
<a name="line-77"></a> &gt;&gt;&gt; :set -fcontext-stack=100
<a name="line-78"></a>
<a name="line-79"></a>We will be using an example inspired by a graphics toolkit -- the area
<a name="line-80"></a>which really benefits from keyword arguments. We first define our
<a name="line-81"></a>labels and useful datatypes
<a name="line-82"></a>
<a name="line-83"></a> &gt;&gt;&gt; data Color = Color
<a name="line-84"></a> &gt;&gt;&gt; data Size  = Size
<a name="line-85"></a> &gt;&gt;&gt; data Origin  = Origin
<a name="line-86"></a> &gt;&gt;&gt; data RaisedBorder = RaisedBorder
<a name="line-87"></a>
<a name="line-88"></a>
<a name="line-89"></a>The number of arguments each keyword must be specified by an 'IsKeyFN'
<a name="line-90"></a>instance.
<a name="line-91"></a>
<a name="line-92"></a> &gt;&gt;&gt; instance IsKeyFN (Color-&gt;a-&gt;b)  True
<a name="line-93"></a> &gt;&gt;&gt; instance IsKeyFN (Size-&gt;a-&gt;b)   True
<a name="line-94"></a> &gt;&gt;&gt; instance (a ~ (Int,Int)) =&gt; IsKeyFN (Origin-&gt;a-&gt;b) True
<a name="line-95"></a> &gt;&gt;&gt; instance IsKeyFN (RaisedBorder-&gt;a-&gt;b) True
<a name="line-96"></a>
<a name="line-97"></a>Note that if a keyword is always followed by a certain type, that
<a name="line-98"></a>can be specified above using an instance like the one for Origin.
<a name="line-99"></a>
<a name="line-100"></a> &gt;&gt;&gt; data CommonColor = Red | Green | Blue deriving Show
<a name="line-101"></a> &gt;&gt;&gt; data RGBColor = RGBColor Int Int Int deriving Show
<a name="line-102"></a>
<a name="line-103"></a>and two functions:
<a name="line-104"></a>
<a name="line-105"></a> &gt;&gt;&gt; :{
<a name="line-106"></a> let make_square Size n Origin (x0,y0) Color (color::CommonColor) =
<a name="line-107"></a>        unwords ["Square:", show (n :: Int), "at", show (x0,y0), show color] ++ "\n"
<a name="line-108"></a> :}
<a name="line-109"></a>
<a name="line-110"></a> &gt;&gt;&gt; :{
<a name="line-111"></a> let make_rect Size (nx,ny) Origin (x0,y0) Color (color::RGBColor)
<a name="line-112"></a>         RaisedBorder border =
<a name="line-113"></a>        unwords ["Rectangle:", show (nx,ny), "at", show (x0,y0),
<a name="line-114"></a>             show color, if border then "raised border" else ""] ++ "\n"
<a name="line-115"></a> :}
<a name="line-116"></a>
<a name="line-117"></a>-}</span>
<a name="line-118"></a>
<a name="line-119"></a><span class='hs-comment'>{- $ex2
<a name="line-120"></a>
<a name="line-121"></a>We are not interested in really drawing squares and rectangles
<a name="line-122"></a>here. Therefore, make_square and make_rect return a String, which we
<a name="line-123"></a>can regard as a ``command'' to be passed to a low-level graphics
<a name="line-124"></a>library. The functions make_square and make_rect are genuine functions
<a name="line-125"></a>and can be used as such. They are not keyword argument functions, yet,
<a name="line-126"></a>but they set the stage. These functions can be considered an
<a name="line-127"></a>`interface' for the keyword argument functions. We should note that
<a name="line-128"></a>the functions are polymorphic: for example, `Size' can be any
<a name="line-129"></a>showable. We must also emphasize the re-use of the labels: The Color
<a name="line-130"></a>of a square is the value of the enumerated type CommonColor. OTH, the
<a name="line-131"></a>color of the rectangle is given as an RGB triple. The sizes of the
<a name="line-132"></a>square and of the rectangle are specified differently too, the same
<a name="line-133"></a>label notwithstanding.
<a name="line-134"></a>
<a name="line-135"></a>Once the user wrote the functions such as make_square and make_rect,
<a name="line-136"></a>he can _automatically_ convert them to their keyword
<a name="line-137"></a>alternatives. This transformation is done by a function 'kw'. The user
<a name="line-138"></a>should pass the positional-argument function (`labeled' as above),
<a name="line-139"></a>and an HList of default values for some of the labels. The latter may
<a name="line-140"></a>be HNil if all keyword arguments are required.
<a name="line-141"></a>
<a name="line-142"></a>The first example (no defaults)
<a name="line-143"></a>
<a name="line-144"></a> &gt;&gt;&gt; kw (make_square .*. HNil) Size (1::Int) Origin (0,10) Color Red   :: String
<a name="line-145"></a> "Square: 1 at (0,10) Red\n"
<a name="line-146"></a>
<a name="line-147"></a>we can permute the arguments at wish
<a name="line-148"></a>
<a name="line-149"></a> &gt;&gt;&gt; kw (make_square .*. HNil) Color Red Size (1::Int) Origin (0,10)   :: String
<a name="line-150"></a> "Square: 1 at (0,10) Red\n"
<a name="line-151"></a>
<a name="line-152"></a>we can also assign a name to a keyword function, or partially apply it:
<a name="line-153"></a>
<a name="line-154"></a> &gt;&gt;&gt; :{
<a name="line-155"></a> case kw (make_square .*. HNil) Color Red of
<a name="line-156"></a>    f -&gt; "here: " ++ f Origin (0,10) Size (1::Int)
<a name="line-157"></a>:}
<a name="line-158"></a>"here: Square: 1 at (0,10) Red\n"
<a name="line-159"></a>
<a name="line-160"></a>Note that it is necessary to use a monomorphic pattern binding here (lambda or
<a name="line-161"></a>case). One way to get around this is to pass @f@ instead of @kw f@ around:
<a name="line-162"></a>
<a name="line-163"></a>&gt;&gt;&gt; :{
<a name="line-164"></a> let f = hEnd $ hBuild make_square Color Red
<a name="line-165"></a> in "here: " ++ kw f Origin (0,10) Size (1::Int)
<a name="line-166"></a>:}
<a name="line-167"></a>"here: Square: 1 at (0,10) Red\n"
<a name="line-168"></a>
<a name="line-169"></a>The following is a more interesting example, with the
<a name="line-170"></a>defaults:
<a name="line-171"></a>
<a name="line-172"></a> &gt;&gt;&gt; :{
<a name="line-173"></a>let addDef f = f .*. Origin .*. (0,10) .*.
<a name="line-174"></a>             RaisedBorder .*. True .*.
<a name="line-175"></a>             HNil
<a name="line-176"></a>    in kw (addDef make_square) Size (1::Int) Color Red ++
<a name="line-177"></a>       kw (addDef make_rect)   Color (RGBColor 0 10 255)
<a name="line-178"></a>                               Size (1.0::Float, 2.0::Float)
<a name="line-179"></a>:}
<a name="line-180"></a>"Square: 1 at (0,10) Red\nRectangle: (1.0,2.0) at (0,10) RGBColor 0 10 255 raised border\n"
<a name="line-181"></a>
<a name="line-182"></a>The argument RaisedBorder is not given, and so the default value is
<a name="line-183"></a>used. Of course, we can override the default:
<a name="line-184"></a>
<a name="line-185"></a> &gt;&gt;&gt; :{
<a name="line-186"></a>let addDef f =  f .*. Origin .*. (0,10) .*.
<a name="line-187"></a>                    RaisedBorder .*. True .*.
<a name="line-188"></a>                    HNil
<a name="line-189"></a> in case kw (addDef make_square) Color of
<a name="line-190"></a>     sq -&gt; case kw (addDef make_rect)  of
<a name="line-191"></a>      re -&gt;
<a name="line-192"></a>         sq Red Size (1::Int) ++
<a name="line-193"></a>         re Color (RGBColor 0 10 255)
<a name="line-194"></a>             RaisedBorder False
<a name="line-195"></a>             Size (1.0::Float, 2.0::Float)
<a name="line-196"></a>:}
<a name="line-197"></a>"Square: 1 at (0,10) Red\nRectangle: (1.0,2.0) at (0,10) RGBColor 0 10 255 \n"
<a name="line-198"></a>
<a name="line-199"></a>We have reshuffled a few arguments, just for fun. As you can see, the
<a name="line-200"></a>function `kw make_rect defaults' is polyvariadic indeed.  We chose to
<a name="line-201"></a>partially apply 'Color' to the function `kw make_square defaults' --
<a name="line-202"></a>so that the function `sq' is positional in its first argument, and
<a name="line-203"></a>keyword in the rest.
<a name="line-204"></a>
<a name="line-205"></a>If we omit a required argument, we get a type error:
<a name="line-206"></a>
<a name="line-207"></a>&gt; ] testse1 = let f x = kw make_square HNil Color Red x
<a name="line-208"></a>&gt; ]         in "here: " ++ f Origin (0,10)
<a name="line-209"></a>&gt;
<a name="line-210"></a>&gt;   Couldn't match `ErrReqdArgNotFound Size' against `[Char]'
<a name="line-211"></a>&gt;       Expected type: ErrReqdArgNotFound Size
<a name="line-212"></a>&gt;       Inferred type: [Char] ...
<a name="line-213"></a>
<a name="line-214"></a>The error message seems reasonably clear. Likewise we get an error
<a name="line-215"></a>message if we pass to a keyword function an argument it does not expect:
<a name="line-216"></a>
<a name="line-217"></a>&gt; ] testse2 = let f x = kw make_square HNil Color Red x
<a name="line-218"></a>&gt; ]         in "here: " ++ f Origin (0,10) Size (1::Int)
<a name="line-219"></a>&gt; ]                       RaisedBorder False
<a name="line-220"></a>&gt;
<a name="line-221"></a>&gt;   No instances for (Fail (ErrUnexpectedKW RaisedBorder),
<a name="line-222"></a>&gt;             KWApply [Char] (HCons RaisedBorder (:*: Bool HNil)) [Char])
<a name="line-223"></a>&gt;       arising from use of `f' at ...
<a name="line-224"></a>&gt;     In the second argument of `(++)', namely
<a name="line-225"></a>&gt;   `f Origin (0,10) Size (1 :: Int) RaisedBorder False'
<a name="line-226"></a>
<a name="line-227"></a>
<a name="line-228"></a>The function 'kw' receives the appropriately labeled function (such
<a name="line-229"></a>as make_square) and the HList with default values. The function 'kw'
<a name="line-230"></a>is polymorphic; the overloading is resolved based on the type of the
<a name="line-231"></a>user function *and* on the type of its continuation. The continuation
<a name="line-232"></a>indicates if a keyword argument is forthcoming, or not. In the latter
<a name="line-233"></a>case, 'kw' checks to see if the supplied defaults can provide the
<a name="line-234"></a>values of the still missing arguments. We see therefore that a
<a name="line-235"></a>function type is more than it may appear -- the type of a function is
<a name="line-236"></a>truly a heterogeneous, type level collection! The function 'kw'
<a name="line-237"></a>traverses that collection, thus performing a limited form of
<a name="line-238"></a>reflection on Haskell functions.
<a name="line-239"></a>
<a name="line-240"></a>-}</span>
<a name="line-241"></a>
<a name="line-242"></a>
<a name="line-243"></a><span class='hs-comment'>{- $imploutline
<a name="line-244"></a>
<a name="line-245"></a>One of the key tools of the implementation is 'kwapply', which applies
<a name="line-246"></a>a function to a polymorphic collection of that function's arguments.
<a name="line-247"></a>The order of the arguments in the collection is irrelevant. The
<a name="line-248"></a>contraption kwapply can handle polymorphic functions with arbitrary
<a name="line-249"></a>number of labeled arguments.
<a name="line-250"></a>
<a name="line-251"></a>For example, if we define
<a name="line-252"></a>
<a name="line-253"></a>&gt; f1 Size n = show n
<a name="line-254"></a>&gt; f2 Size n Color m = unwords ["size:", show n, "color:", show m]
<a name="line-255"></a>&gt; f3 Origin x Color m Size n =
<a name="line-256"></a>&gt;     unwords ["origin:", show x, "size:", show n, "color:",show m]
<a name="line-257"></a>
<a name="line-258"></a>then we can run
<a name="line-259"></a>
<a name="line-260"></a>&gt; katest1  = kwapply f1 (Size .*. () .*. HNil)
<a name="line-261"></a>&gt; katest11 = kwapply f1 (Size .*. "Large" .*. HNil)
<a name="line-262"></a>&gt;
<a name="line-263"></a>&gt; katest2  = kwapply f2 (Size .*. (1::Int) .*. Color .*. Red .*. HNil)
<a name="line-264"></a>&gt; katest21 = kwapply f2 (Color .*. Red .*. Size .*. (1::Int) .*.  HNil)
<a name="line-265"></a>&gt;
<a name="line-266"></a>&gt; katest3  = kwapply f3 (Size .*. (1::Int) .*. Origin .*. (2.0::Float) .*.
<a name="line-267"></a>&gt;                  Color .*. Red .*. HNil)
<a name="line-268"></a>
<a name="line-269"></a>-}</span>
<a name="line-270"></a>
<a name="line-271"></a>
<a name="line-272"></a><span class='hs-comment'>-- | Another key contraption is</span>
<a name="line-273"></a>
<a name="line-274"></a><a name="reflect_fk"></a><span class='hs-definition'>reflect_fk</span><span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>ReflectFK</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>kws</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>fn</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Arg</span> <span class='hs-varid'>kws</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span>
<a name="line-275"></a><span class='hs-definition'>reflect_fk</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Arg</span> <span class='hs-conid'>HNil</span>
<a name="line-276"></a>
<a name="line-277"></a><span class='hs-comment'>{- ^
<a name="line-278"></a>
<a name="line-279"></a>that reflects on a user-supplied function. It converts the *type* of a
<a name="line-280"></a>user function to a collection of keywords required by that
<a name="line-281"></a>function. This and the previous contraptions may be used to define an
<a name="line-282"></a>`extended' version of some user function that takes more arguments --
<a name="line-283"></a>without the need to enumerate all arguments of the original
<a name="line-284"></a>function. We thus infringe on the area of object and module systems.
<a name="line-285"></a>
<a name="line-286"></a>The rest of the implementation is just to convert `kw fn defaults'
<a name="line-287"></a>into the application of kwapply.
<a name="line-288"></a>
<a name="line-289"></a>-}</span>
<a name="line-290"></a>
<a name="line-291"></a>
<a name="line-292"></a><span class='hs-comment'>-- * The rest of the implementation</span>
<a name="line-293"></a><span class='hs-comment'>{- $impl
<a name="line-294"></a>
<a name="line-295"></a>We should note that all implementation is written in the
<a name="line-296"></a>continuation-passing style (CPS) -- at the term level and especially
<a name="line-297"></a>at the _typeclass level_. One of the reasons is to avoid relying on
<a name="line-298"></a>overlapping instances: we compare types with a predicate `TypeEq x y
<a name="line-299"></a>hbool', obtain the type-level boolean, and dispatch to two
<a name="line-300"></a>non-overlapping instances of an auxiliary, continuation class. One
<a name="line-301"></a>instance handles HTrue, and the other the HFalse alternative. Please
<a name="line-302"></a>see the HList paper for more discussion of this technique.
<a name="line-303"></a>
<a name="line-304"></a>The other, equally important reason for the thorough CPS of the
<a name="line-305"></a>typeclasses is to control the order of evaluation of constraints and
<a name="line-306"></a>their functional dependencies. The sole reason is to produce
<a name="line-307"></a>informative error messages. The order of constraints is irrelevant
<a name="line-308"></a>when all the constraints are satisfied. However, if the user omitted a
<a name="line-309"></a>required keyword, many of the constraints below will fail. If a
<a name="line-310"></a>'wrong' constraint fails first, we get a totally off-the-wall error
<a name="line-311"></a>message that gives us no clue whatsoever about the problem. By tightly
<a name="line-312"></a>constraining the order via CPS, we are able to force the typechecker
<a name="line-313"></a>to give informative error messages.
<a name="line-314"></a>
<a name="line-315"></a>-}</span>
<a name="line-316"></a>
<a name="line-317"></a>
<a name="line-318"></a>
<a name="line-319"></a><span class='hs-comment'>-- * Errors</span>
<a name="line-320"></a>
<a name="line-321"></a><a name="IsKeyFN"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>ErrReqdArgNotFound</span> <span class='hs-varid'>x</span>
<a name="line-322"></a><a name="IsKeyFN"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>ErrUnexpectedKW</span> <span class='hs-varid'>x</span>
<a name="line-323"></a>
<a name="line-324"></a>
<a name="line-325"></a><a name="instance%20IsKeyFN%20(%20(K%20s%20c)%20-%3e%20r)%20True%20data%20K%20s%20(c%20::%20*)%20=%20K%20--%20*%20The%20implementation%20of%20KWApply%20class%20KWApply%20f%20arg_values%20r"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>IsKeyFN</span> <span class='hs-layout'>(</span><span class='hs-conid'>Label</span> <span class='hs-layout'>(</span><span class='hs-varid'>s</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Symbol</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-conid'>True</span>
<a name="line-326"></a><span class='hs-comment'>{- ^ labels that impose no restriction on the type of the (single) argument
<a name="line-327"></a> which follows
<a name="line-328"></a>
<a name="line-329"></a> &gt;&gt;&gt; let testF (_ :: Label "a") (a :: Int) () = a+1
<a name="line-330"></a> &gt;&gt;&gt; kw (hBuild testF) (Label :: Label "a") 5 ()
<a name="line-331"></a> 6
<a name="line-332"></a>
<a name="line-333"></a>-}</span>
<a name="line-334"></a>
<a name="line-335"></a><a name="instance%20IsKeyFN%20(%20(K%20s%20c)%20-%3e%20r)%20True%20data%20K%20s%20(c%20::%20*)%20=%20K%20--%20*%20The%20implementation%20of%20KWApply%20class%20KWApply%20f%20arg_values%20r"></a><span class='hs-comment'>{- | The purpose of this instance is to be able to use the same Symbol
<a name="line-336"></a> (type-level string) at different types. If they are supposed to be the same,
<a name="line-337"></a> then use 'Label' instead of 'K'
<a name="line-338"></a>
<a name="line-339"></a> &gt;&gt;&gt; let kA = K :: forall t. K "a" t
<a name="line-340"></a> &gt;&gt;&gt; let testF (K :: K "a" Int) a1 (K :: K "a" Integer) a2 () = a1-fromIntegral a2
<a name="line-341"></a>
<a name="line-342"></a> therefore the following options works:
<a name="line-343"></a>
<a name="line-344"></a> &gt;&gt;&gt; kw (hBuild testF) kA (5 :: Int) kA (3 :: Integer) ()
<a name="line-345"></a> 2
<a name="line-346"></a>
<a name="line-347"></a> &gt;&gt;&gt; kw (hBuild testF) (K :: K "a" Integer) 3 (K :: K "a" Int) 5 ()
<a name="line-348"></a> 2
<a name="line-349"></a>
<a name="line-350"></a> But you cannot leave off all @Int@ or @Integer@ annotations.
<a name="line-351"></a>
<a name="line-352"></a>-}</span>
<a name="line-353"></a><a name="instance%20IsKeyFN%20(%20(K%20s%20c)%20-%3e%20r)%20True%20data%20K%20s%20(c%20::%20*)%20=%20K%20--%20*%20The%20implementation%20of%20KWApply%20class%20KWApply%20f%20arg_values%20r"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-varid'>r</span> <span class='hs-keyglyph'>~</span> <span class='hs-layout'>(</span><span class='hs-varid'>c</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>IsKeyFN</span> <span class='hs-layout'>(</span> <span class='hs-layout'>(</span><span class='hs-conid'>K</span> <span class='hs-varid'>s</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-conid'>True</span>
<a name="line-354"></a>
<a name="line-355"></a><a name="K"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>K</span> <span class='hs-varid'>s</span> <span class='hs-layout'>(</span><span class='hs-varid'>c</span> <span class='hs-keyglyph'>::</span> <span class='hs-varop'>*</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>K</span>
<a name="line-356"></a>
<a name="line-357"></a>
<a name="line-358"></a><span class='hs-comment'>-- * The implementation of KWApply</span>
<a name="line-359"></a>
<a name="line-360"></a><a name="KWApply"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>KWApply</span> <span class='hs-varid'>f</span> <span class='hs-varid'>arg_values</span> <span class='hs-varid'>r</span> <span class='hs-keyword'>where</span>
<a name="line-361"></a>    <span class='hs-varid'>kwapply</span><span class='hs-keyglyph'>::</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>arg_values</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>r</span>
<a name="line-362"></a>
<a name="line-363"></a><a name="instance%20KWApply%20r%20'%5b%5d%20r'"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-varid'>r</span> <span class='hs-keyglyph'>~</span> <span class='hs-varid'>r'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>KWApply</span> <span class='hs-varid'>r</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span> <span class='hs-varid'>r'</span> <span class='hs-keyword'>where</span>
<a name="line-364"></a>    <span class='hs-varid'>kwapply</span> <span class='hs-varid'>f</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span>
<a name="line-365"></a>
<a name="line-366"></a><a name="instance%20KWApply%20(kw%20-%3ea-%3ef')%20(kw'%20':%20a'%20':%20tail)%20r"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>HEq</span> <span class='hs-varid'>kw</span> <span class='hs-varid'>kw'</span> <span class='hs-varid'>flag</span><span class='hs-layout'>,</span>
<a name="line-367"></a>      <span class='hs-conid'>KWApply'</span> <span class='hs-varid'>flag</span> <span class='hs-layout'>(</span><span class='hs-varid'>kw</span> <span class='hs-keyglyph'>-&gt;</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>-&gt;</span><span class='hs-varid'>f'</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>kw'</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>a'</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>tail</span><span class='hs-layout'>)</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<a name="line-368"></a>    <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>KWApply</span> <span class='hs-layout'>(</span><span class='hs-varid'>kw</span> <span class='hs-keyglyph'>-&gt;</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>-&gt;</span><span class='hs-varid'>f'</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>kw'</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>a'</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>tail</span><span class='hs-layout'>)</span> <span class='hs-varid'>r</span> <span class='hs-keyword'>where</span>
<a name="line-369"></a>    <span class='hs-varid'>kwapply</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>kwapply'</span> <span class='hs-layout'>(</span><span class='hs-conid'>Proxy</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Proxy</span> <span class='hs-varid'>flag</span><span class='hs-layout'>)</span>
<a name="line-370"></a>
<a name="line-371"></a><a name="KWApply'"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>KWApply'</span> <span class='hs-varid'>flag</span> <span class='hs-varid'>f</span> <span class='hs-varid'>arg_values</span> <span class='hs-varid'>r</span>  <span class='hs-keyword'>where</span>
<a name="line-372"></a>    <span class='hs-varid'>kwapply'</span><span class='hs-keyglyph'>::</span> <span class='hs-conid'>Proxy</span> <span class='hs-varid'>flag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>arg_values</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>r</span>
<a name="line-373"></a>
<a name="line-374"></a><a name="instance%20KWApply'%20True%20(kw-%3ev-%3ef')%20(kw%20':%20v'%20':%20tail)%20r"></a><span class='hs-keyword'>instance</span>  <span class='hs-layout'>(</span><span class='hs-varid'>v'</span> <span class='hs-keyglyph'>~</span> <span class='hs-varid'>v</span><span class='hs-layout'>,</span> <span class='hs-conid'>KWApply</span> <span class='hs-varid'>f'</span> <span class='hs-varid'>tail</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<a name="line-375"></a>    <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>KWApply'</span> <span class='hs-conid'>True</span> <span class='hs-layout'>(</span><span class='hs-varid'>kw</span><span class='hs-keyglyph'>-&gt;</span><span class='hs-varid'>v</span><span class='hs-keyglyph'>-&gt;</span><span class='hs-varid'>f'</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>kw</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>v'</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>tail</span><span class='hs-layout'>)</span> <span class='hs-varid'>r</span> <span class='hs-keyword'>where</span>
<a name="line-376"></a>    <span class='hs-varid'>kwapply'</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>HCons</span> <span class='hs-varid'>kw_</span> <span class='hs-layout'>(</span><span class='hs-conid'>HCons</span> <span class='hs-varid'>v'</span> <span class='hs-varid'>tl</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-377"></a>                   <span class='hs-varid'>kwapply</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>kw_</span> <span class='hs-varid'>v'</span><span class='hs-layout'>)</span> <span class='hs-varid'>tl</span>
<a name="line-378"></a>
<a name="line-379"></a><a name="instance%20KWApply'%20False%20f%20(kw%20':%20v%20':%20tail)%20r"></a><span class='hs-comment'>-- | Rotate the arg list ...</span>
<a name="line-380"></a><a name="instance%20KWApply'%20False%20f%20(kw%20':%20v%20':%20tail)%20r"></a><span class='hs-keyword'>instance</span>  <span class='hs-layout'>(</span><span class='hs-conid'>HAppendListR</span> <span class='hs-varid'>tail</span> <span class='hs-chr'>'</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>kw</span> <span class='hs-layout'>,</span> <span class='hs-varid'>v</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>~</span> <span class='hs-varid'>l'</span><span class='hs-layout'>,</span>
<a name="line-381"></a>           <span class='hs-conid'>HAppendList</span> <span class='hs-varid'>tail</span> <span class='hs-chr'>'</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>kw</span><span class='hs-layout'>,</span> <span class='hs-varid'>v</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>
<a name="line-382"></a>       <span class='hs-conid'>KWApply</span> <span class='hs-varid'>f</span> <span class='hs-varid'>l'</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<a name="line-383"></a>    <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>KWApply'</span> <span class='hs-conid'>False</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>kw</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>v</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>tail</span><span class='hs-layout'>)</span> <span class='hs-varid'>r</span> <span class='hs-keyword'>where</span>
<a name="line-384"></a>    <span class='hs-varid'>kwapply'</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>HCons</span> <span class='hs-varid'>kw_</span> <span class='hs-layout'>(</span><span class='hs-conid'>HCons</span> <span class='hs-varid'>v</span> <span class='hs-varid'>tl</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-385"></a>      <span class='hs-varid'>kwapply</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>hAppend</span> <span class='hs-varid'>tl</span> <span class='hs-layout'>(</span><span class='hs-varid'>kw_</span> <span class='hs-varop'>.*.</span> <span class='hs-varid'>v</span> <span class='hs-varop'>.*.</span> <span class='hs-conid'>HNil</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-386"></a>
<a name="line-387"></a><span class='hs-comment'>{- |
<a name="line-388"></a>
<a name="line-389"></a>The datatype Arg below is to maintain the state of keyword
<a name="line-390"></a>accumulation: which keywords we need, and which keyword and values we
<a name="line-391"></a>have already got.
<a name="line-392"></a>arg_types is the phantom HList of keywords that are yet to be satisfied.
<a name="line-393"></a>arg_values is the @HList (kw .*. kw_value .*. etc)@
<a name="line-394"></a>of already found keywords and their values.
<a name="line-395"></a>-}</span>
<a name="line-396"></a>
<a name="line-397"></a><a name="Arg"></a><span class='hs-keyword'>newtype</span> <span class='hs-conid'>Arg</span> <span class='hs-varid'>arg_types</span> <span class='hs-varid'>arg_values</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Arg</span> <span class='hs-layout'>(</span><span class='hs-conid'>HList</span> <span class='hs-varid'>arg_values</span><span class='hs-layout'>)</span>
<a name="line-398"></a><span class='hs-keyword'>deriving</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>Show</span> <span class='hs-layout'>(</span><span class='hs-conid'>HList</span> <span class='hs-varid'>vals</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Show</span> <span class='hs-layout'>(</span><span class='hs-conid'>Arg</span> <span class='hs-varid'>tys</span> <span class='hs-varid'>vals</span><span class='hs-layout'>)</span>
<a name="line-399"></a>
<a name="line-400"></a><span class='hs-comment'>{- | Reflection on a function:
<a name="line-401"></a>Given a function, return the type list of its keywords
<a name="line-402"></a>
<a name="line-403"></a>&gt;&gt;&gt; :t reflect_fk (undefined::Size-&gt;Int-&gt;Color-&gt;CommonColor-&gt;String)
<a name="line-404"></a>reflect_fk (undefined::Size-&gt;Int-&gt;Color-&gt;CommonColor-&gt;String)
<a name="line-405"></a>  :: Arg '[Size, Color] '[]
<a name="line-406"></a>
<a name="line-407"></a>&gt;&gt;&gt; :t reflect_fk (undefined::Size-&gt;Int-&gt;()-&gt;Int)
<a name="line-408"></a>reflect_fk (undefined::Size-&gt;Int-&gt;()-&gt;Int) :: Arg '[Size] '[]
<a name="line-409"></a>
<a name="line-410"></a>
<a name="line-411"></a>-}</span>
<a name="line-412"></a>
<a name="line-413"></a><a name="ReflectFK"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>ReflectFK</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>kws</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varop'>*</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-414"></a><a name="instance%20ReflectFK%20f%20kws%20class%20ReflectFK'%20(flag%20::%20Bool)%20f%20kws%20instance%20(kkws%20~%20(kw%20':%20kws),%20ReflectFK%20rest%20kws)%20=%3e%20ReflectFK'%20True%20(kw-%3ea-%3erest)%20kkws%20instance%20('%5b%5d%20~%20nil)%20=%3e%20ReflectFK'%20False%20f%20nil%20--%20%7c%20The%20main%20class:%20collect%20and%20apply%20the%20keyword%20arguments%20class%20KW%20f%20arg_desc%20arg_def%20r"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>IsKeyFN</span> <span class='hs-varid'>f</span> <span class='hs-varid'>flag</span><span class='hs-layout'>,</span> <span class='hs-conid'>ReflectFK'</span> <span class='hs-varid'>flag</span> <span class='hs-varid'>f</span> <span class='hs-varid'>kws</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>ReflectFK</span> <span class='hs-varid'>f</span> <span class='hs-varid'>kws</span>
<a name="line-415"></a><a name="ReflectFK'"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>ReflectFK'</span> <span class='hs-layout'>(</span><span class='hs-varid'>flag</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-varid'>f</span> <span class='hs-varid'>kws</span>
<a name="line-416"></a><a name="instance%20ReflectFK'%20True%20(kw-%3ea-%3erest)%20kkws%20instance%20('%5b%5d%20~%20nil)%20=%3e%20ReflectFK'%20False%20f%20nil%20--%20%7c%20The%20main%20class:%20collect%20and%20apply%20the%20keyword%20arguments%20class%20KW%20f%20arg_desc%20arg_def%20r"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-varid'>kkws</span> <span class='hs-keyglyph'>~</span> <span class='hs-layout'>(</span><span class='hs-varid'>kw</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>kws</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>ReflectFK</span> <span class='hs-varid'>rest</span> <span class='hs-varid'>kws</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>ReflectFK'</span> <span class='hs-conid'>True</span> <span class='hs-layout'>(</span><span class='hs-varid'>kw</span><span class='hs-keyglyph'>-&gt;</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>-&gt;</span><span class='hs-varid'>rest</span><span class='hs-layout'>)</span> <span class='hs-varid'>kkws</span>
<a name="line-417"></a><a name="instance%20ReflectFK'%20False%20f%20nil%20--%20%7c%20The%20main%20class:%20collect%20and%20apply%20the%20keyword%20arguments%20class%20KW%20f%20arg_desc%20arg_def%20r"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-chr'>'</span><span class='hs-conid'>[]</span> <span class='hs-keyglyph'>~</span> <span class='hs-varid'>nil</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>ReflectFK'</span> <span class='hs-conid'>False</span> <span class='hs-varid'>f</span> <span class='hs-varid'>nil</span>
<a name="line-418"></a>
<a name="line-419"></a>
<a name="line-420"></a><span class='hs-comment'>-- | The main class: collect and apply the keyword arguments</span>
<a name="line-421"></a>
<a name="line-422"></a><a name="KW"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>KW</span> <span class='hs-varid'>f</span> <span class='hs-varid'>arg_desc</span> <span class='hs-varid'>arg_def</span> <span class='hs-varid'>r</span> <span class='hs-keyword'>where</span>
<a name="line-423"></a>    <span class='hs-varid'>kwdo</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>arg_desc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>arg_def</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>r</span>
<a name="line-424"></a>
<a name="line-425"></a><a name="instance%20KW%20f%20arg_desc%20arg_def%20r"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>IsKeyFN</span> <span class='hs-varid'>r</span> <span class='hs-varid'>rflag</span><span class='hs-layout'>,</span>
<a name="line-426"></a>        <span class='hs-conid'>KW'</span> <span class='hs-varid'>rflag</span> <span class='hs-varid'>f</span> <span class='hs-varid'>arg_desc</span> <span class='hs-varid'>arg_def</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<a name="line-427"></a>    <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>KW</span> <span class='hs-varid'>f</span> <span class='hs-varid'>arg_desc</span> <span class='hs-varid'>arg_def</span> <span class='hs-varid'>r</span> <span class='hs-keyword'>where</span>
<a name="line-428"></a>    <span class='hs-varid'>kwdo</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>kw'</span> <span class='hs-layout'>(</span><span class='hs-conid'>Proxy</span> <span class='hs-keyglyph'>::</span><span class='hs-conid'>Proxy</span> <span class='hs-varid'>rflag</span><span class='hs-layout'>)</span>
<a name="line-429"></a>
<a name="line-430"></a><a name="KW'"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>KW'</span> <span class='hs-varid'>rflag</span> <span class='hs-varid'>f</span> <span class='hs-varid'>arg_desc</span> <span class='hs-varid'>arg_def</span> <span class='hs-varid'>r</span> <span class='hs-keyword'>where</span>
<a name="line-431"></a>    <span class='hs-varid'>kw'</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Proxy</span> <span class='hs-varid'>rflag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>arg_desc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>arg_def</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>r</span>
<a name="line-432"></a>
<a name="line-433"></a><span class='hs-comment'>{- |
<a name="line-434"></a>If the continuation r does not promise any more keyword
<a name="line-435"></a>arguments, apply the defaults -}</span>
<a name="line-436"></a>
<a name="line-437"></a><a name="instance%20KW'%20False%20f%20(Arg%20arg_needed%20arg_values)%20arg_def%20r"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>KWMerge</span> <span class='hs-varid'>arg_needed</span> <span class='hs-varid'>arg_values</span> <span class='hs-varid'>arg_def</span> <span class='hs-varid'>f</span> <span class='hs-varid'>r</span>
<a name="line-438"></a>    <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>KW'</span> <span class='hs-conid'>False</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>Arg</span> <span class='hs-varid'>arg_needed</span> <span class='hs-varid'>arg_values</span><span class='hs-layout'>)</span> <span class='hs-varid'>arg_def</span> <span class='hs-varid'>r</span> <span class='hs-keyword'>where</span>
<a name="line-439"></a>    <span class='hs-varid'>kw'</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>f</span> <span class='hs-varid'>args_given</span> <span class='hs-varid'>arg_def</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>kwmerge</span> <span class='hs-varid'>args_given</span> <span class='hs-varid'>arg_def</span> <span class='hs-varid'>f</span>
<a name="line-440"></a>
<a name="line-441"></a><span class='hs-comment'>{- | Otherwise, collect the supplied keyword and its value, and recurse for
<a name="line-442"></a>more: -}</span>
<a name="line-443"></a>
<a name="line-444"></a><a name="instance%20KW'%20True%20f%20arg_desc%20arg_def%20kwar"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>KWAcc</span> <span class='hs-varid'>arg_desc</span> <span class='hs-varid'>kw</span> <span class='hs-varid'>a</span> <span class='hs-varid'>f</span> <span class='hs-varid'>arg_def</span> <span class='hs-varid'>r</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>kw</span><span class='hs-keyglyph'>-&gt;</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>-&gt;</span><span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>~</span> <span class='hs-varid'>kwar</span><span class='hs-layout'>)</span>
<a name="line-445"></a>    <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>KW'</span> <span class='hs-conid'>True</span> <span class='hs-varid'>f</span> <span class='hs-varid'>arg_desc</span> <span class='hs-varid'>arg_def</span> <span class='hs-varid'>kwar</span> <span class='hs-keyword'>where</span>
<a name="line-446"></a>    <span class='hs-varid'>kw'</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>f</span> <span class='hs-varid'>arg_desc</span> <span class='hs-varid'>arg_def</span> <span class='hs-varid'>kw_</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>kwaccum</span> <span class='hs-varid'>arg_desc</span> <span class='hs-varid'>kw_</span> <span class='hs-varid'>a</span> <span class='hs-varid'>f</span> <span class='hs-varid'>arg_def</span>
<a name="line-447"></a>
<a name="line-448"></a>
<a name="line-449"></a><span class='hs-comment'>{- | Add the needed arguments from arg_def to arg_values and continue
<a name="line-450"></a>with kwapply.
<a name="line-451"></a>
<a name="line-452"></a>That is, we try to satisfy the missing arguments from the defaults.
<a name="line-453"></a>It will be a type error if some required arguments are missing -}</span>
<a name="line-454"></a>
<a name="line-455"></a><a name="KWMerge"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>KWMerge</span> <span class='hs-varid'>arg_needed</span> <span class='hs-varid'>arg_values</span> <span class='hs-varid'>arg_def</span> <span class='hs-varid'>f</span> <span class='hs-varid'>r</span> <span class='hs-keyword'>where</span>
<a name="line-456"></a>    <span class='hs-varid'>kwmerge</span><span class='hs-keyglyph'>::</span> <span class='hs-conid'>Arg</span> <span class='hs-varid'>arg_needed</span> <span class='hs-varid'>arg_values</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>arg_def</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>r</span>
<a name="line-457"></a>
<a name="line-458"></a><a name="instance%20KWMerge%20'%5b%5d%20arg_values%20arg_def%20f%20r"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>KWApply</span> <span class='hs-varid'>f</span> <span class='hs-varid'>arg_values</span> <span class='hs-varid'>r</span>
<a name="line-459"></a>    <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>KWMerge</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span> <span class='hs-varid'>arg_values</span> <span class='hs-varid'>arg_def</span> <span class='hs-varid'>f</span> <span class='hs-varid'>r</span> <span class='hs-keyword'>where</span>
<a name="line-460"></a>    <span class='hs-varid'>kwmerge</span> <span class='hs-layout'>(</span><span class='hs-conid'>Arg</span> <span class='hs-varid'>arg_values</span><span class='hs-layout'>)</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>kwapply</span> <span class='hs-varid'>f</span> <span class='hs-varid'>arg_values</span>
<a name="line-461"></a>
<a name="line-462"></a><a name="instance%20KWMerge%20(kw%20':%20atail)%20arg_values%20arg_def%20f%20r"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>KWMerge'</span> <span class='hs-varid'>kw</span> <span class='hs-varid'>arg_def</span> <span class='hs-varid'>atail</span> <span class='hs-varid'>arg_values</span> <span class='hs-varid'>arg_def</span> <span class='hs-varid'>f</span> <span class='hs-varid'>r</span>
<a name="line-463"></a>    <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>KWMerge</span> <span class='hs-layout'>(</span><span class='hs-varid'>kw</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>atail</span><span class='hs-layout'>)</span> <span class='hs-varid'>arg_values</span> <span class='hs-varid'>arg_def</span> <span class='hs-varid'>f</span> <span class='hs-varid'>r</span> <span class='hs-keyword'>where</span>
<a name="line-464"></a>    <span class='hs-varid'>kwmerge</span> <span class='hs-layout'>(</span><span class='hs-conid'>Arg</span> <span class='hs-varid'>arg_values</span><span class='hs-layout'>)</span> <span class='hs-varid'>arg_def</span> <span class='hs-keyglyph'>=</span>
<a name="line-465"></a>      <span class='hs-varid'>kwmerge'</span> <span class='hs-layout'>(</span><span class='hs-varid'>undefined</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>kw</span><span class='hs-layout'>)</span> <span class='hs-varid'>arg_def</span>
<a name="line-466"></a>             <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-conid'>Arg</span> <span class='hs-varid'>arg_values</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>::</span><span class='hs-conid'>Arg</span> <span class='hs-varid'>atail</span> <span class='hs-varid'>arg_values</span><span class='hs-layout'>)</span> <span class='hs-varid'>arg_def</span>
<a name="line-467"></a>
<a name="line-468"></a><a name="KWMerge'"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>KWMerge'</span> <span class='hs-varid'>kw</span> <span class='hs-varid'>list</span> <span class='hs-varid'>atail</span> <span class='hs-varid'>arg_values</span> <span class='hs-varid'>arg_def</span> <span class='hs-varid'>f</span> <span class='hs-varid'>r</span> <span class='hs-keyword'>where</span>
<a name="line-469"></a>    <span class='hs-varid'>kwmerge'</span><span class='hs-keyglyph'>::</span> <span class='hs-varid'>kw</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>list</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Arg</span> <span class='hs-varid'>atail</span> <span class='hs-varid'>arg_values</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>arg_def</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>r</span>
<a name="line-470"></a>
<a name="line-471"></a><a name="instance%20KWMerge'%20kw%20'%5b%5d%20atail%20arg_values%20arg_def%20f%20nff"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Fail</span> <span class='hs-layout'>(</span><span class='hs-conid'>ErrReqdArgNotFound</span> <span class='hs-varid'>kw</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>nff</span> <span class='hs-keyglyph'>~</span> <span class='hs-layout'>(</span><span class='hs-conid'>ErrReqdArgNotFound</span> <span class='hs-varid'>kw</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-472"></a>    <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>KWMerge'</span> <span class='hs-varid'>kw</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span> <span class='hs-varid'>atail</span> <span class='hs-varid'>arg_values</span> <span class='hs-varid'>arg_def</span> <span class='hs-varid'>f</span>
<a name="line-473"></a>                <span class='hs-varid'>nff</span> <span class='hs-keyword'>where</span>
<a name="line-474"></a>    <span class='hs-varid'>kwmerge'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>undefined</span>
<a name="line-475"></a><a name="instance%20KWMerge'%20kw%20(kw'%20':%20etc)%20atail%20arg_values%20arg_def%20f%20r"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>HEq</span> <span class='hs-varid'>kw</span> <span class='hs-varid'>kw'</span> <span class='hs-varid'>flag</span><span class='hs-layout'>,</span>
<a name="line-476"></a>      <span class='hs-conid'>KWMerge''</span> <span class='hs-varid'>flag</span> <span class='hs-varid'>kw</span> <span class='hs-layout'>(</span><span class='hs-varid'>kw'</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>etc</span><span class='hs-layout'>)</span> <span class='hs-varid'>atail</span> <span class='hs-varid'>arg_values</span> <span class='hs-varid'>arg_def</span> <span class='hs-varid'>f</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<a name="line-477"></a>    <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>KWMerge'</span> <span class='hs-varid'>kw</span> <span class='hs-layout'>(</span><span class='hs-varid'>kw'</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>etc</span><span class='hs-layout'>)</span> <span class='hs-varid'>atail</span> <span class='hs-varid'>arg_values</span> <span class='hs-varid'>arg_def</span> <span class='hs-varid'>f</span> <span class='hs-varid'>r</span> <span class='hs-keyword'>where</span>
<a name="line-478"></a>    <span class='hs-varid'>kwmerge'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>kwmerge''</span> <span class='hs-layout'>(</span><span class='hs-conid'>Proxy</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Proxy</span> <span class='hs-varid'>flag</span><span class='hs-layout'>)</span>
<a name="line-479"></a>
<a name="line-480"></a><a name="KWMerge''"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>KWMerge''</span> <span class='hs-layout'>(</span><span class='hs-varid'>flag</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-varid'>kw</span> <span class='hs-layout'>(</span><span class='hs-varid'>list</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varop'>*</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-varid'>atail</span> <span class='hs-varid'>arg_values</span> <span class='hs-varid'>arg_def</span> <span class='hs-varid'>f</span> <span class='hs-varid'>r</span>
<a name="line-481"></a>     <span class='hs-keyword'>where</span>
<a name="line-482"></a>    <span class='hs-varid'>kwmerge''</span><span class='hs-keyglyph'>::</span> <span class='hs-conid'>Proxy</span> <span class='hs-varid'>flag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>kw</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>list</span>
<a name="line-483"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Arg</span> <span class='hs-varid'>atail</span> <span class='hs-varid'>arg_values</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>arg_def</span>
<a name="line-484"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>r</span>
<a name="line-485"></a><a name="instance%20KWMerge''%20True%20kw%20(kw%20':%20v%20':%20tail)%20atail%20arg_values%20arg_def%20f%20r"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>KWMerge</span> <span class='hs-varid'>atail</span> <span class='hs-layout'>(</span><span class='hs-varid'>kw</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>v</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>arg_values</span><span class='hs-layout'>)</span> <span class='hs-varid'>arg_def</span> <span class='hs-varid'>f</span> <span class='hs-varid'>r</span>
<a name="line-486"></a>    <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>KWMerge''</span> <span class='hs-conid'>True</span> <span class='hs-varid'>kw</span> <span class='hs-layout'>(</span><span class='hs-varid'>kw</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>v</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>tail</span><span class='hs-layout'>)</span>
<a name="line-487"></a>                 <span class='hs-varid'>atail</span> <span class='hs-varid'>arg_values</span> <span class='hs-varid'>arg_def</span> <span class='hs-varid'>f</span> <span class='hs-varid'>r</span> <span class='hs-keyword'>where</span>
<a name="line-488"></a>    <span class='hs-varid'>kwmerge''</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>HCons</span> <span class='hs-varid'>kw_</span> <span class='hs-layout'>(</span><span class='hs-conid'>HCons</span> <span class='hs-varid'>v</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Arg</span> <span class='hs-varid'>arg_values</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-489"></a>      <span class='hs-varid'>kwmerge</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-conid'>Arg</span> <span class='hs-layout'>(</span><span class='hs-varid'>kw_</span> <span class='hs-varop'>.*.</span> <span class='hs-varid'>v</span> <span class='hs-varop'>.*.</span> <span class='hs-varid'>arg_values</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>::</span>
<a name="line-490"></a>         <span class='hs-layout'>(</span><span class='hs-conid'>Arg</span> <span class='hs-varid'>atail</span> <span class='hs-layout'>(</span><span class='hs-varid'>kw</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>v</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>arg_values</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-491"></a><a name="instance%20KWMerge''%20False%20kw%20(kw'%20':%20v'%20':%20tail)%20atail%20arg_values%20arg_def%20f%20r"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>KWMerge'</span> <span class='hs-varid'>kw</span> <span class='hs-varid'>tail</span> <span class='hs-varid'>atail</span> <span class='hs-varid'>arg_values</span> <span class='hs-varid'>arg_def</span> <span class='hs-varid'>f</span> <span class='hs-varid'>r</span>
<a name="line-492"></a>    <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>KWMerge''</span> <span class='hs-conid'>False</span> <span class='hs-varid'>kw</span> <span class='hs-layout'>(</span><span class='hs-varid'>kw'</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>v'</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>tail</span><span class='hs-layout'>)</span>
<a name="line-493"></a>                 <span class='hs-varid'>atail</span> <span class='hs-varid'>arg_values</span> <span class='hs-varid'>arg_def</span> <span class='hs-varid'>f</span> <span class='hs-varid'>r</span> <span class='hs-keyword'>where</span>
<a name="line-494"></a>    <span class='hs-varid'>kwmerge''</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>kw_</span> <span class='hs-layout'>(</span><span class='hs-conid'>HCons</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>HCons</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>tl</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>kwmerge'</span> <span class='hs-varid'>kw_</span> <span class='hs-varid'>tl</span>
<a name="line-495"></a>
<a name="line-496"></a><span class='hs-comment'>-- | Add the real argument to the Arg structure, and continue</span>
<a name="line-497"></a>
<a name="line-498"></a><a name="KWAcc"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>KWAcc</span> <span class='hs-varid'>arg_desc</span> <span class='hs-varid'>kw</span> <span class='hs-varid'>a</span> <span class='hs-varid'>f</span> <span class='hs-varid'>arg_def</span> <span class='hs-varid'>r</span> <span class='hs-keyword'>where</span>
<a name="line-499"></a>    <span class='hs-varid'>kwaccum</span><span class='hs-keyglyph'>::</span> <span class='hs-varid'>arg_desc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>kw</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>arg_def</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>r</span>
<a name="line-500"></a>
<a name="line-501"></a>
<a name="line-502"></a><a name="instance%20KWAcc%20(Arg%20arg_types%20arg_values)%20kw%20a%20f%20arg_def%20r"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>HDelete</span> <span class='hs-varid'>kw</span> <span class='hs-varid'>arg_types</span> <span class='hs-varid'>arg_types'</span><span class='hs-layout'>,</span>
<a name="line-503"></a>      <span class='hs-conid'>KW</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>Arg</span> <span class='hs-varid'>arg_types'</span> <span class='hs-layout'>(</span><span class='hs-varid'>kw</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>a</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>arg_values</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>arg_def</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<a name="line-504"></a>    <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>KWAcc</span> <span class='hs-layout'>(</span><span class='hs-conid'>Arg</span> <span class='hs-varid'>arg_types</span> <span class='hs-varid'>arg_values</span><span class='hs-layout'>)</span> <span class='hs-varid'>kw</span> <span class='hs-varid'>a</span> <span class='hs-varid'>f</span> <span class='hs-varid'>arg_def</span> <span class='hs-varid'>r</span>  <span class='hs-keyword'>where</span>
<a name="line-505"></a>    <span class='hs-varid'>kwaccum</span> <span class='hs-layout'>(</span><span class='hs-conid'>Arg</span> <span class='hs-varid'>arg_values</span><span class='hs-layout'>)</span> <span class='hs-varid'>kw_</span> <span class='hs-varid'>a</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span>
<a name="line-506"></a>      <span class='hs-varid'>kwdo</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>Arg</span> <span class='hs-layout'>(</span><span class='hs-varid'>kw_</span> <span class='hs-varop'>.*.</span> <span class='hs-varid'>a</span> <span class='hs-varop'>.*.</span> <span class='hs-varid'>arg_values</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>::</span>
<a name="line-507"></a>        <span class='hs-conid'>Arg</span> <span class='hs-varid'>arg_types'</span> <span class='hs-layout'>(</span><span class='hs-varid'>kw</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>a</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>arg_values</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-508"></a>
<a name="line-509"></a>
<a name="line-510"></a><span class='hs-comment'>-- | Delete e from l to yield l' The element e must occur in l</span>
<a name="line-511"></a>
<a name="line-512"></a><a name="HDelete"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>HDelete</span> <span class='hs-varid'>e</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>k</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>l'</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>k</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-513"></a><a name="instance%20HDelete%20e%20'%5b%5d%20r%20instance%20(HEq%20e%20e'%20flag,%20HDelete'%20flag%20e%20(e'%20':%20tail)%20l')%20=%3e%20HDelete%20e%20(e'%20':%20tail)%20l'%20class%20HDelete'%20(flag%20::%20Bool)%20e%20l%20l'%20instance%20(tail'%20~%20tail)%20=%3e%20HDelete'%20True%20e%20(e%20':%20tail)%20tail'%20instance%20(HDelete%20e%20tail%20tail',%20e'tail%20~%20(e'%20':%20tail'))%20=%3e%20HDelete'%20False%20e%20(e'%20':%20tail)%20e'tail%20%7b-%20%7c%20@kw@%20takes%20a%20'HList'%20whose%20first%20element%20is%20a%20function,%20and%20the%20rest%20of%20the%20elements%20are%20default%20values.%20A%20useful%20trick%20is%20to%20have%20a%20final%20argument%20@()@%20which%20is%20not%20eaten%20up%20by%20a%20label%20(A%20only%20takes%201%20argument).%20That%20way%20when%20you%20supply%20the%20()%20it%20knows%20there%20are%20no%20more%20arguments%20(?).%20%3e%3e%3e%20data%20A%20=%20A%20%3e%3e%3e%20instance%20IsKeyFN%20(A%20-%3e%20a%20-%3e%20b)%20True%20%3e%3e%3e%20let%20f%20A%20a%20()%20=%20a%20+%201%20%3e%3e%3e%20let%20f'%20=%20f%20.*.%20A%20.*.%201%20.*.%20HNil%20%3e%3e%3e%20kw%20f'%20A%200%20()%201%20%3e%3e%3e%20kw%20f'%20()%202%20-%7d%20class%20Kw%20(fn%20::%20*)%20(arg_def%20::%20%5b*%5d)%20r"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Fail</span> <span class='hs-layout'>(</span><span class='hs-conid'>ErrUnexpectedKW</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>~</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HDelete</span> <span class='hs-varid'>e</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span> <span class='hs-varid'>r</span>
<a name="line-514"></a><a name="instance%20HDelete%20e%20(e'%20':%20tail)%20l'%20class%20HDelete'%20(flag%20::%20Bool)%20e%20l%20l'%20instance%20(tail'%20~%20tail)%20=%3e%20HDelete'%20True%20e%20(e%20':%20tail)%20tail'%20instance%20(HDelete%20e%20tail%20tail',%20e'tail%20~%20(e'%20':%20tail'))%20=%3e%20HDelete'%20False%20e%20(e'%20':%20tail)%20e'tail%20%7b-%20%7c%20@kw@%20takes%20a%20'HList'%20whose%20first%20element%20is%20a%20function,%20and%20the%20rest%20of%20the%20elements%20are%20default%20values.%20A%20useful%20trick%20is%20to%20have%20a%20final%20argument%20@()@%20which%20is%20not%20eaten%20up%20by%20a%20label%20(A%20only%20takes%201%20argument).%20That%20way%20when%20you%20supply%20the%20()%20it%20knows%20there%20are%20no%20more%20arguments%20(?).%20%3e%3e%3e%20data%20A%20=%20A%20%3e%3e%3e%20instance%20IsKeyFN%20(A%20-%3e%20a%20-%3e%20b)%20True%20%3e%3e%3e%20let%20f%20A%20a%20()%20=%20a%20+%201%20%3e%3e%3e%20let%20f'%20=%20f%20.*.%20A%20.*.%201%20.*.%20HNil%20%3e%3e%3e%20kw%20f'%20A%200%20()%201%20%3e%3e%3e%20kw%20f'%20()%202%20-%7d%20class%20Kw%20(fn%20::%20*)%20(arg_def%20::%20%5b*%5d)%20r"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>HEq</span> <span class='hs-varid'>e</span> <span class='hs-varid'>e'</span> <span class='hs-varid'>flag</span><span class='hs-layout'>,</span> <span class='hs-conid'>HDelete'</span> <span class='hs-varid'>flag</span> <span class='hs-varid'>e</span> <span class='hs-layout'>(</span><span class='hs-varid'>e'</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>tail</span><span class='hs-layout'>)</span> <span class='hs-varid'>l'</span><span class='hs-layout'>)</span>
<a name="line-515"></a>    <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HDelete</span> <span class='hs-varid'>e</span> <span class='hs-layout'>(</span><span class='hs-varid'>e'</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>tail</span><span class='hs-layout'>)</span> <span class='hs-varid'>l'</span>
<a name="line-516"></a><a name="HDelete'"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>HDelete'</span> <span class='hs-layout'>(</span><span class='hs-varid'>flag</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-varid'>e</span> <span class='hs-varid'>l</span> <span class='hs-varid'>l'</span>
<a name="line-517"></a><a name="instance%20HDelete'%20True%20e%20(e%20':%20tail)%20tail'%20instance%20(HDelete%20e%20tail%20tail',%20e'tail%20~%20(e'%20':%20tail'))%20=%3e%20HDelete'%20False%20e%20(e'%20':%20tail)%20e'tail%20%7b-%20%7c%20@kw@%20takes%20a%20'HList'%20whose%20first%20element%20is%20a%20function,%20and%20the%20rest%20of%20the%20elements%20are%20default%20values.%20A%20useful%20trick%20is%20to%20have%20a%20final%20argument%20@()@%20which%20is%20not%20eaten%20up%20by%20a%20label%20(A%20only%20takes%201%20argument).%20That%20way%20when%20you%20supply%20the%20()%20it%20knows%20there%20are%20no%20more%20arguments%20(?).%20%3e%3e%3e%20data%20A%20=%20A%20%3e%3e%3e%20instance%20IsKeyFN%20(A%20-%3e%20a%20-%3e%20b)%20True%20%3e%3e%3e%20let%20f%20A%20a%20()%20=%20a%20+%201%20%3e%3e%3e%20let%20f'%20=%20f%20.*.%20A%20.*.%201%20.*.%20HNil%20%3e%3e%3e%20kw%20f'%20A%200%20()%201%20%3e%3e%3e%20kw%20f'%20()%202%20-%7d%20class%20Kw%20(fn%20::%20*)%20(arg_def%20::%20%5b*%5d)%20r"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-varid'>tail'</span> <span class='hs-keyglyph'>~</span> <span class='hs-varid'>tail</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HDelete'</span> <span class='hs-conid'>True</span> <span class='hs-varid'>e</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>tail</span><span class='hs-layout'>)</span> <span class='hs-varid'>tail'</span>
<a name="line-518"></a><a name="instance%20HDelete'%20False%20e%20(e'%20':%20tail)%20e'tail%20%7b-%20%7c%20@kw@%20takes%20a%20'HList'%20whose%20first%20element%20is%20a%20function,%20and%20the%20rest%20of%20the%20elements%20are%20default%20values.%20A%20useful%20trick%20is%20to%20have%20a%20final%20argument%20@()@%20which%20is%20not%20eaten%20up%20by%20a%20label%20(A%20only%20takes%201%20argument).%20That%20way%20when%20you%20supply%20the%20()%20it%20knows%20there%20are%20no%20more%20arguments%20(?).%20%3e%3e%3e%20data%20A%20=%20A%20%3e%3e%3e%20instance%20IsKeyFN%20(A%20-%3e%20a%20-%3e%20b)%20True%20%3e%3e%3e%20let%20f%20A%20a%20()%20=%20a%20+%201%20%3e%3e%3e%20let%20f'%20=%20f%20.*.%20A%20.*.%201%20.*.%20HNil%20%3e%3e%3e%20kw%20f'%20A%200%20()%201%20%3e%3e%3e%20kw%20f'%20()%202%20-%7d%20class%20Kw%20(fn%20::%20*)%20(arg_def%20::%20%5b*%5d)%20r"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>HDelete</span> <span class='hs-varid'>e</span> <span class='hs-varid'>tail</span> <span class='hs-varid'>tail'</span><span class='hs-layout'>,</span> <span class='hs-varid'>e'tail</span> <span class='hs-keyglyph'>~</span> <span class='hs-layout'>(</span><span class='hs-varid'>e'</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>tail'</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-519"></a>    <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HDelete'</span> <span class='hs-conid'>False</span> <span class='hs-varid'>e</span> <span class='hs-layout'>(</span><span class='hs-varid'>e'</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>tail</span><span class='hs-layout'>)</span> <span class='hs-varid'>e'tail</span>
<a name="line-520"></a>
<a name="line-521"></a>
<a name="line-522"></a><a name="Kw"></a><span class='hs-comment'>{- |
<a name="line-523"></a>
<a name="line-524"></a>@kw@ takes a 'HList' whose first element is a function, and the rest
<a name="line-525"></a>of the elements are default values.
<a name="line-526"></a>A useful trick is to have a final argument @()@ which is not
<a name="line-527"></a>eaten up by a label (A only takes 1 argument). That way when you supply
<a name="line-528"></a>the () it knows there are no more arguments (?).
<a name="line-529"></a>
<a name="line-530"></a>&gt;&gt;&gt; data A = A
<a name="line-531"></a>&gt;&gt;&gt; instance IsKeyFN (A -&gt; a -&gt; b) True
<a name="line-532"></a>&gt;&gt;&gt; let f A a () = a + 1
<a name="line-533"></a>&gt;&gt;&gt; let f' = f .*. A .*. 1 .*. HNil
<a name="line-534"></a>
<a name="line-535"></a>&gt;&gt;&gt; kw f' A 0 ()
<a name="line-536"></a>1
<a name="line-537"></a>
<a name="line-538"></a>&gt;&gt;&gt; kw f' ()
<a name="line-539"></a>2
<a name="line-540"></a>
<a name="line-541"></a>-}</span>
<a name="line-542"></a><a name="Kw"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>Kw</span> <span class='hs-layout'>(</span><span class='hs-varid'>fn</span> <span class='hs-keyglyph'>::</span> <span class='hs-varop'>*</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg_def</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varop'>*</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-varid'>r</span> <span class='hs-keyword'>where</span>
<a name="line-543"></a>    <span class='hs-varid'>kw</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HList</span> <span class='hs-layout'>(</span><span class='hs-varid'>fn</span> <span class='hs-chr'>'</span><span class='hs-conop'>:</span> <span class='hs-varid'>arg_def</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>r</span>
<a name="line-544"></a>
<a name="line-545"></a><a name="instance%20Kw%20fn%20arg_def%20r"></a><span class='hs-keyword'>instance</span>
<a name="line-546"></a>    <span class='hs-layout'>(</span><span class='hs-conid'>KW'</span> <span class='hs-varid'>rflag</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>akws</span> <span class='hs-varid'>arg_def</span> <span class='hs-varid'>r</span><span class='hs-layout'>,</span>
<a name="line-547"></a>     <span class='hs-varid'>akws</span> <span class='hs-keyglyph'>~</span> <span class='hs-layout'>(</span><span class='hs-conid'>Arg</span> <span class='hs-layout'>(</span><span class='hs-varid'>kws</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varop'>*</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-chr'>'</span><span class='hs-conid'>[]</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-548"></a>     <span class='hs-conid'>ReflectFK'</span> <span class='hs-varid'>flag</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>kws</span><span class='hs-layout'>,</span> <span class='hs-conid'>IsKeyFN</span> <span class='hs-varid'>r</span> <span class='hs-varid'>rflag</span><span class='hs-layout'>,</span>
<a name="line-549"></a>     <span class='hs-conid'>IsKeyFN</span> <span class='hs-varid'>fn</span> <span class='hs-layout'>(</span><span class='hs-varid'>flag</span><span class='hs-keyglyph'>::</span><span class='hs-conid'>Bool</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Kw</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>arg_def</span> <span class='hs-varid'>r</span>
<a name="line-550"></a>   <span class='hs-keyword'>where</span>
<a name="line-551"></a>    <span class='hs-varid'>kw</span> <span class='hs-layout'>(</span><span class='hs-conid'>HCons</span> <span class='hs-varid'>f</span> <span class='hs-varid'>arg_def</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>kwdo</span> <span class='hs-varid'>f</span> <span class='hs-varid'>rfk</span> <span class='hs-varid'>arg_def</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>r</span>
<a name="line-552"></a>        <span class='hs-keyword'>where</span> <span class='hs-varid'>rfk</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>reflect_fk</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>akws</span>
<a name="line-553"></a>
<a name="line-554"></a><a name="TaggedToKW"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>TaggedToKW</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TaggedToKW</span>
<a name="line-555"></a><a name="instance%20ApplyAB%20TaggedToKW%20x%20y"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-keyglyph'>~</span> <span class='hs-conid'>Tagged</span> <span class='hs-varid'>l</span> <span class='hs-varid'>v</span><span class='hs-layout'>,</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>~</span> <span class='hs-conid'>HList</span> <span class='hs-chr'>'</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Label</span> <span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-varid'>v</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span>
<a name="line-556"></a>        <span class='hs-conid'>ApplyAB</span> <span class='hs-conid'>TaggedToKW</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span> <span class='hs-keyword'>where</span>
<a name="line-557"></a>    <span class='hs-varid'>applyAB</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tagged</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hBuild</span> <span class='hs-conid'>Label</span> <span class='hs-varid'>v</span>
<a name="line-558"></a>
<a name="line-559"></a>
<a name="line-560"></a><a name="recToKW"></a><span class='hs-comment'>{- | convert a 'Record' into a list that can supply
<a name="line-561"></a>default arguments for 'kw'
<a name="line-562"></a>
<a name="line-563"></a>A bit of setup:
<a name="line-564"></a>
<a name="line-565"></a>&gt;&gt;&gt; :set -XQuasiQuotes
<a name="line-566"></a>&gt;&gt;&gt; import Data.HList.RecordPuns
<a name="line-567"></a>&gt;&gt;&gt; let f (_ :: Label "a") a (_ :: Label "b") b () = a `div` b
<a name="line-568"></a>
<a name="line-569"></a>
<a name="line-570"></a>&gt;&gt;&gt; let a = 2; b = 1; f' = f .*. recToKW [pun| a b |]
<a name="line-571"></a>&gt;&gt;&gt; kw f' ()
<a name="line-572"></a>2
<a name="line-573"></a>
<a name="line-574"></a>&gt;&gt;&gt; kw f' (Label :: Label "a") 10 ()
<a name="line-575"></a>10
<a name="line-576"></a>
<a name="line-577"></a>
<a name="line-578"></a>-}</span>
<a name="line-579"></a><span class='hs-definition'>recToKW</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span><span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-conid'>HMapCxt</span> <span class='hs-conid'>HList</span> <span class='hs-conid'>TaggedToKW</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-conid'>HConcat</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span>
<a name="line-580"></a>     <span class='hs-conid'>Record</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HList</span> <span class='hs-layout'>(</span><span class='hs-conid'>HConcatR</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-581"></a><span class='hs-definition'>recToKW</span> <span class='hs-layout'>(</span><span class='hs-conid'>Record</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hConcat</span> <span class='hs-layout'>(</span><span class='hs-varid'>hMap</span> <span class='hs-conid'>TaggedToKW</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HList</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-582"></a>
<a name="line-583"></a><span class='hs-comment'>{- $originalIntro
<a name="line-584"></a>
<a name="line-585"></a>&gt; From oleg-at-okmij.org Fri Aug 13 14:58:35 2004
<a name="line-586"></a>&gt; To: haskell@haskell.org
<a name="line-587"></a>&gt; Subject: Keyword arguments
<a name="line-588"></a>&gt; From: oleg-at-pobox.com
<a name="line-589"></a>&gt; Message-ID: &lt;20040813215834.F1FF3AB7E@Adric.metnet.navy.mil&gt;
<a name="line-590"></a>&gt; Date: Fri, 13 Aug 2004 14:58:34 -0700 (PDT)
<a name="line-591"></a>&gt; Status: OR
<a name="line-592"></a>
<a name="line-593"></a>
<a name="line-594"></a>We show the Haskell implementation of keyword arguments, which goes
<a name="line-595"></a>well beyond records (e.g., in permitting the re-use of
<a name="line-596"></a>labels). Keyword arguments indeed look just like regular, positional
<a name="line-597"></a>arguments. However, keyword arguments may appear in any
<a name="line-598"></a>order. Furthermore, one may associate defaults with some keywords; the
<a name="line-599"></a>corresponding arguments may then be omitted. It is a type error to
<a name="line-600"></a>omit a required keyword argument. The latter property is in stark
<a name="line-601"></a>contrast with the conventional way of emulating keyword arguments via
<a name="line-602"></a>records. Also in marked contrast with records, keyword labels may be
<a name="line-603"></a>reused throughout the code with no restriction; the same label may be
<a name="line-604"></a>associated with arguments of different types in different
<a name="line-605"></a>functions. Labels of Haskell records may not be re-used.  Our solution
<a name="line-606"></a>is essentially equivalent to keyword arguments of DSSSL Scheme or
<a name="line-607"></a>labels of OCaml.
<a name="line-608"></a>
<a name="line-609"></a>Keyword argument functions are naturally polyvariadic: Haskell does
<a name="line-610"></a>support varargs! Keyword argument functions may be polymorphic. As
<a name="line-611"></a>usual, functions with keyword arguments may be partially applied. On
<a name="line-612"></a>the downside, sometimes one has to specify the type of the return
<a name="line-613"></a>value of the function (if the keyword argument function has no
<a name="line-614"></a>signature -- the latter is the norm, see below) -- provided that the
<a name="line-615"></a>compiler cannot figure the return type out on its own. This is usually
<a name="line-616"></a>only the case when we use keyword functions at the top level (GHCi
<a name="line-617"></a>prompt).
<a name="line-618"></a>
<a name="line-619"></a>Our solution requires no special extensions to Haskell and works with
<a name="line-620"></a>the existing Haskell compilers; it is tested on GHC 6.0.1. The
<a name="line-621"></a>overlapping instances extension is not necessary (albeit it is
<a name="line-622"></a>convenient).
<a name="line-623"></a>
<a name="line-624"></a>The gist of our implementation is the realization that the type of a
<a name="line-625"></a>function is a polymorphic collection of its argument types -- a
<a name="line-626"></a>collection that we can traverse. This message thus illustrates a
<a name="line-627"></a>limited form of the reflection on a function.
<a name="line-628"></a>
<a name="line-629"></a>
<a name="line-630"></a>Our implementation is a trivial extension of the strongly-typed
<a name="line-631"></a>polymorphic open records described in
<a name="line-632"></a>    &lt;<a href="http://homepages.cwi.nl/~ralf/HList/">http://homepages.cwi.nl/~ralf/HList/</a>&gt;
<a name="line-633"></a>
<a name="line-634"></a>In fact, the implementation relies on the HList library.  To run the
<a name="line-635"></a>code (which this message is), one needs to download the HList library
<a name="line-636"></a>from the above site.
<a name="line-637"></a>
<a name="line-638"></a>The HList paper discusses the issue of labels in some detail. The
<a name="line-639"></a>paper gives three different representations. One of them needs no
<a name="line-640"></a>overlapping instances and is very portable. In this message, we chose
<a name="line-641"></a>a representation that relies on generic type equality and therefore
<a name="line-642"></a>needs overlapping instances as implemented in GHC. Again, this is
<a name="line-643"></a>merely an outcome of our non-deterministic choice. It should be
<a name="line-644"></a>emphasized that other choices are possible, which do not depend on
<a name="line-645"></a>overlapping instances at all. Please see the HList paper for details.
<a name="line-646"></a>
<a name="line-647"></a>-}</span>
<a name="line-648"></a>
<a name="line-649"></a>
<a name="line-650"></a><span class='hs-comment'>{- $todo
<a name="line-651"></a>
<a name="line-652"></a>[@better instances for Symbol@]
<a name="line-653"></a>
<a name="line-654"></a>There isn't a pair @(K2 \"Origin\" (Int, Int))@ @(K \"hi\")@ that behaves just like Origin below.
<a name="line-655"></a>something is possible between constraintkinds. See 'Data.HList.FakePrelude.Fun'
<a name="line-656"></a>
<a name="line-657"></a>&gt; instance (a ~ (Int,Int)) =&gt; IsKeyFN (Origin-&gt;a-&gt;b) True
<a name="line-658"></a>
<a name="line-659"></a>[@wildcard/catchall@]
<a name="line-660"></a>
<a name="line-661"></a>like in R. This would be a special keyword for keyword args that didn't match.
<a name="line-662"></a>They would be put in a HList/Record argument like @...@
<a name="line-663"></a>
<a name="line-664"></a>[@investigate first-classness of varargs@]
<a name="line-665"></a>for whatever reason you can't have  @f = kw fn blah@ and then pass more arguments
<a name="line-666"></a>on to fn. This is bad. It used to work (in the ghc6.0 days and probably up to
<a name="line-667"></a>6.12). Some convenience functions/operators should be added which do the same
<a name="line-668"></a>thing as:
<a name="line-669"></a>
<a name="line-670"></a>&gt; fn `hAppendList` hBuild a b c d e
<a name="line-671"></a>
<a name="line-672"></a>
<a name="line-673"></a>-}</span>
</pre></body>
</html>
