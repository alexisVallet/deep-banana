-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Semigroupoids: Category sans id
--   
--   Provides a wide array of (semi)groupoids and operations for working
--   with them.
--   
--   A <a>Semigroupoid</a> is a <a>Category</a> without the requirement of
--   identity arrows for every object in the category.
--   
--   A <a>Category</a> is any <a>Semigroupoid</a> for which the Yoneda
--   lemma holds.
--   
--   When working with comonads you often have the <tt>&lt;*&gt;</tt>
--   portion of an <tt>Applicative</tt>, but not the <tt>pure</tt>. This
--   was captured in Uustalu and Vene's "Essence of Dataflow Programming"
--   in the form of the <tt>ComonadZip</tt> class in the days before
--   <tt>Applicative</tt>. Apply provides a weaker invariant, but for the
--   comonads used for data flow programming (found in the streams
--   package), this invariant is preserved. Applicative function
--   composition forms a semigroupoid.
--   
--   Similarly many structures are nearly a comonad, but not quite, for
--   instance lists provide a reasonable <a>extend</a> operation in the
--   form of <a>tails</a>, but do not always contain a value.
--   
--   Ideally the following relationships would hold:
--   
--   <pre>
--   Foldable ----&gt; Traversable &lt;--- Functor ------&gt; Alt ---------&gt; Plus           Semigroupoid
--        |               |            |                              |                  |
--        v               v            v                              v                  v
--   Foldable1 ---&gt; Traversable1     Apply --------&gt; Applicative -&gt; Alternative      Category
--                                     |               |              |                  |
--                                     v               v              v                  v
--                                   Bind ---------&gt; Monad -------&gt; MonadPlus          Arrow
--   </pre>
--   
--   Apply, Bind, and Extend (not shown) give rise the Static, Kleisli and
--   Cokleisli semigroupoids respectively.
--   
--   This lets us remove many of the restrictions from various monad
--   transformers as in many cases the binding operation or
--   <tt>&lt;*&gt;</tt> operation does not require them.
--   
--   Finally, to work with these weaker structures it is beneficial to have
--   containers that can provide stronger guarantees about their contents,
--   so versions of <a>Traversable</a> and <a>Foldable</a> that can be
--   folded with just a <a>Semigroup</a> are added.
@package semigroupoids
@version 4.3


-- | Placeholders for missing instances of Traversable, until base catches
--   up and adds them
module Data.Traversable.Instances


module Data.Functor.Extend
class Functor w => Extend w where extended f = fmap f . duplicated duplicated = extended id
duplicated :: Extend w => w a -> w (w a)
extended :: Extend w => (w a -> b) -> w a -> w b
instance [safe] Extend NonEmpty
instance [safe] Extend w => Extend (IdentityT w)
instance [safe] Extend Identity
instance [safe] (Extend w, Semigroup m) => Extend (TracedT m w)
instance [safe] Extend w => Extend (StoreT s w)
instance [safe] Extend w => Extend (EnvT e w)
instance [safe] (Extend f, Extend g) => Extend (Coproduct f g)
instance [safe] Extend Tree
instance [safe] Extend Seq
instance [safe] Semigroup m => Extend ((->) m)
instance [safe] Extend ((,) e)
instance [safe] Extend (Either a)
instance [safe] Extend Maybe
instance [safe] Extend []


-- | NB: The definitions exported through <a>Data.Functor.Apply</a> need to
--   be included here because otherwise the instances for the transformers
--   package have orphaned heads.
module Data.Functor.Bind

-- | The <a>Functor</a> class is used for types that can be mapped over.
--   Instances of <a>Functor</a> should satisfy the following laws:
--   
--   <pre>
--   fmap id  ==  id
--   fmap (f . g)  ==  fmap f . fmap g
--   </pre>
--   
--   The instances of <a>Functor</a> for lists, <a>Maybe</a> and <a>IO</a>
--   satisfy these laws.
class Functor (f :: * -> *)
fmap :: Functor f => (a -> b) -> f a -> f b
(<$) :: Functor f => a -> f b -> f a

-- | An infix synonym for <a>fmap</a>.
(<$>) :: Functor f => (a -> b) -> f a -> f b

-- | Flipped version of <a>&lt;$</a>.
--   
--   <i>Since: 4.7.0.0</i>
($>) :: Functor f => f a -> b -> f b

-- | A strong lax semi-monoidal endofunctor. This is equivalent to an
--   <a>Applicative</a> without <a>pure</a>.
--   
--   Laws:
--   
--   <pre>
--   associative composition: (.) &lt;$&gt; u &lt;.&gt; v &lt;.&gt; w = u &lt;.&gt; (v &lt;.&gt; w)
--   </pre>
class Functor f => Apply f where a .> b = const id <$> a <.> b a <. b = const <$> a <.> b
(<.>) :: Apply f => f (a -> b) -> f a -> f b
(.>) :: Apply f => f a -> f b -> f b
(<.) :: Apply f => f a -> f b -> f a

-- | A variant of <a>&lt;.&gt;</a> with the arguments reversed.
(<..>) :: Apply w => w a -> w (a -> b) -> w b

-- | Lift a binary function into a comonad with zipping
liftF2 :: Apply w => (a -> b -> c) -> w a -> w b -> w c

-- | Lift a ternary function into a comonad with zipping
liftF3 :: Apply w => (a -> b -> c -> d) -> w a -> w b -> w c -> w d

-- | Wrap an <a>Applicative</a> to be used as a member of <a>Apply</a>
newtype WrappedApplicative f a
WrapApplicative :: f a -> WrappedApplicative f a
unwrapApplicative :: WrappedApplicative f a -> f a

-- | Transform a Apply into an Applicative by adding a unit.
newtype MaybeApply f a
MaybeApply :: Either (f a) a -> MaybeApply f a
runMaybeApply :: MaybeApply f a -> Either (f a) a

-- | A <a>Monad</a> sans <a>return</a>.
--   
--   Minimal definition: Either <a>join</a> or <a>&gt;&gt;-</a>
--   
--   If defining both, then the following laws (the default definitions)
--   must hold:
--   
--   <pre>
--   join = (&gt;&gt;- id)
--   m &gt;&gt;- f = join (fmap f m)
--   </pre>
--   
--   Laws:
--   
--   <pre>
--   induced definition of &lt;.&gt;: f &lt;.&gt; x = f &gt;&gt;- (&lt;$&gt; x)
--   </pre>
--   
--   Finally, there are two associativity conditions:
--   
--   <pre>
--   associativity of (&gt;&gt;-):    (m &gt;&gt;- f) &gt;&gt;- g == m &gt;&gt;- (\x -&gt; f x &gt;&gt;- g)
--   associativity of join:     join . join = join . fmap join
--   </pre>
--   
--   These can both be seen as special cases of the constraint that
--   
--   <pre>
--   associativity of (-&gt;-): (f -&gt;- g) -&gt;- h = f -&gt;- (g -&gt;- h)
--   </pre>
class Apply m => Bind m where m >>- f = join (fmap f m) join = (>>- id)
(>>-) :: Bind m => m a -> (a -> m b) -> m b
join :: Bind m => m (m a) -> m a
(-<<) :: Bind m => (a -> m b) -> m a -> m b
(-<-) :: Bind m => (b -> m c) -> (a -> m b) -> a -> m c
(->-) :: Bind m => (a -> m b) -> (b -> m c) -> a -> m c
apDefault :: Bind f => f (a -> b) -> f a -> f b
returning :: Functor f => f a -> (a -> b) -> f b
instance [safe] Bind Tree
instance [safe] Bind Seq
instance [safe] Bind IntMap
instance [safe] Ord k => Bind (Map k)
instance [safe] Bind (ContT r m)
instance [safe] (Bind m, Semigroup w) => Bind (RWST r w s m)
instance [safe] (Bind m, Semigroup w) => Bind (RWST r w s m)
instance [safe] Bind m => Bind (StateT s m)
instance [safe] Bind m => Bind (StateT s m)
instance [safe] (Bind m, Semigroup w) => Bind (WriterT w m)
instance [safe] (Bind m, Semigroup w) => Bind (WriterT w m)
instance [safe] Bind m => Bind (ReaderT e m)
instance [safe] (Functor m, Monad m) => Bind (ExceptT e m)
instance [safe] (Functor m, Monad m) => Bind (ErrorT e m)
instance [safe] (Apply m, Monad m) => Bind (ListT m)
instance [safe] (Functor m, Monad m) => Bind (MaybeT m)
instance [safe] Monad m => Bind (WrappedMonad m)
instance [safe] Bind m => Bind (IdentityT m)
instance [safe] Bind Identity
instance [safe] Bind Option
instance [safe] Bind Maybe
instance [safe] Bind IO
instance [safe] Bind NonEmpty
instance [safe] Bind []
instance [safe] Bind ((->) m)
instance [safe] (Bind f, Bind g) => Bind (Product f g)
instance [safe] Bind (Either a)
instance [safe] Semigroup m => Bind ((,) m)
instance [safe] Apply (Cokleisli w a)
instance [safe] Comonad f => Comonad (MaybeApply f)
instance [safe] Extend f => Extend (MaybeApply f)
instance [safe] Apply f => Applicative (MaybeApply f)
instance [safe] Apply f => Apply (MaybeApply f)
instance [safe] Functor f => Functor (MaybeApply f)
instance [safe] Alternative f => Alternative (WrappedApplicative f)
instance [safe] Applicative f => Applicative (WrappedApplicative f)
instance [safe] Applicative f => Apply (WrappedApplicative f)
instance [safe] Functor f => Functor (WrappedApplicative f)
instance [safe] Apply w => Apply (TracedT m w)
instance [safe] (Apply w, Semigroup s) => Apply (StoreT s w)
instance [safe] (Semigroup e, Apply w) => Apply (EnvT e w)
instance [safe] Apply (ContT r m)
instance [safe] (Bind m, Semigroup w) => Apply (RWST r w s m)
instance [safe] (Bind m, Semigroup w) => Apply (RWST r w s m)
instance [safe] Bind m => Apply (StateT s m)
instance [safe] Bind m => Apply (StateT s m)
instance [safe] (Apply m, Semigroup w) => Apply (WriterT w m)
instance [safe] (Apply m, Semigroup w) => Apply (WriterT w m)
instance [safe] Apply m => Apply (ListT m)
instance [safe] Apply m => Apply (ReaderT e m)
instance [safe] (Functor m, Monad m) => Apply (ExceptT e m)
instance [safe] (Functor m, Monad m) => Apply (ErrorT e m)
instance [safe] (Functor m, Monad m) => Apply (MaybeT m)
instance [safe] Apply Tree
instance [safe] Apply Seq
instance [safe] Apply IntMap
instance [safe] Ord k => Apply (Map k)
instance [safe] Arrow a => Apply (WrappedArrow a b)
instance [safe] Monad m => Apply (WrappedMonad m)
instance [safe] Apply w => Apply (IdentityT w)
instance [safe] Apply Identity
instance [safe] Apply Option
instance [safe] Apply Maybe
instance [safe] Apply IO
instance [safe] Apply []
instance [safe] Apply ZipList
instance [safe] Apply ((->) m)
instance [safe] Semigroup m => Apply (Const m)
instance [safe] Apply (Either a)
instance [safe] Apply NonEmpty
instance [safe] Semigroup m => Apply ((,) m)
instance [safe] (Apply f, Apply g) => Apply (Product f g)
instance [safe] (Apply f, Apply g) => Apply (Compose f g)


module Data.Functor.Bind.Trans

-- | A subset of monad transformers can transform any <a>Bind</a> as well.
class MonadTrans t => BindTrans t
liftB :: (BindTrans t, Bind b) => b a -> t b a
instance BindTrans (ContT r)
instance (Semigroup w, Monoid w) => BindTrans (RWST r w s)
instance (Semigroup w, Monoid w) => BindTrans (RWST r w s)
instance BindTrans (StateT s)
instance BindTrans (StateT s)
instance (Semigroup w, Monoid w) => BindTrans (WriterT w)
instance (Semigroup w, Monoid w) => BindTrans (WriterT w)
instance BindTrans (ReaderT e)
instance BindTrans IdentityT


-- | A semigroupoid satisfies all of the requirements to be a Category
--   except for the existence of identity arrows.
module Data.Semigroupoid

-- | <a>Category</a> sans <a>id</a>
class Semigroupoid c
o :: Semigroupoid c => c j k -> c i j -> c i k
newtype WrappedCategory k a b
WrapCategory :: k a b -> WrappedCategory k a b
unwrapCategory :: WrappedCategory k a b -> k a b
newtype Semi m a b
Semi :: m -> Semi m a b
getSemi :: Semi m a b -> m
instance [safe] Monoid m => Category (Semi m)
instance [safe] Semigroup m => Semigroupoid (Semi m)
instance [safe] Category k => Category (WrappedCategory k)
instance [safe] Category k => Semigroupoid (WrappedCategory k)
instance [safe] Semigroupoid Op
instance [safe] Extend w => Semigroupoid (Cokleisli w)
instance [safe] Bind m => Semigroupoid (Kleisli m)
instance [safe] Semigroupoid (,)
instance [safe] Semigroupoid (->)


-- | A semigroupoid satisfies all of the requirements to be a Category
--   except for the existence of identity arrows.
module Data.Semigroupoid.Dual
newtype Dual k a b
Dual :: k b a -> Dual k a b
getDual :: Dual k a b -> k b a
instance Category k => Category (Dual k)
instance Semigroupoid k => Semigroupoid (Dual k)

module Data.Groupoid

-- | semigroupoid with inverses. This technically should be a category with
--   inverses, except we need to use Ob to define the valid objects for the
--   category
class Semigroupoid k => Groupoid k
inv :: Groupoid k => k a b -> k b a
instance Groupoid k => Groupoid (Dual k)

module Data.Isomorphism
data Iso k a b
Iso :: k a b -> k b a -> Iso k a b
embed :: Iso k a b -> k a b
project :: Iso k a b -> k b a
instance Category k => Category (Iso k)
instance Semigroupoid k => Groupoid (Iso k)
instance Semigroupoid k => Semigroupoid (Iso k)

module Data.Semigroupoid.Product
data Product j k a b
Pair :: j a b -> k a' b' -> Product j k (a, a') (b, b')
distributeDualProduct :: Dual (Product j k) a b -> Product (Dual j) (Dual k) a b
factorDualProduct :: Product (Dual j) (Dual k) a b -> Dual (Product j k) a b
instance (Groupoid j, Groupoid k) => Groupoid (Product j k)
instance (Semigroupoid j, Semigroupoid k) => Semigroupoid (Product j k)

module Data.Semigroupoid.Coproduct
data L a
data R a
data Coproduct j k a b
L :: j a b -> Coproduct j k (L a) (L b)
R :: k a b -> Coproduct j k (R a) (R b)
distributeDualCoproduct :: Dual (Coproduct j k) a b -> Coproduct (Dual j) (Dual k) a b
factorDualCoproduct :: Coproduct (Dual j) (Dual k) a b -> Dual (Coproduct j k) a b
instance (Groupoid j, Groupoid k) => Groupoid (Coproduct j k)
instance (Semigroupoid j, Semigroupoid k) => Semigroupoid (Coproduct j k)


module Data.Semigroupoid.Ob
class Semigroupoid k => Ob k a
semiid :: Ob k a => k a a
instance Ob (->) a
instance (Extend w, Comonad w) => Ob (Cokleisli w) a
instance (Bind m, Monad m) => Ob (Kleisli m) a
instance (Semigroupoid l, Ob r a) => Ob (Coproduct l r) (R a)
instance (Ob l a, Semigroupoid r) => Ob (Coproduct l r) (L a)
instance (Ob l a, Ob r b) => Ob (Product l r) (a, b)


module Data.Functor.Apply

-- | The <a>Functor</a> class is used for types that can be mapped over.
--   Instances of <a>Functor</a> should satisfy the following laws:
--   
--   <pre>
--   fmap id  ==  id
--   fmap (f . g)  ==  fmap f . fmap g
--   </pre>
--   
--   The instances of <a>Functor</a> for lists, <a>Maybe</a> and <a>IO</a>
--   satisfy these laws.
class Functor (f :: * -> *)
fmap :: Functor f => (a -> b) -> f a -> f b
(<$) :: Functor f => a -> f b -> f a

-- | An infix synonym for <a>fmap</a>.
(<$>) :: Functor f => (a -> b) -> f a -> f b

-- | Flipped version of <a>&lt;$</a>.
--   
--   <i>Since: 4.7.0.0</i>
($>) :: Functor f => f a -> b -> f b

-- | A strong lax semi-monoidal endofunctor. This is equivalent to an
--   <a>Applicative</a> without <a>pure</a>.
--   
--   Laws:
--   
--   <pre>
--   associative composition: (.) &lt;$&gt; u &lt;.&gt; v &lt;.&gt; w = u &lt;.&gt; (v &lt;.&gt; w)
--   </pre>
class Functor f => Apply f where a .> b = const id <$> a <.> b a <. b = const <$> a <.> b
(<.>) :: Apply f => f (a -> b) -> f a -> f b
(.>) :: Apply f => f a -> f b -> f b
(<.) :: Apply f => f a -> f b -> f a

-- | A variant of <a>&lt;.&gt;</a> with the arguments reversed.
(<..>) :: Apply w => w a -> w (a -> b) -> w b

-- | Lift a binary function into a comonad with zipping
liftF2 :: Apply w => (a -> b -> c) -> w a -> w b -> w c

-- | Lift a ternary function into a comonad with zipping
liftF3 :: Apply w => (a -> b -> c -> d) -> w a -> w b -> w c -> w d

-- | Wrap an <a>Applicative</a> to be used as a member of <a>Apply</a>
newtype WrappedApplicative f a
WrapApplicative :: f a -> WrappedApplicative f a
unwrapApplicative :: WrappedApplicative f a -> f a

-- | Transform a Apply into an Applicative by adding a unit.
newtype MaybeApply f a
MaybeApply :: Either (f a) a -> MaybeApply f a
runMaybeApply :: MaybeApply f a -> Either (f a) a


module Data.Semigroup.Foldable
class Foldable t => Foldable1 t where foldMap1 f = maybe (error "foldMap1") id . getOption . foldMap (Option . Just . f) fold1 = foldMap1 id
fold1 :: (Foldable1 t, Semigroup m) => t m -> m
foldMap1 :: (Foldable1 t, Semigroup m) => (a -> m) -> t a -> m

-- | Insert an <tt>m</tt> between each pair of 't m'. Equivalent to
--   <a>intercalateMap1</a> with <a>id</a> as the second argument.
--   
--   <pre>
--   &gt;&gt;&gt; intercalate1 ", " $ "hello" :| ["how", "are", "you"]
--   "hello, how, are, you"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intercalate1 ", " $ "hello" :| []
--   "hello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intercalate1 mempty $ "I" :| ["Am", "Fine", "You?"]
--   "IAmFineYou?"
--   </pre>
intercalate1 :: (Foldable1 t, Semigroup m) => m -> t m -> m

-- | Insert <tt>m</tt> between each pair of <tt>m</tt> derived from
--   <tt>a</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; intercalateMap1 " " show $ True :| [False, True]
--   "True False True"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intercalateMap1 " " show $ True :| []
--   "True"
--   </pre>
intercalateMap1 :: (Foldable1 t, Semigroup m) => m -> (a -> m) -> t a -> m
traverse1_ :: (Foldable1 t, Apply f) => (a -> f b) -> t a -> f ()
for1_ :: (Foldable1 t, Apply f) => t a -> (a -> f b) -> f ()
sequenceA1_ :: (Foldable1 t, Apply f) => t (f a) -> f ()

-- | Usable default for foldMap, but only if you define foldMap1 yourself
foldMapDefault1 :: (Foldable1 t, Monoid m) => (a -> m) -> t a -> m
instance Functor f => Functor (Act f)
instance Apply f => Semigroup (Act f a)
instance Semigroup a => Semigroup (JoinWith a)
instance Foldable1 ((,) a)
instance Foldable1 NonEmpty
instance (Foldable1 f, Foldable1 g) => Foldable1 (Coproduct f g)
instance (Foldable1 f, Foldable1 g) => Foldable1 (Product f g)
instance (Foldable1 f, Foldable1 g) => Foldable1 (Compose f g)
instance Foldable1 m => Foldable1 (IdentityT m)
instance Foldable1 Identity
instance Foldable1 Tree


module Data.Semigroup.Traversable
class (Foldable1 t, Traversable t) => Traversable1 t where sequence1 = traverse1 id traverse1 f = sequence1 . fmap f
traverse1 :: (Traversable1 t, Apply f) => (a -> f b) -> t a -> f (t b)
sequence1 :: (Traversable1 t, Apply f) => t (f b) -> f (t b)
foldMap1Default :: (Traversable1 f, Semigroup m) => (a -> m) -> f a -> m
instance Traversable1 ((,) a)
instance Traversable1 NonEmpty
instance Traversable1 Tree
instance (Traversable1 f, Traversable1 g) => Traversable1 (Coproduct f g)
instance (Traversable1 f, Traversable1 g) => Traversable1 (Product f g)
instance (Traversable1 f, Traversable1 g) => Traversable1 (Compose f g)
instance Traversable1 f => Traversable1 (IdentityT f)
instance Traversable1 Identity

module Data.Semifunctor

-- | Semifunctors map objects to objects, and arrows to arrows preserving
--   connectivity as normal functors, but do not purport to preserve
--   identity arrows. We apply them to semigroupoids, because those don't
--   even claim to offer identity arrows!
class (Semigroupoid c, Semigroupoid d) => Semifunctor f c d | f c -> d, f d -> c
semimap :: Semifunctor f c d => c a b -> d (f a) (f b)

-- | Used to map a more traditional bifunctor into a semifunctor
data Bi p a
Bi :: p a b -> Bi p (a, b)
(#) :: a -> b -> Bi (,) (a, b)
semibimap :: Semifunctor p (Product l r) cod => l a b -> r c d -> cod (p (a, c)) (p (b, d))
semifirst :: (Semifunctor p (Product l r) cod, Ob r c) => l a b -> cod (p (a, c)) (p (b, c))
semisecond :: (Semifunctor p (Product l r) cod, Ob l a) => r b c -> cod (p (a, b)) (p (a, c))
first :: (Semifunctor p (Product l r) cod, Category r) => l a b -> cod (p (a, c)) (p (b, c))
second :: (Semifunctor p (Product l r) cod, Category l) => r b c -> cod (p (a, b)) (p (a, c))
data WrappedFunctor f a
WrapFunctor :: f a -> WrappedFunctor f a
unwrapFunctor :: WrappedFunctor f a -> f a
data WrappedTraversable1 f a
WrapTraversable1 :: f a -> WrappedTraversable1 f a
unwrapTraversable1 :: WrappedTraversable1 f a -> f a
instance [safe] Extend w => Semifunctor (Bi (,)) (Product (Cokleisli w) (Cokleisli w)) (Cokleisli w)
instance [safe] Bind m => Semifunctor (Bi Either) (Product (Kleisli m) (Kleisli m)) (Kleisli m)
instance [safe] Bind m => Semifunctor (Bi (,)) (Product (Kleisli m) (Kleisli m)) (Kleisli m)
instance [safe] Semifunctor (Bi Either) (Product (->) (->)) (->)
instance [safe] Semifunctor (Bi (,)) (Product (->) (->)) (->)
instance [safe] Semifunctor f c d => Semifunctor f (Dual c) (Dual d)
instance [safe] (Traversable1 f, Bind m) => Semifunctor (WrappedTraversable1 f) (Kleisli m) (Kleisli m)
instance [safe] (Distributive f, Extend w) => Semifunctor (WrappedFunctor f) (Cokleisli w) (Cokleisli w)
instance [safe] (Traversable f, Bind m, Monad m) => Semifunctor (WrappedFunctor f) (Kleisli m) (Kleisli m)
instance [safe] Functor f => Semifunctor (WrappedFunctor f) (->) (->)


module Data.Semifunctor.Associative
class Semifunctor p (Product k k) k => Associative k p
associate :: Associative k p => k (p (p (a, b), c)) (p (a, p (b, c)))
kleisliAssociate :: (Monad m, Semifunctor p (Product (Kleisli m) (Kleisli m)) (Kleisli m), Associative (->) p) => Kleisli m (p (p (a, b), c)) (p (a, p (b, c)))
cokleisliAssociate :: (Comonad m, Semifunctor p (Product (Cokleisli m) (Cokleisli m)) (Cokleisli m), Associative (->) p) => Cokleisli m (p (p (a, b), c)) (p (a, p (b, c)))
class Semifunctor p (Product k k) k => Disassociative k p
disassociate :: Disassociative k p => k (p (a, p (b, c))) (p (p (a, b), c))
kleisliDisassociate :: (Monad m, Semifunctor p (Product (Kleisli m) (Kleisli m)) (Kleisli m), Disassociative (->) p) => Kleisli m (p (a, p (b, c))) (p (p (a, b), c))
cokleisliDisassociate :: (Comonad m, Semifunctor p (Product (Cokleisli m) (Cokleisli m)) (Cokleisli m), Disassociative (->) p) => Cokleisli m (p (a, p (b, c))) (p (p (a, b), c))
instance (Extend m, Comonad m) => Disassociative (Cokleisli m) (Bi (,))
instance (Bind m, Monad m) => Disassociative (Kleisli m) (Bi (,))
instance (Bind m, Monad m) => Disassociative (Kleisli m) (Bi Either)
instance Disassociative (->) (Bi (,))
instance Disassociative (->) (Bi Either)
instance (Extend m, Comonad m) => Associative (Cokleisli m) (Bi (,))
instance (Bind m, Monad m) => Associative (Kleisli m) (Bi (,))
instance (Bind m, Monad m) => Associative (Kleisli m) (Bi Either)
instance Associative (->) (Bi (,))
instance Associative (->) (Bi Either)


module Data.Semifunctor.Braided
class Associative k p => Braided k p
braid :: Braided k p => k (p (a, b)) (p (b, a))
kleisliBraid :: (Monad m, Semifunctor p (Product (Kleisli m) (Kleisli m)) (Kleisli m), Braided (->) p) => Kleisli m (p (a, b)) (p (b, a))
cokleisliBraid :: (Extend w, Comonad w, Semifunctor p (Product (Cokleisli w) (Cokleisli w)) (Cokleisli w), Braided (->) p) => Cokleisli w (p (a, b)) (p (b, a))
class Braided k p => Symmetric k p
swap :: Symmetric k p => k (p (a, b)) (p (b, a))
instance [safe] (Extend w, Comonad w) => Symmetric (Cokleisli w) (Bi (,))
instance [safe] (Bind m, Monad m) => Symmetric (Kleisli m) (Bi (,))
instance [safe] (Bind m, Monad m) => Symmetric (Kleisli m) (Bi Either)
instance [safe] Symmetric (->) (Bi (,))
instance [safe] Symmetric (->) (Bi Either)
instance [safe] (Extend w, Comonad w) => Braided (Cokleisli w) (Bi (,))
instance [safe] (Bind m, Monad m) => Braided (Kleisli m) (Bi (,))
instance [safe] (Bind m, Monad m) => Braided (Kleisli m) (Bi Either)
instance [safe] Braided (->) (Bi (,))
instance [safe] Braided (->) (Bi Either)


module Data.Functor.Alt

-- | Laws:
--   
--   <pre>
--   &lt;!&gt; is associative:             (a &lt;!&gt; b) &lt;!&gt; c = a &lt;!&gt; (b &lt;!&gt; c)
--   &lt;$&gt; left-distributes over &lt;!&gt;:  f &lt;$&gt; (a &lt;!&gt; b) = (f &lt;$&gt; a) &lt;!&gt; (f &lt;$&gt; b)
--   </pre>
--   
--   If extended to an <a>Alternative</a> then <a>&lt;!&gt;</a> should
--   equal <a>&lt;|&gt;</a>.
--   
--   Ideally, an instance of <a>Alt</a> also satisfies the "left
--   distributon" law of MonadPlus with respect to <a>.</a>:
--   
--   <pre>
--   &lt;.&gt; right-distributes over &lt;!&gt;: (a &lt;!&gt; b) &lt;.&gt; c = (a &lt;.&gt; c) &lt;!&gt; (b &lt;.&gt; c)
--   </pre>
--   
--   But <a>Maybe</a>, <a>IO</a>, <tt><a>Either</a> a</tt>,
--   <tt><a>ErrorT</a> e m</tt>, and <tt>STM</tt> satisfy the alternative
--   "left catch" law instead:
--   
--   <pre>
--   pure a &lt;!&gt; b = pure a
--   </pre>
--   
--   However, this variation cannot be stated purely in terms of the
--   dependencies of <a>Alt</a>.
--   
--   When and if MonadPlus is successfully refactored, this class should
--   also be refactored to remove these instances.
--   
--   The right distributive law should extend in the cases where the a
--   <a>Bind</a> or <a>Monad</a> is provided to yield variations of the
--   right distributive law:
--   
--   <pre>
--   (m &lt;!&gt; n) &gt;&gt;- f = (m &gt;&gt;- f) &lt;!&gt; (m &gt;&gt;- f)
--   (m &lt;!&gt; n) &gt;&gt;= f = (m &gt;&gt;= f) &lt;!&gt; (m &gt;&gt;= f)
--   </pre>
class Functor f => Alt f where some v = some_v where many_v = some_v <!> pure [] some_v = (:) <$> v <*> many_v many v = many_v where many_v = some_v <!> pure [] some_v = (:) <$> v <*> many_v
(<!>) :: Alt f => f a -> f a -> f a
some :: (Alt f, Applicative f) => f a -> f [a]
many :: (Alt f, Applicative f) => f a -> f [a]
instance [safe] Alt f => Alt (RWST r w s f)
instance [safe] Alt f => Alt (RWST r w s f)
instance [safe] Alt f => Alt (WriterT w f)
instance [safe] Alt f => Alt (WriterT w f)
instance [safe] Alt f => Alt (StateT e f)
instance [safe] Alt f => Alt (StateT e f)
instance [safe] Apply f => Alt (ListT f)
instance [safe] (Bind f, Monad f, Semigroup e) => Alt (ExceptT e f)
instance [safe] (Bind f, Monad f) => Alt (ErrorT e f)
instance [safe] (Bind f, Monad f) => Alt (MaybeT f)
instance [safe] Alt f => Alt (ReaderT e f)
instance [safe] Alt f => Alt (IdentityT f)
instance [safe] Alternative f => Alt (WrappedApplicative f)
instance [safe] Alt NonEmpty
instance [safe] Alt Seq
instance [safe] Alt IntMap
instance [safe] Ord k => Alt (Map k)
instance [safe] ArrowPlus a => Alt (WrappedArrow a b)
instance [safe] MonadPlus m => Alt (WrappedMonad m)
instance [safe] Alt Option
instance [safe] Alt Maybe
instance [safe] Alt []
instance [safe] Alt IO
instance [safe] Alt (Either a)


module Data.Functor.Plus

-- | Laws:
--   
--   <pre>
--   zero &lt;!&gt; m = m
--   m &lt;!&gt; zero = m
--   </pre>
--   
--   If extended to an <a>Alternative</a> then <a>zero</a> should equal
--   <a>empty</a>.
class Alt f => Plus f
zero :: Plus f => f a
instance [safe] Plus f => Plus (RWST r w s f)
instance [safe] Plus f => Plus (RWST r w s f)
instance [safe] Plus f => Plus (WriterT w f)
instance [safe] Plus f => Plus (WriterT w f)
instance [safe] Plus f => Plus (StateT e f)
instance [safe] Plus f => Plus (StateT e f)
instance [safe] (Apply f, Applicative f) => Plus (ListT f)
instance [safe] (Bind f, Monad f, Error e) => Plus (ErrorT e f)
instance [safe] (Bind f, Monad f) => Plus (MaybeT f)
instance [safe] Plus f => Plus (ReaderT e f)
instance [safe] Plus f => Plus (IdentityT f)
instance [safe] Alternative f => Plus (WrappedApplicative f)
instance [safe] Plus Seq
instance [safe] Plus IntMap
instance [safe] Ord k => Plus (Map k)
instance [safe] ArrowPlus a => Plus (WrappedArrow a b)
instance [safe] MonadPlus m => Plus (WrappedMonad m)
instance [safe] Plus Option
instance [safe] Plus Maybe
instance [safe] Plus []
instance [safe] Plus IO

module Data.Semigroupoid.Static
newtype Static f a b
Static :: f (a -> b) -> Static f a b
runStatic :: Static f a b -> f (a -> b)
instance [safe] Applicative f => ArrowChoice (Static f)
instance [safe] Alternative f => ArrowPlus (Static f)
instance [safe] Alternative f => ArrowZero (Static f)
instance [safe] Applicative f => Arrow (Static f)
instance [safe] Applicative f => Category (Static f)
instance [safe] Apply f => Semigroupoid (Static f)
instance [safe] (Comonad f, Monoid a) => Comonad (Static f a)
instance [safe] (Extend f, Semigroup a) => Extend (Static f a)
instance [safe] Applicative f => Applicative (Static f a)
instance [safe] Plus f => Plus (Static f a)
instance [safe] Alt f => Alt (Static f a)
instance [safe] Apply f => Apply (Static f a)
instance [safe] Functor f => Functor (Static f a)
