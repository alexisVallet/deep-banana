-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Trie-based memo functions
--   
--   MemoTrie provides a basis for memoized functions over some domains,
--   using tries. It's based on ideas from Ralf Hinze and code from Spencer
--   Janssen.
--   
--   Project wiki page: <a>http://haskell.org/haskellwiki/MemoTrie</a>
--   
--   Â© 2008-2015 by Conal Elliott; BSD3 license. Generic support thanks to
--   Sam Boosalis.
@package MemoTrie
@version 0.6.4


-- | Trie-based memoizer
--   
--   Adapted from sjanssen's paste: <a>"a lazy trie"</a>, which I think is
--   based on Ralf Hinze's paper "Memo Functions, Polytypically!".
--   
--   You can automatically derive generic instances. for example:
--   
--   <pre>
--   {--}
--   import Data.MemoTrie
--   import GHC.Generics (Generic) 
--   
--   data Color = RGB Int Int Int
--              | NamedColor String 
--    deriving (<a>Generic</a>) 
--   
--   instance HasTrie Color where
--     newtype (Color :-&gt;: b) = ColorTrie { unColorTrie :: <a>Reg</a> Color :-&gt;: b } 
--     trie = <a>trieGeneric</a> ColorTrie 
--     untrie = <a>untrieGeneric</a> unColorTrie
--     enumerate = <a>enumerateGeneric</a> unColorTrie
--   </pre>
--   
--   see <tt>examples/Generic.hs</tt>, which can be run with:
--   
--   <pre>
--   $ cabal configure -fexamples &amp;&amp; cabal run generic
--   </pre>
module Data.MemoTrie

-- | Mapping from all elements of <tt>a</tt> to the results of some
--   function
class HasTrie a where data family (:->:) a :: * -> *

-- | Create the trie for the entire domain of a function
trie :: HasTrie a => (a -> b) -> (a :->: b)

-- | Convert a trie to a function, i.e., access a field of the trie
untrie :: HasTrie a => (a :->: b) -> (a -> b)

-- | List the trie elements. Order of keys (<tt>:: a</tt>) is always the
--   same.
enumerate :: HasTrie a => (a :->: b) -> [(a, b)]

-- | Domain elements of a trie
domain :: HasTrie a => [a]

-- | Identity trie
idTrie :: HasTrie a => a :->: a

-- | Trie composition
(@.@) :: (HasTrie a, HasTrie b) => (b :->: c) -> (a :->: b) -> (a :->: c)

-- | Trie-based function memoizer
memo :: HasTrie t => (t -> a) -> (t -> a)

-- | Memoize a binary function, on its first argument and then on its
--   second. Take care to exploit any partial evaluation.
memo2 :: (HasTrie s, HasTrie t) => (s -> t -> a) -> (s -> t -> a)

-- | Memoize a ternary function on successive arguments. Take care to
--   exploit any partial evaluation.
memo3 :: (HasTrie r, HasTrie s, HasTrie t) => (r -> s -> t -> a) -> (r -> s -> t -> a)

-- | Lift a memoizer to work with one more argument.
mup :: HasTrie t => (b -> c) -> (t -> b) -> (t -> c)

-- | Apply a unary function inside of a trie
inTrie :: (HasTrie a, HasTrie c) => ((a -> b) -> (c -> d)) -> ((a :->: b) -> (c :->: d))

-- | Apply a binary function inside of a trie
inTrie2 :: (HasTrie a, HasTrie c, HasTrie e) => ((a -> b) -> (c -> d) -> (e -> f)) -> ((a :->: b) -> (c :->: d) -> (e :->: f))

-- | Apply a ternary function inside of a trie
inTrie3 :: (HasTrie a, HasTrie c, HasTrie e, HasTrie g) => ((a -> b) -> (c -> d) -> (e -> f) -> (g -> h)) -> ((a :->: b) -> (c :->: d) -> (e :->: f) -> (g :->: h))
trieGeneric :: (Generic a, HasTrie (Reg a)) => ((Reg a :->: b) -> (a :->: b)) -> (a -> b) -> (a :->: b)
untrieGeneric :: (Generic a, HasTrie (Reg a)) => ((a :->: b) -> (Reg a :->: b)) -> (a :->: b) -> (a -> b)
enumerateGeneric :: (Generic a, HasTrie (Reg a)) => ((a :->: b) -> (Reg a :->: b)) -> (a :->: b) -> [(a, b)]

-- | the data type in a <b>reg</b>ular form. "unlifted" generic
--   representation. (i.e. is a unary type constructor).
type Reg a = Rep a ()
instance (Data.MemoTrie.HasTrie a, GHC.Classes.Eq b) => GHC.Classes.Eq (a Data.MemoTrie.:->: b)
instance (Data.MemoTrie.HasTrie a, GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (a Data.MemoTrie.:->: b)
instance Data.MemoTrie.HasTrie Data.Void.Void
instance Data.MemoTrie.HasTrie ()
instance Data.MemoTrie.HasTrie GHC.Types.Bool
instance (Data.MemoTrie.HasTrie a, Data.MemoTrie.HasTrie b) => Data.MemoTrie.HasTrie (Data.Either.Either a b)
instance (Data.MemoTrie.HasTrie a, Data.MemoTrie.HasTrie b) => Data.MemoTrie.HasTrie (a, b)
instance (Data.MemoTrie.HasTrie a, Data.MemoTrie.HasTrie b, Data.MemoTrie.HasTrie c) => Data.MemoTrie.HasTrie (a, b, c)
instance Data.MemoTrie.HasTrie x => Data.MemoTrie.HasTrie [x]
instance Data.MemoTrie.HasTrie GHC.Types.Word
instance Data.MemoTrie.HasTrie GHC.Word.Word8
instance Data.MemoTrie.HasTrie GHC.Word.Word16
instance Data.MemoTrie.HasTrie GHC.Word.Word32
instance Data.MemoTrie.HasTrie GHC.Word.Word64
instance Data.MemoTrie.HasTrie GHC.Types.Char
instance Data.MemoTrie.HasTrie GHC.Types.Int
instance Data.MemoTrie.HasTrie GHC.Int.Int8
instance Data.MemoTrie.HasTrie GHC.Int.Int16
instance Data.MemoTrie.HasTrie GHC.Int.Int32
instance Data.MemoTrie.HasTrie GHC.Int.Int64
instance Data.MemoTrie.HasTrie GHC.Integer.Type.Integer
instance (Data.MemoTrie.HasTrie a, GHC.Base.Monoid b) => GHC.Base.Monoid (a Data.MemoTrie.:->: b)
instance Data.MemoTrie.HasTrie a => GHC.Base.Functor ((Data.MemoTrie.:->:) a)
instance Data.MemoTrie.HasTrie a => GHC.Base.Applicative ((Data.MemoTrie.:->:) a)
instance Data.MemoTrie.HasTrie a => GHC.Base.Monad ((Data.MemoTrie.:->:) a)
instance Data.MemoTrie.HasTrie (GHC.Generics.V1 x)
instance Data.MemoTrie.HasTrie (GHC.Generics.U1 x)
instance (Data.MemoTrie.HasTrie (f x), Data.MemoTrie.HasTrie (g x)) => Data.MemoTrie.HasTrie ((GHC.Generics.:+:) f g x)
instance (Data.MemoTrie.HasTrie (f x), Data.MemoTrie.HasTrie (g x)) => Data.MemoTrie.HasTrie ((GHC.Generics.:*:) f g x)
instance Data.MemoTrie.HasTrie a => Data.MemoTrie.HasTrie (GHC.Generics.K1 i a x)
instance Data.MemoTrie.HasTrie (f x) => Data.MemoTrie.HasTrie (GHC.Generics.M1 i t f x)
