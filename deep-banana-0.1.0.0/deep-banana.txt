-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A GPU accelerated deep learning library.
--   
--   Please see README.md
@package deep-banana
@version 0.1.0.0

module DeepBanana.Prelude

module DeepBanana.Device.Monad
class Device d
deviceId :: Device d => Proxy d -> Int
newtype DeviceM d a
DeviceM :: IO a -> DeviceM d a
[unsafeRunDeviceM] :: DeviceM d a -> IO a
unsafeIOToDevice :: IO a -> DeviceM d a
runDeviceM :: (Device d) => Proxy d -> DeviceM d a -> IO a
onDevice :: Device d => Proxy d -> IO a -> IO a
instance forall (k :: BOX) (d :: k). GHC.Base.Functor (DeepBanana.Device.Monad.DeviceM d)
instance forall (k :: BOX) (d :: k). GHC.Base.Applicative (DeepBanana.Device.Monad.DeviceM d)
instance forall (k :: BOX) (d :: k). GHC.Base.Monad (DeepBanana.Device.Monad.DeviceM d)
instance forall (k :: BOX) (d :: k). Control.Monad.Primitive.PrimMonad (DeepBanana.Device.Monad.DeviceM d)
instance GHC.TypeLits.KnownNat n => DeepBanana.Device.Monad.Device n
instance forall (k :: BOX) (t :: k). Data.MemoTrie.HasTrie (Data.Proxy.Proxy t)

module DeepBanana.Device.CUDA
mallocArray :: Storable a => Int -> DeviceM k d (DevicePtr a)
newListArray :: Storable a => [a] -> DeviceM k d (DevicePtr a)
free :: DevicePtr a -> DeviceM k d ()
pokeArray :: Storable a => Int -> Ptr a -> DevicePtr a -> DeviceM k d ()
copyArray :: Storable a => Int -> DevicePtr a -> DevicePtr a -> DeviceM k d ()
peekListArray :: Storable a => Int -> DevicePtr a -> DeviceM k d [a]
peekArray :: Storable a => Int -> DevicePtr a -> Ptr a -> DeviceM k d ()


-- | FFI wrapper around CuDNN. |
module DeepBanana.Device.CuDNN
getVersion :: IO CSize
newtype Status
Status :: CInt -> Status
[unStatus] :: Status -> CInt
success :: Status
not_initialized :: Status
alloc_failed :: Status
bad_param :: Status
internal_error :: Status
invalid_value :: Status
arch_mismatch :: Status
mapping_error :: Status
getErrorString :: Status -> IO CString
execution_failed :: Status
not_supported :: Status
license_error :: Status
newtype Handle d
Handle :: Ptr () -> Handle d
[unHandle] :: Handle d -> Ptr ()
createHandle :: Ptr (Ptr ()) -> DeviceM d Status
destroyHandle :: Ptr () -> DeviceM d Status
getRawHandle :: (Device d) => Proxy d -> Ptr ()
handle :: (Device d) => Handle d
setStream :: Handle d -> Stream -> DeviceM d Status
getStream :: Handle d -> Ptr Stream -> DeviceM d Status
newtype TensorDescriptor
TensorDescriptor :: Ptr () -> TensorDescriptor
[unTensorDescriptor] :: TensorDescriptor -> Ptr ()
newtype ConvolutionDescriptor
ConvolutionDescriptor :: Ptr () -> ConvolutionDescriptor
[unConvolutionDescriptor] :: ConvolutionDescriptor -> Ptr ()
newtype PoolingDescriptor
PoolingDescriptor :: Ptr () -> PoolingDescriptor
[unPoolingDescriptor] :: PoolingDescriptor -> Ptr ()
newtype FilterDescriptor
FilterDescriptor :: Ptr () -> FilterDescriptor
[unFilterDescriptor] :: FilterDescriptor -> Ptr ()
newtype DataType
DataType :: CInt -> DataType
[unDataType] :: DataType -> CInt
float :: DataType
double :: DataType
createTensorDescriptor :: Ptr TensorDescriptor -> DeviceM d Status
newtype TensorFormat
TensorFormat :: CInt -> TensorFormat
[unTensorFormat] :: TensorFormat -> CInt
nchw :: TensorFormat
nhwc :: TensorFormat
setTensor4dDescriptor :: TensorDescriptor -> TensorFormat -> DataType -> CInt -> CInt -> CInt -> CInt -> DeviceM d Status
setTensor4dDescriptorEx :: TensorDescriptor -> DataType -> CInt -> CInt -> CInt -> CInt -> CInt -> CInt -> CInt -> CInt -> DeviceM d Status
getTensor4dDescriptor :: TensorDescriptor -> Ptr DataType -> Ptr CInt -> Ptr CInt -> Ptr CInt -> Ptr CInt -> Ptr CInt -> Ptr CInt -> Ptr CInt -> Ptr CInt -> DeviceM d Status
setTensorNdDescriptor :: TensorDescriptor -> DataType -> CInt -> Ptr CInt -> Ptr CInt -> DeviceM d Status
getTensorNdDescriptor :: TensorDescriptor -> CInt -> Ptr DataType -> Ptr CInt -> Ptr CInt -> Ptr CInt -> DeviceM d Status
destroyTensorDescriptor :: TensorDescriptor -> DeviceM d Status
transformTensor :: Handle d -> Ptr a -> TensorDescriptor -> DevicePtr a -> Ptr a -> TensorDescriptor -> DevicePtr a -> DeviceM d Status
newtype AddMode
AddMode :: CInt -> AddMode
[unAddMode] :: AddMode -> CInt
add_image :: AddMode
add_same_hw :: AddMode
add_feature_map :: AddMode
add_same_chw :: AddMode
add_same_c :: AddMode
addTensor :: Handle d -> Ptr a -> TensorDescriptor -> DevicePtr a -> Ptr a -> TensorDescriptor -> DevicePtr a -> DeviceM d Status
add_full_tensor :: AddMode
setTensor :: Handle d -> TensorDescriptor -> DevicePtr a -> DevicePtr a -> DeviceM d Status
newtype ConvolutionMode
ConvolutionMode :: CInt -> ConvolutionMode
[unConvolutionMode] :: ConvolutionMode -> CInt
convolution :: ConvolutionMode
cross_correlation :: ConvolutionMode
createFilterDescriptor :: Ptr FilterDescriptor -> DeviceM d Status
setFilter4dDescriptor :: FilterDescriptor -> DataType -> CInt -> CInt -> CInt -> CInt -> DeviceM d Status
getFilter4dDescriptor :: FilterDescriptor -> Ptr DataType -> Ptr CInt -> Ptr CInt -> Ptr CInt -> Ptr CInt -> DeviceM d Status
setFilterNdDescriptor :: FilterDescriptor -> DataType -> CInt -> Ptr CInt -> DeviceM d Status
getFilterNdDescriptor :: FilterDescriptor -> CInt -> Ptr DataType -> Ptr CInt -> Ptr CInt -> DeviceM d Status
destroyFilterDescriptor :: FilterDescriptor -> DeviceM d Status
createConvolutionDescriptor :: Ptr ConvolutionDescriptor -> DeviceM d Status
setConvolution2dDescriptor :: ConvolutionDescriptor -> CInt -> CInt -> CInt -> CInt -> CInt -> CInt -> ConvolutionMode -> DeviceM d Status
getConvolution2dDescriptor :: ConvolutionDescriptor -> Ptr CInt -> Ptr CInt -> Ptr CInt -> Ptr CInt -> Ptr CInt -> Ptr CInt -> Ptr ConvolutionMode -> DeviceM d Status
getConvolution2dForwardOutputDim :: ConvolutionDescriptor -> TensorDescriptor -> FilterDescriptor -> Ptr CInt -> Ptr CInt -> Ptr CInt -> Ptr CInt -> DeviceM d Status
setConvolutionNdDescriptor :: ConvolutionDescriptor -> CInt -> Ptr CInt -> Ptr CInt -> Ptr CInt -> ConvolutionMode -> DeviceM d Status
getConvolutionNdDescriptor :: ConvolutionDescriptor -> CInt -> Ptr CInt -> Ptr CInt -> Ptr CInt -> Ptr CInt -> Ptr ConvolutionMode -> DeviceM d Status
getConvolutionNdForwardOutputDim :: ConvolutionDescriptor -> TensorDescriptor -> FilterDescriptor -> CInt -> Ptr CInt -> DeviceM d Status
destroyConvolutionDescriptor :: ConvolutionDescriptor -> DeviceM d Status
newtype ConvolutionFwdPreference
ConvolutionFwdPreference :: CInt -> ConvolutionFwdPreference
[unConvolutionForwardPreference] :: ConvolutionFwdPreference -> CInt
convolution_fwd_no_workspace :: ConvolutionFwdPreference
convolution_fwd_prefer_fastest :: ConvolutionFwdPreference
convolution_fwd_specify_workspace_limit :: ConvolutionFwdPreference
newtype ConvolutionFwdAlgo
ConvolutionFwdAlgo :: CInt -> ConvolutionFwdAlgo
[unConvolutionFwdAlgo] :: ConvolutionFwdAlgo -> CInt
convolution_fwd_algo_implicit_gemm :: ConvolutionFwdAlgo
convolution_fwd_algo_implicit_precomp_gemm :: ConvolutionFwdAlgo
convolution_fwd_algo_gemm :: ConvolutionFwdAlgo
convolution_fwd_algo_direct :: ConvolutionFwdAlgo
convolution_fwd_algo_fft :: ConvolutionFwdAlgo
getConvolutionForwardAlgorithm :: Handle d -> TensorDescriptor -> FilterDescriptor -> ConvolutionDescriptor -> TensorDescriptor -> ConvolutionFwdPreference -> CSize -> Ptr ConvolutionFwdAlgo -> DeviceM d Status
convolution_fwd_algo_fft_tiling :: ConvolutionFwdAlgo
getConvolutionForwardWorkspaceSize :: Handle d -> TensorDescriptor -> FilterDescriptor -> ConvolutionDescriptor -> TensorDescriptor -> ConvolutionFwdAlgo -> Ptr CSize -> DeviceM d Status
convolutionForward :: Handle d -> Ptr a -> TensorDescriptor -> DevicePtr a -> FilterDescriptor -> DevicePtr a -> ConvolutionDescriptor -> ConvolutionFwdAlgo -> DevicePtr Int8 -> CSize -> Ptr a -> TensorDescriptor -> DevicePtr a -> DeviceM d Status
convolutionBackwardBias :: Handle d -> Ptr a -> TensorDescriptor -> DevicePtr a -> Ptr a -> TensorDescriptor -> DevicePtr a -> DeviceM d Status
newtype ConvolutionBwdFilterAlgo
ConvolutionBwdFilterAlgo :: CInt -> ConvolutionBwdFilterAlgo
[unConvolutionBwdFilterAlgo] :: ConvolutionBwdFilterAlgo -> CInt
convolution_bwd_filter_algo_0 :: ConvolutionBwdFilterAlgo
convolution_bwd_filter_algo_1 :: ConvolutionBwdFilterAlgo
convolution_bwd_filter_algo_fft :: ConvolutionBwdFilterAlgo
convolution_bwd_filter_algo_3 :: ConvolutionBwdFilterAlgo
getConvolutionBackwardFilterWorkspaceSize :: Handle d -> TensorDescriptor -> TensorDescriptor -> ConvolutionDescriptor -> FilterDescriptor -> ConvolutionBwdFilterAlgo -> Ptr CSize -> DeviceM d Status
convolutionBackwardFilter :: Handle d -> Ptr a -> TensorDescriptor -> DevicePtr a -> TensorDescriptor -> DevicePtr a -> ConvolutionDescriptor -> ConvolutionBwdFilterAlgo -> DevicePtr Int8 -> CSize -> Ptr a -> FilterDescriptor -> DevicePtr a -> DeviceM d Status
newtype ConvolutionBwdDataAlgo
ConvolutionBwdDataAlgo :: CInt -> ConvolutionBwdDataAlgo
[unConvoltuionBwdDataAlgo] :: ConvolutionBwdDataAlgo -> CInt
convolution_bwd_data_algo_0 :: ConvolutionBwdDataAlgo
convolution_bwd_data_algo_1 :: ConvolutionBwdDataAlgo
convolution_bwd_data_algo_fft :: ConvolutionBwdDataAlgo
convolution_bwd_data_algo_fft_tiling :: ConvolutionBwdDataAlgo
getConvolutionBackwardDataWorkspaceSize :: Handle d -> FilterDescriptor -> TensorDescriptor -> ConvolutionDescriptor -> TensorDescriptor -> ConvolutionBwdDataAlgo -> Ptr CSize -> DeviceM d Status
convolutionBackwardData :: Handle d -> Ptr a -> FilterDescriptor -> DevicePtr a -> TensorDescriptor -> DevicePtr a -> ConvolutionDescriptor -> ConvolutionBwdDataAlgo -> DevicePtr Int8 -> CSize -> Ptr a -> TensorDescriptor -> DevicePtr a -> DeviceM d Status
im2Col :: Handle d -> Ptr a -> TensorDescriptor -> DevicePtr a -> FilterDescriptor -> ConvolutionDescriptor -> DevicePtr a -> DeviceM d Status
newtype SoftmaxAlgorithm
SoftmaxAlgorithm :: CInt -> SoftmaxAlgorithm
[unSoftmaxAlgorithm] :: SoftmaxAlgorithm -> CInt
softmax_fast :: SoftmaxAlgorithm
softmax_accurate :: SoftmaxAlgorithm
newtype SoftmaxMode
SoftmaxMode :: CInt -> SoftmaxMode
[unSoftmaxMode] :: SoftmaxMode -> CInt
softmax_mode_instance :: SoftmaxMode
softmax_mode_channel :: SoftmaxMode
softmaxForward :: Handle d -> SoftmaxAlgorithm -> SoftmaxMode -> Ptr a -> TensorDescriptor -> DevicePtr a -> Ptr a -> TensorDescriptor -> DevicePtr a -> DeviceM d Status
softmaxBackward :: Handle d -> SoftmaxAlgorithm -> SoftmaxMode -> Ptr a -> TensorDescriptor -> DevicePtr a -> TensorDescriptor -> DevicePtr a -> Ptr a -> TensorDescriptor -> DevicePtr a -> DeviceM d Status
newtype PoolingMode
PoolingMode :: CInt -> PoolingMode
[unPoolingMode] :: PoolingMode -> CInt
pooling_max :: PoolingMode
pooling_average_count_include_padding :: PoolingMode
pooling_average_count_exclude_padding :: PoolingMode
createPoolingDescriptor :: Ptr PoolingDescriptor -> DeviceM d Status
setPooling2dDescriptor :: PoolingDescriptor -> PoolingMode -> CInt -> CInt -> CInt -> CInt -> CInt -> CInt -> DeviceM d Status
getPooling2dDescriptor :: PoolingDescriptor -> Ptr PoolingMode -> Ptr CInt -> Ptr CInt -> Ptr CInt -> Ptr CInt -> Ptr CInt -> Ptr CInt -> DeviceM d Status
setPoolingNdDescriptor :: PoolingDescriptor -> PoolingMode -> CInt -> Ptr CInt -> Ptr CInt -> Ptr CInt -> DeviceM d Status
getPoolingNdDescriptor :: PoolingDescriptor -> CInt -> Ptr PoolingMode -> Ptr CInt -> Ptr CInt -> Ptr CInt -> Ptr CInt -> DeviceM d Status
destroyPoolingDescriptor :: PoolingDescriptor -> DeviceM d Status
poolingForward :: Handle d -> PoolingDescriptor -> Ptr a -> TensorDescriptor -> DevicePtr a -> Ptr a -> TensorDescriptor -> DevicePtr a -> DeviceM d Status
poolingBackward :: Handle d -> PoolingDescriptor -> Ptr a -> TensorDescriptor -> DevicePtr a -> TensorDescriptor -> DevicePtr a -> TensorDescriptor -> DevicePtr a -> Ptr a -> TensorDescriptor -> DevicePtr a -> DeviceM d Status
newtype ActivationMode
ActivationMode :: CInt -> ActivationMode
[unActivationMode] :: ActivationMode -> CInt
activation_sigmoid :: ActivationMode
activation_relu :: ActivationMode
activation_tanh :: ActivationMode
activationForward :: Handle d -> ActivationMode -> Ptr a -> TensorDescriptor -> DevicePtr a -> Ptr a -> TensorDescriptor -> DevicePtr a -> DeviceM d Status
activationBackward :: Handle d -> ActivationMode -> Ptr a -> TensorDescriptor -> DevicePtr a -> TensorDescriptor -> DevicePtr a -> TensorDescriptor -> DevicePtr a -> Ptr a -> TensorDescriptor -> DevicePtr a -> DeviceM d Status
newtype BatchNormMode
BatchNormMode :: CInt -> BatchNormMode
[unBatchNormMode] :: BatchNormMode -> CInt
batchnorm_per_activation :: BatchNormMode
batchnorm_spatial :: BatchNormMode
batchNormalizationForwardInference :: Handle d -> BatchNormMode -> Ptr a -> Ptr a -> TensorDescriptor -> DevicePtr a -> TensorDescriptor -> DevicePtr a -> TensorDescriptor -> DevicePtr a -> DevicePtr a -> DevicePtr a -> DevicePtr a -> CDouble -> DeviceM d Status
batchNormalizationForwardTraining :: Handle d -> BatchNormMode -> Ptr a -> Ptr a -> TensorDescriptor -> DevicePtr a -> TensorDescriptor -> DevicePtr a -> TensorDescriptor -> DevicePtr a -> DevicePtr a -> CDouble -> DevicePtr a -> DevicePtr a -> CDouble -> DevicePtr a -> DevicePtr a -> DeviceM d Status
batchNormalizationBackward :: Handle d -> BatchNormMode -> Ptr a -> Ptr a -> Ptr a -> Ptr a -> TensorDescriptor -> DevicePtr a -> TensorDescriptor -> DevicePtr a -> TensorDescriptor -> DevicePtr a -> TensorDescriptor -> DevicePtr a -> DevicePtr a -> DevicePtr a -> Double -> DevicePtr a -> DevicePtr a -> DeviceM d Status
instance Foreign.Storable.Storable DeepBanana.Device.CuDNN.BatchNormMode
instance GHC.Show.Show DeepBanana.Device.CuDNN.BatchNormMode
instance GHC.Classes.Ord DeepBanana.Device.CuDNN.BatchNormMode
instance GHC.Classes.Eq DeepBanana.Device.CuDNN.BatchNormMode
instance Foreign.Storable.Storable DeepBanana.Device.CuDNN.ActivationMode
instance GHC.Classes.Eq DeepBanana.Device.CuDNN.ActivationMode
instance GHC.Show.Show DeepBanana.Device.CuDNN.ActivationMode
instance Foreign.Storable.Storable DeepBanana.Device.CuDNN.PoolingMode
instance GHC.Classes.Eq DeepBanana.Device.CuDNN.PoolingMode
instance GHC.Show.Show DeepBanana.Device.CuDNN.PoolingMode
instance Foreign.Storable.Storable DeepBanana.Device.CuDNN.SoftmaxMode
instance GHC.Classes.Eq DeepBanana.Device.CuDNN.SoftmaxMode
instance GHC.Show.Show DeepBanana.Device.CuDNN.SoftmaxMode
instance Foreign.Storable.Storable DeepBanana.Device.CuDNN.SoftmaxAlgorithm
instance GHC.Classes.Eq DeepBanana.Device.CuDNN.SoftmaxAlgorithm
instance GHC.Show.Show DeepBanana.Device.CuDNN.SoftmaxAlgorithm
instance Foreign.Storable.Storable DeepBanana.Device.CuDNN.ConvolutionBwdDataAlgo
instance GHC.Show.Show DeepBanana.Device.CuDNN.ConvolutionBwdDataAlgo
instance GHC.Classes.Ord DeepBanana.Device.CuDNN.ConvolutionBwdDataAlgo
instance GHC.Classes.Eq DeepBanana.Device.CuDNN.ConvolutionBwdDataAlgo
instance Foreign.Storable.Storable DeepBanana.Device.CuDNN.ConvolutionBwdFilterAlgo
instance GHC.Show.Show DeepBanana.Device.CuDNN.ConvolutionBwdFilterAlgo
instance GHC.Classes.Ord DeepBanana.Device.CuDNN.ConvolutionBwdFilterAlgo
instance GHC.Classes.Eq DeepBanana.Device.CuDNN.ConvolutionBwdFilterAlgo
instance Foreign.Storable.Storable DeepBanana.Device.CuDNN.ConvolutionFwdAlgo
instance GHC.Classes.Eq DeepBanana.Device.CuDNN.ConvolutionFwdAlgo
instance GHC.Show.Show DeepBanana.Device.CuDNN.ConvolutionFwdAlgo
instance Foreign.Storable.Storable DeepBanana.Device.CuDNN.ConvolutionFwdPreference
instance GHC.Classes.Eq DeepBanana.Device.CuDNN.ConvolutionFwdPreference
instance GHC.Show.Show DeepBanana.Device.CuDNN.ConvolutionFwdPreference
instance Foreign.Storable.Storable DeepBanana.Device.CuDNN.ConvolutionMode
instance GHC.Classes.Eq DeepBanana.Device.CuDNN.ConvolutionMode
instance GHC.Show.Show DeepBanana.Device.CuDNN.ConvolutionMode
instance Foreign.Storable.Storable DeepBanana.Device.CuDNN.AddMode
instance GHC.Classes.Eq DeepBanana.Device.CuDNN.AddMode
instance GHC.Show.Show DeepBanana.Device.CuDNN.AddMode
instance Foreign.Storable.Storable DeepBanana.Device.CuDNN.TensorFormat
instance GHC.Classes.Eq DeepBanana.Device.CuDNN.TensorFormat
instance GHC.Show.Show DeepBanana.Device.CuDNN.TensorFormat
instance Foreign.Storable.Storable DeepBanana.Device.CuDNN.DataType
instance GHC.Classes.Eq DeepBanana.Device.CuDNN.DataType
instance GHC.Show.Show DeepBanana.Device.CuDNN.DataType
instance Foreign.Storable.Storable DeepBanana.Device.CuDNN.FilterDescriptor
instance Foreign.Storable.Storable DeepBanana.Device.CuDNN.PoolingDescriptor
instance Foreign.Storable.Storable DeepBanana.Device.CuDNN.ConvolutionDescriptor
instance Foreign.Storable.Storable DeepBanana.Device.CuDNN.TensorDescriptor
instance forall (k :: BOX) (d :: k). Foreign.Storable.Storable (DeepBanana.Device.CuDNN.Handle d)
instance Foreign.Storable.Storable DeepBanana.Device.CuDNN.Status
instance GHC.Classes.Eq DeepBanana.Device.CuDNN.Status
instance GHC.Show.Show DeepBanana.Device.CuDNN.Status

module DeepBanana.Device.CuRAND
newtype Status
Status :: CInt -> Status
[unStatus] :: Status -> CInt
status_success :: Status
status_version_mismatch :: Status
status_not_initialized :: Status
status_allocation_failed :: Status
status_type_error :: Status
status_out_of_range :: Status
status_length_not_multiple :: Status
status_double_precision_required :: Status
status_launch_failure :: Status
newtype RngType
RngType :: CInt -> RngType
[unRngType] :: RngType -> CInt
status_preexisting_failure :: Status
rng_test :: RngType
status_initialization_failed :: Status
rng_pseudo_default :: RngType
status_arch_mismatch :: Status
rng_pseudo_xorwow :: RngType
status_internal_error :: Status
rng_pseudo_mrg32k3a :: RngType
rng_pseudo_mtgp32 :: RngType
rng_pseudo_mt19937 :: RngType
rng_pseudo_philox4_32_10 :: RngType
rng_quasi_default :: RngType
newtype CuRANDOrdering
CuRANDOrdering :: CInt -> CuRANDOrdering
[unCuRANDOrdering] :: CuRANDOrdering -> CInt
rng_quasi_sobol32 :: RngType
rng_quasi_scrambled_sobol32 :: RngType
ordering_pseudo_best :: CuRANDOrdering
rng_quasi_sobol64 :: RngType
ordering_pseudo_default :: CuRANDOrdering
rng_quasi_scrambled_sobol64 :: RngType
ordering_pseudo_seeded :: CuRANDOrdering
ordering_quasi_default :: CuRANDOrdering
newtype DirectionVectorSet
DirectionVectorSet :: CInt -> DirectionVectorSet
[unDirectionVectorSet] :: DirectionVectorSet -> CInt
newtype DirectionVectors32
DirectionVectors32 :: Ptr CUInt -> DirectionVectors32
[unDirectionVectors32] :: DirectionVectors32 -> Ptr CUInt
newtype DirectionVectors64
DirectionVectors64 :: Ptr CULLong -> DirectionVectors64
[unDirectionVectors64] :: DirectionVectors64 -> Ptr CULLong
direction_vectors_32_joekuo6 :: DirectionVectorSet
scrambled_direction_vectors_32_joekuo6 :: DirectionVectorSet
direction_vectors_64_joekuo6 :: DirectionVectorSet
scrambled_direction_vectors_64_joekuo6 :: DirectionVectorSet
newtype Generator d
Generator :: Ptr () -> Generator d
[unGenerator] :: Generator d -> Ptr ()
newtype Distribution
Distribution :: Ptr CDouble -> Distribution
[unDistribution] :: Distribution -> Ptr CDouble
newtype DistributionShift
DistributionShift :: Ptr () -> DistributionShift
[unDistributionShift] :: DistributionShift -> Ptr ()
newtype DistributionM2Shift
DistributionM2Shift :: Ptr () -> DistributionM2Shift
[unDistributionM2Shift] :: DistributionM2Shift -> Ptr ()
newtype HistogramM2
HistogramM2 :: Ptr () -> HistogramM2
[unHistogramM2] :: HistogramM2 -> Ptr ()
newtype HistogramM2K
HistogramM2K :: Ptr CInt -> HistogramM2K
[unHistogramM2K] :: HistogramM2K -> Ptr CInt
newtype HistogramM2V
HistogramM2V :: Ptr Distribution -> HistogramM2V
[unHistogramM2V] :: HistogramM2V -> Ptr Distribution
newtype DiscreteDistribution
DiscreteDistribution :: Ptr () -> DiscreteDistribution
[unDiscreteDistribution] :: DiscreteDistribution -> Ptr ()
newtype Method
Method :: CInt -> Method
[unMethod] :: Method -> CInt
choose_best :: Method
itr :: Method
knuth :: Method
hitr :: Method
m1 :: Method
m2 :: Method
binary_search :: Method
discrete_gauss :: Method
rejection :: Method
device_api :: Method
createGenerator :: Ptr (Generator d) -> RngType -> DeviceM d Status
fast_rejection :: Method
createGeneratorHost :: Ptr (Generator d) -> RngType -> DeviceM d Status
_3rd :: Method
definition :: Method
destroyGenerator :: Generator d -> DeviceM d Status
poisson :: Method
getVersion :: Ptr CInt -> DeviceM d Status
setStream :: Generator d -> Stream -> DeviceM d Status
setPseudoRandomGeneratorSeed :: Generator d -> CULLong -> DeviceM d Status
setGeneratorOffset :: Generator d -> CULLong -> DeviceM d Status
setGeneratorOrdering :: Generator d -> CuRANDOrdering -> DeviceM d Status
setQuasiRandomGeneratorDimensions :: Generator d -> CUInt -> DeviceM d Status
generate :: Generator d -> DevicePtr CUInt -> CSize -> DeviceM d Status
generateLongLong :: Generator d -> DevicePtr CULLong -> CSize -> DeviceM d Status
generateUniform :: Generator d -> DevicePtr CFloat -> CSize -> DeviceM d Status
generateUniformDouble :: Generator d -> DevicePtr CDouble -> CSize -> DeviceM d Status
generateNormal :: Generator d -> DevicePtr CFloat -> CSize -> CFloat -> CFloat -> DeviceM d Status
generateNormalDouble :: Generator d -> DevicePtr CDouble -> CSize -> CDouble -> CDouble -> DeviceM d Status
generateLogNormal :: Generator d -> DevicePtr CFloat -> CSize -> CFloat -> CFloat -> DeviceM d Status
generateLogNormalDouble :: Generator d -> DevicePtr CDouble -> CSize -> CDouble -> CDouble -> DeviceM d Status
createPoissonDistribution :: CDouble -> Ptr DiscreteDistribution -> DeviceM d Status
destroyDistribution :: DiscreteDistribution -> DeviceM d Status
generatePoisson :: Generator d -> DevicePtr CUInt -> CSize -> CDouble -> DeviceM d Status
generatePoissonMethod :: Generator d -> DevicePtr CUInt -> CSize -> CDouble -> DeviceM d Status
generateSeeds :: Generator d -> DeviceM d Status
getDirectionVectors32 :: Ptr (Ptr DirectionVectors32) -> DirectionVectorSet -> DeviceM d Status
getScrambleConstants32 :: Ptr (Ptr CUInt) -> DeviceM d Status
getDirectionVectors64 :: Ptr (Ptr DirectionVectors64) -> DirectionVectors64 -> DeviceM d Status
getScrambleConstants64 :: Ptr (Ptr CULLong) -> DeviceM d Status
instance Foreign.Storable.Storable DeepBanana.Device.CuRAND.Method
instance GHC.Classes.Eq DeepBanana.Device.CuRAND.Method
instance GHC.Show.Show DeepBanana.Device.CuRAND.Method
instance Foreign.Storable.Storable DeepBanana.Device.CuRAND.HistogramM2V
instance GHC.Classes.Eq DeepBanana.Device.CuRAND.HistogramM2V
instance GHC.Show.Show DeepBanana.Device.CuRAND.HistogramM2V
instance Foreign.Storable.Storable DeepBanana.Device.CuRAND.HistogramM2K
instance GHC.Classes.Eq DeepBanana.Device.CuRAND.HistogramM2K
instance GHC.Show.Show DeepBanana.Device.CuRAND.HistogramM2K
instance Foreign.Storable.Storable DeepBanana.Device.CuRAND.HistogramM2
instance Foreign.Storable.Storable DeepBanana.Device.CuRAND.DistributionM2Shift
instance Foreign.Storable.Storable DeepBanana.Device.CuRAND.DistributionShift
instance Foreign.Storable.Storable DeepBanana.Device.CuRAND.Distribution
instance GHC.Classes.Eq DeepBanana.Device.CuRAND.Distribution
instance GHC.Show.Show DeepBanana.Device.CuRAND.Distribution
instance forall (k :: BOX) (d :: k). Foreign.Storable.Storable (DeepBanana.Device.CuRAND.Generator d)
instance Foreign.Storable.Storable DeepBanana.Device.CuRAND.DirectionVectors32
instance Foreign.Storable.Storable DeepBanana.Device.CuRAND.DirectionVectorSet
instance GHC.Classes.Eq DeepBanana.Device.CuRAND.DirectionVectorSet
instance GHC.Show.Show DeepBanana.Device.CuRAND.DirectionVectorSet
instance Foreign.Storable.Storable DeepBanana.Device.CuRAND.CuRANDOrdering
instance GHC.Classes.Eq DeepBanana.Device.CuRAND.CuRANDOrdering
instance GHC.Show.Show DeepBanana.Device.CuRAND.CuRANDOrdering
instance Foreign.Storable.Storable DeepBanana.Device.CuRAND.RngType
instance GHC.Classes.Eq DeepBanana.Device.CuRAND.RngType
instance GHC.Show.Show DeepBanana.Device.CuRAND.RngType
instance Foreign.Storable.Storable DeepBanana.Device.CuRAND.Status
instance GHC.Classes.Eq DeepBanana.Device.CuRAND.Status
instance GHC.Show.Show DeepBanana.Device.CuRAND.Status


-- | FFI wrapper to custom CUDA code needed for for HNN.
module DeepBanana.Device.Cubits
thresh :: DevicePtr CFloat -> CSize -> CFloat -> DevicePtr CFloat -> DeviceM d ()
threshDouble :: DevicePtr CDouble -> CSize -> CDouble -> DevicePtr CDouble -> DeviceM d ()
mul :: DevicePtr CFloat -> DevicePtr CFloat -> CSize -> DeviceM d ()
mulDouble :: DevicePtr CDouble -> DevicePtr CDouble -> CSize -> DeviceM d ()
add :: DevicePtr CFloat -> DevicePtr CFloat -> CSize -> DeviceM d ()
addDouble :: DevicePtr CDouble -> DevicePtr CDouble -> CSize -> DeviceM d ()
tabs :: DevicePtr CFloat -> CSize -> DeviceM d ()
tabsDouble :: DevicePtr CDouble -> CSize -> DeviceM d ()
tsignum :: DevicePtr CFloat -> CSize -> DeviceM d ()
tsignumDouble :: DevicePtr CDouble -> CSize -> DeviceM d ()
subtract :: DevicePtr CFloat -> DevicePtr CFloat -> CSize -> DeviceM d ()
subtractDouble :: DevicePtr CDouble -> DevicePtr CDouble -> CSize -> DeviceM d ()
tnegate :: DevicePtr CFloat -> CSize -> DeviceM d ()
tnegateDouble :: DevicePtr CDouble -> CSize -> DeviceM d ()
scale :: CFloat -> DevicePtr CFloat -> CSize -> DeviceM d ()
scaleDouble :: CDouble -> DevicePtr CDouble -> CSize -> DeviceM d ()
logFloat :: DevicePtr CFloat -> CSize -> DeviceM d ()
logDouble :: DevicePtr CDouble -> CSize -> DeviceM d ()
inv :: DevicePtr CFloat -> CSize -> DeviceM d ()
invDouble :: DevicePtr CDouble -> CSize -> DeviceM d ()
texp :: DevicePtr CFloat -> CSize -> DeviceM d ()
texpDouble :: DevicePtr CDouble -> CSize -> DeviceM d ()
tsqrt :: DevicePtr CFloat -> CSize -> DeviceM d ()
tsqrtDouble :: DevicePtr CDouble -> CSize -> DeviceM d ()
tsin :: DevicePtr CFloat -> CSize -> DeviceM d ()
tsinDouble :: DevicePtr CDouble -> CSize -> DeviceM d ()
tcos :: DevicePtr CFloat -> CSize -> DeviceM d ()
tcosDouble :: DevicePtr CDouble -> CSize -> DeviceM d ()
ttan :: DevicePtr CFloat -> CSize -> DeviceM d ()
ttanDouble :: DevicePtr CDouble -> CSize -> DeviceM d ()
tasin :: DevicePtr CFloat -> CSize -> DeviceM d ()
tasinDouble :: DevicePtr CDouble -> CSize -> DeviceM d ()
tacos :: DevicePtr CFloat -> CSize -> DeviceM d ()
tacosDouble :: DevicePtr CDouble -> CSize -> DeviceM d ()
tatan :: DevicePtr CFloat -> CSize -> DeviceM d ()
tatanDouble :: DevicePtr CDouble -> CSize -> DeviceM d ()
tsinh :: DevicePtr CFloat -> CSize -> DeviceM d ()
tsinhDouble :: DevicePtr CDouble -> CSize -> DeviceM d ()
tcosh :: DevicePtr CFloat -> CSize -> DeviceM d ()
tcoshDouble :: DevicePtr CDouble -> CSize -> DeviceM d ()
ttanh :: DevicePtr CFloat -> CSize -> DeviceM d ()
ttanhDouble :: DevicePtr CDouble -> CSize -> DeviceM d ()
tasinh :: DevicePtr CFloat -> CSize -> DeviceM d ()
tasinhDouble :: DevicePtr CDouble -> CSize -> DeviceM d ()
tacosh :: DevicePtr CFloat -> CSize -> DeviceM d ()
tacoshDouble :: DevicePtr CDouble -> CSize -> DeviceM d ()
tatanh :: DevicePtr CFloat -> CSize -> DeviceM d ()
tatanhDouble :: DevicePtr CDouble -> CSize -> DeviceM d ()
tpow :: DevicePtr CFloat -> DevicePtr CFloat -> CSize -> DeviceM d ()
tpowDouble :: DevicePtr CDouble -> DevicePtr CDouble -> CSize -> DeviceM d ()
tmax :: DevicePtr CFloat -> DevicePtr CFloat -> CSize -> DeviceM d ()
tmaxDouble :: DevicePtr CDouble -> DevicePtr CDouble -> CSize -> DeviceM d ()
broadcast_copy :: CInt -> CSize -> DevicePtr CFloat -> DevicePtr CInt -> DevicePtr CFloat -> DevicePtr CInt -> DeviceM d ()
broadcast_copyDouble :: CInt -> CSize -> DevicePtr CDouble -> DevicePtr CInt -> DevicePtr CDouble -> DevicePtr CInt -> DeviceM d ()
freeDevicePtr :: FunPtr (Ptr a -> IO ())
freeCuRANDGenerator :: FunPtr (Ptr () -> IO ())

module DeepBanana.Exception
data WithStack e
withStack :: (?loc :: CallStack) => e -> WithStack e
data Coproduct (l :: [*])
Left' :: a -> Coproduct (a : l)
Right' :: Coproduct l -> Coproduct (a : l)
class Variant t e
setVariant :: Variant t e => e -> t
getVariant :: Variant t e => t -> Maybe e
throwVariant :: (MonadError t m, Variant t e) => e -> m a
catchVariant :: (MonadError t m, Variant t e) => m a -> (e -> m a) -> m a
unsafeRunExcept :: (Exception e) => Either e a -> a
embedExcept :: (MonadError e m) => Either e a -> m a
runExceptTAs :: Proxy t -> ExceptT t m a -> m (Either t a)
attemptGCThenRetryOn :: (MonadIO m, MonadError t m, Variant t e) => Proxy e -> m a -> m a
instance GHC.Generics.Selector DeepBanana.Exception.S1_0_1WithStack
instance GHC.Generics.Selector DeepBanana.Exception.S1_0_0WithStack
instance GHC.Generics.Constructor DeepBanana.Exception.C1_0WithStack
instance GHC.Generics.Datatype DeepBanana.Exception.D1WithStack
instance GHC.Generics.Generic (DeepBanana.Exception.WithStack e)
instance GHC.Classes.Eq e => GHC.Classes.Eq (DeepBanana.Exception.WithStack e)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (DeepBanana.Exception.Coproduct '[a])
instance (Control.DeepSeq.NFData a, Control.DeepSeq.NFData (DeepBanana.Exception.Coproduct b)) => Control.DeepSeq.NFData (DeepBanana.Exception.Coproduct (a : b))
instance DeepBanana.Exception.Variant a a
instance DeepBanana.Exception.Variant (DeepBanana.Exception.Coproduct b) e => DeepBanana.Exception.Variant (DeepBanana.Exception.Coproduct (a : b)) e
instance DeepBanana.Exception.Variant (DeepBanana.Exception.Coproduct (a : b)) a
instance GHC.Show.Show a => GHC.Show.Show (DeepBanana.Exception.Coproduct '[a])
instance (GHC.Show.Show a, GHC.Show.Show (DeepBanana.Exception.Coproduct b)) => GHC.Show.Show (DeepBanana.Exception.Coproduct (a : b))
instance (GHC.Show.Show a, Data.Typeable.Internal.Typeable a) => GHC.Exception.Exception (DeepBanana.Exception.Coproduct '[a])
instance (GHC.Show.Show a, GHC.Show.Show (DeepBanana.Exception.Coproduct b), Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable b, Data.Typeable.Internal.Typeable (DeepBanana.Exception.Coproduct b)) => GHC.Exception.Exception (DeepBanana.Exception.Coproduct (a : b))
instance Control.DeepSeq.NFData e => Control.DeepSeq.NFData (DeepBanana.Exception.WithStack e)
instance GHC.Show.Show e => GHC.Show.Show (DeepBanana.Exception.WithStack e)
instance (GHC.Classes.Eq e, GHC.Show.Show e, Data.Typeable.Internal.Typeable e) => GHC.Exception.Exception (DeepBanana.Exception.WithStack e)
instance DeepBanana.Exception.Variant t e => DeepBanana.Exception.Variant (DeepBanana.Exception.WithStack t) e

module DeepBanana.Layer.CUDA.Exception
handleCUDAException :: (MonadIO m, MonadError t m, Variant t e, CUDAException e) => Proxy e -> IO a -> m a
class (Eq e, Exception e) => CUDAException e
data MemoryAllocation
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_79Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_78Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_77Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_76Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_75Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_74Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_73Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_72Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_71Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_70Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_69Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_68Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_67Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_66Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_65Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_64Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_63Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_62Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_61Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_60Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_59Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_58Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_57Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_56Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_55Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_54Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_53Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_52Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_51Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_50Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_49Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_48Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_47Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_46Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_45Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_44Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_43Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_42Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_41Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_40Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_39Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_38Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_37Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_36Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_35Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_34Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_33Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_32Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_31Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_30Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_29Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_28Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_27Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_26Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_25Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_24Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_23Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_22Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_21Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_20Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_19Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_18Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_17Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_16Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_15Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_14Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_13Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_12Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_11Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_10Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_9Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_8Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_7Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_6Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_5Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_4Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_3Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_2Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_1Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_0Status
instance GHC.Generics.Datatype DeepBanana.Layer.CUDA.Exception.D1Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.Exception.C1_0MemoryAllocation
instance GHC.Generics.Datatype DeepBanana.Layer.CUDA.Exception.D1MemoryAllocation
instance Control.DeepSeq.NFData DeepBanana.Layer.CUDA.Exception.MemoryAllocation
instance GHC.Generics.Generic DeepBanana.Layer.CUDA.Exception.MemoryAllocation
instance GHC.Exception.Exception DeepBanana.Layer.CUDA.Exception.MemoryAllocation
instance GHC.Show.Show DeepBanana.Layer.CUDA.Exception.MemoryAllocation
instance GHC.Classes.Eq DeepBanana.Layer.CUDA.Exception.MemoryAllocation
instance GHC.Classes.Eq Foreign.CUDA.Runtime.Error.CUDAException
instance GHC.Generics.Generic Foreign.CUDA.Runtime.Error.Status
instance Control.DeepSeq.NFData Foreign.CUDA.Runtime.Error.Status
instance DeepBanana.Layer.CUDA.Exception.CUDAException DeepBanana.Layer.CUDA.Exception.MemoryAllocation

module DeepBanana.Layer.CUDA.CuDNN.Exception
data BadParam
badParam :: (?loc :: CallStack) => BadParam
data NotInitialized
notInitialized :: (?loc :: CallStack) => NotInitialized
data AllocFailed
allocFailed :: (?loc :: CallStack) => AllocFailed
data InternalError
internalError :: (?loc :: CallStack) => InternalError
data InvalidValue
invalidValue :: (?loc :: CallStack) => InvalidValue
data ArchMismatch
archMismatch :: (?loc :: CallStack) => ArchMismatch
data MappingError
mappingError :: (?loc :: CallStack) => MappingError
data ExecutionFailed
executionFailed :: (?loc :: CallStack) => ExecutionFailed
data NotSupported
notSupported :: (?loc :: CallStack) => NotSupported
data LicenseError
licenseError :: (?loc :: CallStack) => LicenseError
class StatusException e
handleStatus :: (?loc :: CallStack, MonadError t m, Variant t e, StatusException e) => Proxy e -> m Status -> m Status
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.CuDNN.Exception.C1_0LicenseError
instance GHC.Generics.Datatype DeepBanana.Layer.CUDA.CuDNN.Exception.D1LicenseError
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.CuDNN.Exception.C1_0NotSupported
instance GHC.Generics.Datatype DeepBanana.Layer.CUDA.CuDNN.Exception.D1NotSupported
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.CuDNN.Exception.C1_0ExecutionFailed
instance GHC.Generics.Datatype DeepBanana.Layer.CUDA.CuDNN.Exception.D1ExecutionFailed
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.CuDNN.Exception.C1_0MappingError
instance GHC.Generics.Datatype DeepBanana.Layer.CUDA.CuDNN.Exception.D1MappingError
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.CuDNN.Exception.C1_0ArchMismatch
instance GHC.Generics.Datatype DeepBanana.Layer.CUDA.CuDNN.Exception.D1ArchMismatch
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.CuDNN.Exception.C1_0InvalidValue
instance GHC.Generics.Datatype DeepBanana.Layer.CUDA.CuDNN.Exception.D1InvalidValue
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.CuDNN.Exception.C1_0InternalError
instance GHC.Generics.Datatype DeepBanana.Layer.CUDA.CuDNN.Exception.D1InternalError
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.CuDNN.Exception.C1_0AllocFailed
instance GHC.Generics.Datatype DeepBanana.Layer.CUDA.CuDNN.Exception.D1AllocFailed
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.CuDNN.Exception.C1_0NotInitialized
instance GHC.Generics.Datatype DeepBanana.Layer.CUDA.CuDNN.Exception.D1NotInitialized
instance GHC.Generics.Constructor DeepBanana.Layer.CUDA.CuDNN.Exception.C1_0BadParam
instance GHC.Generics.Datatype DeepBanana.Layer.CUDA.CuDNN.Exception.D1BadParam
instance Control.DeepSeq.NFData DeepBanana.Layer.CUDA.CuDNN.Exception.LicenseError
instance GHC.Generics.Generic DeepBanana.Layer.CUDA.CuDNN.Exception.LicenseError
instance GHC.Exception.Exception DeepBanana.Layer.CUDA.CuDNN.Exception.LicenseError
instance GHC.Show.Show DeepBanana.Layer.CUDA.CuDNN.Exception.LicenseError
instance GHC.Classes.Eq DeepBanana.Layer.CUDA.CuDNN.Exception.LicenseError
instance Control.DeepSeq.NFData DeepBanana.Layer.CUDA.CuDNN.Exception.NotSupported
instance GHC.Generics.Generic DeepBanana.Layer.CUDA.CuDNN.Exception.NotSupported
instance GHC.Exception.Exception DeepBanana.Layer.CUDA.CuDNN.Exception.NotSupported
instance GHC.Show.Show DeepBanana.Layer.CUDA.CuDNN.Exception.NotSupported
instance GHC.Classes.Eq DeepBanana.Layer.CUDA.CuDNN.Exception.NotSupported
instance Control.DeepSeq.NFData DeepBanana.Layer.CUDA.CuDNN.Exception.ExecutionFailed
instance GHC.Generics.Generic DeepBanana.Layer.CUDA.CuDNN.Exception.ExecutionFailed
instance GHC.Exception.Exception DeepBanana.Layer.CUDA.CuDNN.Exception.ExecutionFailed
instance GHC.Show.Show DeepBanana.Layer.CUDA.CuDNN.Exception.ExecutionFailed
instance GHC.Classes.Eq DeepBanana.Layer.CUDA.CuDNN.Exception.ExecutionFailed
instance Control.DeepSeq.NFData DeepBanana.Layer.CUDA.CuDNN.Exception.MappingError
instance GHC.Generics.Generic DeepBanana.Layer.CUDA.CuDNN.Exception.MappingError
instance GHC.Exception.Exception DeepBanana.Layer.CUDA.CuDNN.Exception.MappingError
instance GHC.Show.Show DeepBanana.Layer.CUDA.CuDNN.Exception.MappingError
instance GHC.Classes.Eq DeepBanana.Layer.CUDA.CuDNN.Exception.MappingError
instance Control.DeepSeq.NFData DeepBanana.Layer.CUDA.CuDNN.Exception.ArchMismatch
instance GHC.Generics.Generic DeepBanana.Layer.CUDA.CuDNN.Exception.ArchMismatch
instance GHC.Exception.Exception DeepBanana.Layer.CUDA.CuDNN.Exception.ArchMismatch
instance GHC.Show.Show DeepBanana.Layer.CUDA.CuDNN.Exception.ArchMismatch
instance GHC.Classes.Eq DeepBanana.Layer.CUDA.CuDNN.Exception.ArchMismatch
instance Control.DeepSeq.NFData DeepBanana.Layer.CUDA.CuDNN.Exception.InvalidValue
instance GHC.Generics.Generic DeepBanana.Layer.CUDA.CuDNN.Exception.InvalidValue
instance GHC.Exception.Exception DeepBanana.Layer.CUDA.CuDNN.Exception.InvalidValue
instance GHC.Show.Show DeepBanana.Layer.CUDA.CuDNN.Exception.InvalidValue
instance GHC.Classes.Eq DeepBanana.Layer.CUDA.CuDNN.Exception.InvalidValue
instance Control.DeepSeq.NFData DeepBanana.Layer.CUDA.CuDNN.Exception.InternalError
instance GHC.Generics.Generic DeepBanana.Layer.CUDA.CuDNN.Exception.InternalError
instance GHC.Exception.Exception DeepBanana.Layer.CUDA.CuDNN.Exception.InternalError
instance GHC.Show.Show DeepBanana.Layer.CUDA.CuDNN.Exception.InternalError
instance GHC.Classes.Eq DeepBanana.Layer.CUDA.CuDNN.Exception.InternalError
instance Control.DeepSeq.NFData DeepBanana.Layer.CUDA.CuDNN.Exception.AllocFailed
instance GHC.Generics.Generic DeepBanana.Layer.CUDA.CuDNN.Exception.AllocFailed
instance GHC.Exception.Exception DeepBanana.Layer.CUDA.CuDNN.Exception.AllocFailed
instance GHC.Show.Show DeepBanana.Layer.CUDA.CuDNN.Exception.AllocFailed
instance GHC.Classes.Eq DeepBanana.Layer.CUDA.CuDNN.Exception.AllocFailed
instance Control.DeepSeq.NFData DeepBanana.Layer.CUDA.CuDNN.Exception.NotInitialized
instance GHC.Generics.Generic DeepBanana.Layer.CUDA.CuDNN.Exception.NotInitialized
instance GHC.Exception.Exception DeepBanana.Layer.CUDA.CuDNN.Exception.NotInitialized
instance GHC.Show.Show DeepBanana.Layer.CUDA.CuDNN.Exception.NotInitialized
instance GHC.Classes.Eq DeepBanana.Layer.CUDA.CuDNN.Exception.NotInitialized
instance Control.DeepSeq.NFData DeepBanana.Layer.CUDA.CuDNN.Exception.BadParam
instance GHC.Generics.Generic DeepBanana.Layer.CUDA.CuDNN.Exception.BadParam
instance GHC.Exception.Exception DeepBanana.Layer.CUDA.CuDNN.Exception.BadParam
instance GHC.Show.Show DeepBanana.Layer.CUDA.CuDNN.Exception.BadParam
instance GHC.Classes.Eq DeepBanana.Layer.CUDA.CuDNN.Exception.BadParam
instance DeepBanana.Layer.CUDA.CuDNN.Exception.StatusException DeepBanana.Layer.CUDA.CuDNN.Exception.BadParam
instance DeepBanana.Layer.CUDA.CuDNN.Exception.StatusException DeepBanana.Layer.CUDA.CuDNN.Exception.NotInitialized
instance DeepBanana.Layer.CUDA.CuDNN.Exception.StatusException DeepBanana.Layer.CUDA.CuDNN.Exception.AllocFailed
instance DeepBanana.Layer.CUDA.CuDNN.Exception.StatusException DeepBanana.Layer.CUDA.CuDNN.Exception.InternalError
instance DeepBanana.Layer.CUDA.CuDNN.Exception.StatusException DeepBanana.Layer.CUDA.CuDNN.Exception.InvalidValue
instance DeepBanana.Layer.CUDA.CuDNN.Exception.StatusException DeepBanana.Layer.CUDA.CuDNN.Exception.ArchMismatch
instance DeepBanana.Layer.CUDA.CuDNN.Exception.StatusException DeepBanana.Layer.CUDA.CuDNN.Exception.MappingError
instance DeepBanana.Layer.CUDA.CuDNN.Exception.StatusException DeepBanana.Layer.CUDA.CuDNN.Exception.ExecutionFailed
instance DeepBanana.Layer.CUDA.CuDNN.Exception.StatusException DeepBanana.Layer.CUDA.CuDNN.Exception.NotSupported
instance DeepBanana.Layer.CUDA.CuDNN.Exception.StatusException DeepBanana.Layer.CUDA.CuDNN.Exception.LicenseError

module DeepBanana.Tensor.Exception
data OutOfMemory
outOfMemory :: (?loc :: CallStack) => String -> OutOfMemory
data IncompatibleSize
incompatibleSize :: (?loc :: CallStack) => String -> IncompatibleSize
data IncompatibleShape
incompatibleShape :: (?loc :: CallStack) => String -> IncompatibleShape
instance GHC.Generics.Constructor DeepBanana.Tensor.Exception.C1_0IncompatibleShape
instance GHC.Generics.Datatype DeepBanana.Tensor.Exception.D1IncompatibleShape
instance GHC.Generics.Constructor DeepBanana.Tensor.Exception.C1_0IncompatibleSize
instance GHC.Generics.Datatype DeepBanana.Tensor.Exception.D1IncompatibleSize
instance GHC.Generics.Constructor DeepBanana.Tensor.Exception.C1_0OutOfMemory
instance GHC.Generics.Datatype DeepBanana.Tensor.Exception.D1OutOfMemory
instance Control.DeepSeq.NFData DeepBanana.Tensor.Exception.IncompatibleShape
instance GHC.Generics.Generic DeepBanana.Tensor.Exception.IncompatibleShape
instance GHC.Exception.Exception DeepBanana.Tensor.Exception.IncompatibleShape
instance GHC.Show.Show DeepBanana.Tensor.Exception.IncompatibleShape
instance GHC.Classes.Eq DeepBanana.Tensor.Exception.IncompatibleShape
instance Control.DeepSeq.NFData DeepBanana.Tensor.Exception.IncompatibleSize
instance GHC.Generics.Generic DeepBanana.Tensor.Exception.IncompatibleSize
instance GHC.Exception.Exception DeepBanana.Tensor.Exception.IncompatibleSize
instance GHC.Show.Show DeepBanana.Tensor.Exception.IncompatibleSize
instance GHC.Classes.Eq DeepBanana.Tensor.Exception.IncompatibleSize
instance Control.DeepSeq.NFData DeepBanana.Tensor.Exception.OutOfMemory
instance GHC.Generics.Generic DeepBanana.Tensor.Exception.OutOfMemory
instance GHC.Exception.Exception DeepBanana.Tensor.Exception.OutOfMemory
instance GHC.Show.Show DeepBanana.Tensor.Exception.OutOfMemory
instance GHC.Classes.Eq DeepBanana.Tensor.Exception.OutOfMemory

module DeepBanana.Data.Exception
data EmptyBatch
emptyBatch :: (?loc :: CallStack) => String -> EmptyBatch
instance GHC.Generics.Constructor DeepBanana.Data.Exception.C1_0EmptyBatch
instance GHC.Generics.Datatype DeepBanana.Data.Exception.D1EmptyBatch
instance Control.DeepSeq.NFData DeepBanana.Data.Exception.EmptyBatch
instance GHC.Generics.Generic DeepBanana.Data.Exception.EmptyBatch
instance GHC.Exception.Exception DeepBanana.Data.Exception.EmptyBatch
instance GHC.Show.Show DeepBanana.Data.Exception.EmptyBatch
instance GHC.Classes.Eq DeepBanana.Data.Exception.EmptyBatch

module DeepBanana.Device
data Generator
Generator :: CULLong -> CULLong -> Generator
[seed] :: Generator -> CULLong
[offset] :: Generator -> CULLong
generator :: CULLong -> Generator
withGenerator :: (Device d) => Generator -> (Generator d -> DeviceM d a) -> DeviceM d a
class DeviceTransfer t1 t2
transfer :: (DeviceTransfer t1 t2, MonadError t m, Variant t OutOfMemory) => t1 -> m t2
transfer' :: (DeviceTransfer t1 t2) => t1 -> t2
instance GHC.Show.Show DeepBanana.Device.Generator
instance GHC.Classes.Ord DeepBanana.Device.Generator
instance GHC.Classes.Eq DeepBanana.Device.Generator

module DeepBanana.Layer.CUDA.Monad
type CudaErrorT = ExceptT CudaExceptions
type CudaError = CudaErrorT Identity
type CudaT m = CudaErrorT (CudaRandT m)
type Cuda = CudaT Identity
type CudaExceptions = Coproduct '[AllocFailed, BadParam, NotSupported, MemoryAllocation, MappingError, ExecutionFailed, OutOfMemory, IncompatibleShape, IncompatibleSize, EmptyBatch]
class (MonadError CudaExceptions m) => MonadCudaError m
runCudaErrorT :: (Monad m) => CudaErrorT m a -> m (Either CudaExceptions a)
runCudaError :: CudaError a -> Either CudaExceptions a
unsafeRunCudaError :: CudaError a -> a
cudaErrorHoist :: (Monad m, Monad m') => (forall a. m a -> m' a) -> CudaErrorT m a -> CudaErrorT m' a
class (MonadState (Generator) m) => MonadCudaRand m
class (MonadCudaError m, MonadCudaRand m) => MonadCuda m
runCudaT :: (Monad m) => Generator -> CudaT m a -> m (Either CudaExceptions a, Generator)
runCudaTEx :: (MonadThrow m) => Generator -> CudaT m a -> m (a, Generator)
runCuda :: Generator -> Cuda a -> (Either CudaExceptions a, Generator)
runCudaEx :: Generator -> Cuda a -> (a, Generator)
cudaHoist :: (Monad m, Monad n) => (forall a. m a -> n a) -> CudaT m a -> CudaT n a
unsafeIOToPrim :: (PrimMonad m) => IO a -> m a
embedCuda :: (Monad m, MonadCuda m') => (forall a. m a -> m' a) -> CudaT m b -> m' b
embedCudaFromST :: (MonadCuda m) => (forall s. CudaT (ST s) a) -> m a
embedCudaError :: (Monad m, MonadCudaError m') => (forall a. m a -> m' a) -> CudaErrorT m a -> m' a
embedCudaErrorFromST :: (MonadCudaError m) => (forall s. CudaErrorT (ST s) a) -> m a
instance Control.Monad.Error.Class.MonadError DeepBanana.Layer.CUDA.Monad.CudaExceptions m => DeepBanana.Layer.CUDA.Monad.MonadCudaError m
instance Control.Monad.State.Class.MonadState DeepBanana.Device.Generator m => DeepBanana.Layer.CUDA.Monad.MonadCudaRand m
instance (DeepBanana.Layer.CUDA.Monad.MonadCudaError m, DeepBanana.Layer.CUDA.Monad.MonadCudaRand m) => DeepBanana.Layer.CUDA.Monad.MonadCuda m


-- | Defines datatype which can be used as scalar elements for a tensor.
--   Also exports much needed, although orphan instances for <a>CFloat</a>
--   and <a>CDouble</a>: <a>Generic</a>, <a>NFData</a> and
--   <tt>Serialize</tt>.
module DeepBanana.Tensor.TensorScalar

-- | Type class for tensor scalars. Basically requires them to be storable,
--   serializable, deepseqable numbers that can be handled by CUDA, Cublas,
--   CuDNN and Haskell. Basically requires low-level numeric routines.
class (Floating a, Storable a, VectorSpace a, a ~ Scalar a, Serialize a, NFData a) => TensorScalar a

-- | The corresponding CuDNN datatype.
datatype :: TensorScalar a => Proxy a -> DataType

-- | Low-level in-place numeric operations.
thresh :: TensorScalar a => DevicePtr a -> CSize -> a -> DevicePtr a -> DeviceM d ()
rawMul :: TensorScalar a => DevicePtr a -> DevicePtr a -> CSize -> DeviceM d ()
rawAdd :: TensorScalar a => DevicePtr a -> DevicePtr a -> CSize -> DeviceM d ()
rawAbs :: TensorScalar a => DevicePtr a -> CSize -> DeviceM d ()
rawSignum :: TensorScalar a => DevicePtr a -> CSize -> DeviceM d ()
rawSubtract :: TensorScalar a => DevicePtr a -> DevicePtr a -> CSize -> DeviceM d ()
rawNegate :: TensorScalar a => DevicePtr a -> CSize -> DeviceM d ()
rawScale :: TensorScalar a => a -> DevicePtr a -> CSize -> DeviceM d ()
rawLog :: TensorScalar a => DevicePtr a -> CSize -> DeviceM d ()
rawInv :: TensorScalar a => DevicePtr a -> CSize -> DeviceM d ()
rawExp :: TensorScalar a => DevicePtr a -> CSize -> DeviceM d ()
rawSqrt :: TensorScalar a => DevicePtr a -> CSize -> DeviceM d ()
rawSin :: TensorScalar a => DevicePtr a -> CSize -> DeviceM d ()
rawCos :: TensorScalar a => DevicePtr a -> CSize -> DeviceM d ()
rawTan :: TensorScalar a => DevicePtr a -> CSize -> DeviceM d ()
rawAsin :: TensorScalar a => DevicePtr a -> CSize -> DeviceM d ()
rawAcos :: TensorScalar a => DevicePtr a -> CSize -> DeviceM d ()
rawAtan :: TensorScalar a => DevicePtr a -> CSize -> DeviceM d ()
rawSinh :: TensorScalar a => DevicePtr a -> CSize -> DeviceM d ()
rawCosh :: TensorScalar a => DevicePtr a -> CSize -> DeviceM d ()
rawTanh :: TensorScalar a => DevicePtr a -> CSize -> DeviceM d ()
rawAsinh :: TensorScalar a => DevicePtr a -> CSize -> DeviceM d ()
rawAcosh :: TensorScalar a => DevicePtr a -> CSize -> DeviceM d ()
rawAtanh :: TensorScalar a => DevicePtr a -> CSize -> DeviceM d ()
rawPow :: TensorScalar a => DevicePtr a -> DevicePtr a -> CSize -> DeviceM d ()
rawMax :: TensorScalar a => DevicePtr a -> DevicePtr a -> CSize -> DeviceM d ()
broadcast_copy :: TensorScalar a => CInt -> CSize -> DevicePtr a -> DevicePtr CInt -> DevicePtr a -> DevicePtr CInt -> DeviceM d ()

-- | Low-level CuRAND bindings.
generateUniform :: TensorScalar a => Generator d -> DevicePtr a -> CSize -> DeviceM d Status
generateNormal :: TensorScalar a => Generator d -> DevicePtr a -> CSize -> a -> a -> DeviceM d Status
generateLogNormal :: TensorScalar a => Generator d -> DevicePtr a -> CSize -> a -> a -> DeviceM d Status

-- | Haskell type representing the C <tt>float</tt> type.
data CFloat :: *

-- | Haskell type representing the C <tt>double</tt> type.
data CDouble :: *
mySizeOf :: Storable a => Proxy a -> Int
instance GHC.Generics.Generic Foreign.C.Types.CFloat
instance GHC.Generics.Generic Foreign.C.Types.CDouble
instance Data.Serialize.Serialize Foreign.C.Types.CFloat
instance Data.Serialize.Serialize Foreign.C.Types.CDouble
instance DeepBanana.Tensor.TensorScalar.TensorScalar Foreign.C.Types.CFloat
instance DeepBanana.Tensor.TensorScalar.TensorScalar Foreign.C.Types.CDouble


-- | Heterogeneous lists. Used notably for:
--   
--   <ul>
--   <li>Tensor shapes</li>
--   <li>Neural network weights</li>
--   <li>Multi GPU</li>
--   </ul>
--   
--   It is similar in principle and very much inspired by Oleg Kiselyov's
--   <a>HList package</a>.
module DeepBanana.HList

-- | An <tt><a>HList</a> l</tt> is an heterogeneous list indexed by a
--   type-level list <tt>l</tt> of its elements datatypes.
--   
--   <pre>
--   1:."Hi!":.(+):.Z :: HList '[Int,String,Float -&gt; Float -&gt; Float]
--   </pre>

-- | Fixed size homogeneous list datatype. Useful to define shapes with
--   dynamic dimensions and fixed length, for instance.
type SizedList (n :: Nat) (a :: *) = HList (SizedList' n a)

-- | Helper type family for <tt><a>SizedList</a></tt>.

-- | Concatenating and splitting heterogeneous lists.
class Concat (l1 :: [*]) (l2 :: [*]) where type family ConcatRes l1 l2 :: [*]
hconcat :: Concat l1 l2 => HList l1 -> HList l2 -> HList (ConcatRes l1 l2)
hsplit :: Concat l1 l2 => HList (ConcatRes l1 l2) -> (HList l1, HList l2)

-- | Heterogeneous category type class. Used to overload feed-forward
--   composition across a few layer datatypes.
class HCategory (cat :: [*] -> * -> * -> *)
id' :: HCategory cat => cat '[] a a
(>+>) :: (HCategory cat, Concat l1 l2) => cat l1 a b -> cat l2 b c -> cat (ConcatRes l1 l2) a c

-- | Heterogeneous monoid type class. Used to overload heterogeneous list
--   concatenation for weights datatypes notably.
class HMonoid (t :: [*] -> *)
hmempty :: HMonoid t => t '[]
(<+>) :: (HMonoid t, Concat l1 l2) => t l1 -> t l2 -> t (ConcatRes l1 l2)
instance GHC.Classes.Eq (DeepBanana.HList.HList '[])
instance (GHC.Classes.Eq e, GHC.Classes.Eq (DeepBanana.HList.HList l)) => GHC.Classes.Eq (DeepBanana.HList.HList (e : l))
instance GHC.Classes.Ord (DeepBanana.HList.HList '[])
instance (GHC.Classes.Ord e, GHC.Classes.Ord (DeepBanana.HList.HList l)) => GHC.Classes.Ord (DeepBanana.HList.HList (e : l))
instance GHC.Show.Show (DeepBanana.HList.HList '[])
instance (GHC.Show.Show e, GHC.Show.Show (DeepBanana.HList.HList l)) => GHC.Show.Show (DeepBanana.HList.HList (e : l))
instance Control.DeepSeq.NFData (DeepBanana.HList.HList '[])
instance (Control.DeepSeq.NFData e, Control.DeepSeq.NFData (DeepBanana.HList.HList l)) => Control.DeepSeq.NFData (DeepBanana.HList.HList (e : l))
instance Data.Serialize.Serialize (DeepBanana.HList.HList '[])
instance (Data.Serialize.Serialize e, Data.Serialize.Serialize (DeepBanana.HList.HList l)) => Data.Serialize.Serialize (DeepBanana.HList.HList (e : l))
instance DeepBanana.HList.Concat '[] l2
instance DeepBanana.HList.Concat l1 l2 => DeepBanana.HList.Concat (e : l1) l2
instance DeepBanana.Device.DeviceTransfer (DeepBanana.HList.HList '[]) (DeepBanana.HList.HList '[])
instance (DeepBanana.Device.DeviceTransfer (DeepBanana.HList.HList l1) (DeepBanana.HList.HList l2), DeepBanana.Device.DeviceTransfer e1 e2) => DeepBanana.Device.DeviceTransfer (DeepBanana.HList.HList (e1 : l1)) (DeepBanana.HList.HList (e2 : l2))
instance DeepBanana.HList.HMonoid DeepBanana.HList.HList


-- | Weights for neural networks as heterogenous lists.
module DeepBanana.Weights

-- | Weights for a neural network. Represents the weights as the
--   concatenated <tt><a>HList</a></tt> of the individual layer's weights.
--   The <tt>a</tt> parameter represents the weights scalar datatype, used
--   for <tt><a>FixShape</a></tt> and <tt><a>VectorSpace</a></tt>
--   instances.
newtype Weights (a :: *) l
W :: HList l -> Weights l
[unWeights] :: Weights l -> HList l

-- | Class for datatypes which are not <tt><a>Floating</a></tt> nor
--   <tt><a>VectorSpace</a></tt> instances themselves, but can be lifted to
--   fixed-shape versions which are through an error monad. Somewhat ad-hoc
--   class Used to implement stochastic gradient descent in
--   <tt><a>Optimize</a></tt> for non fixed shape datatypes in a type safe
--   manner.
class (Floating (FixScalar t)) => FixShape t where type family FixScalar t :: *
liftVec :: (FixShape t, MonadError e m, Variant e IncompatibleShape) => (forall t'. (Floating t', VectorSpace t', Scalar t' ~ FixScalar t) => t' -> t' -> t') -> t -> t -> m t
instance GHC.Classes.Eq (DeepBanana.HList.HList l) => GHC.Classes.Eq (DeepBanana.Weights.Weights a l)
instance GHC.Classes.Ord (DeepBanana.HList.HList l) => GHC.Classes.Ord (DeepBanana.Weights.Weights a l)
instance GHC.Show.Show (DeepBanana.HList.HList l) => GHC.Show.Show (DeepBanana.Weights.Weights a l)
instance Control.DeepSeq.NFData (DeepBanana.HList.HList l) => Control.DeepSeq.NFData (DeepBanana.Weights.Weights a l)
instance Data.Serialize.Serialize (DeepBanana.HList.HList l) => Data.Serialize.Serialize (DeepBanana.Weights.Weights a l)
instance Data.AdditiveGroup.AdditiveGroup (DeepBanana.Weights.Weights a '[])
instance (Data.AdditiveGroup.AdditiveGroup (DeepBanana.Weights.Weights a l), Data.AdditiveGroup.AdditiveGroup e) => Data.AdditiveGroup.AdditiveGroup (DeepBanana.Weights.Weights a (e : l))
instance Data.VectorSpace.VectorSpace (DeepBanana.Weights.Weights a '[])
instance (Data.VectorSpace.VectorSpace e, Data.VectorSpace.VectorSpace (DeepBanana.Weights.Weights a l), Data.VectorSpace.Scalar e ~ Data.VectorSpace.Scalar (DeepBanana.Weights.Weights a l)) => Data.VectorSpace.VectorSpace (DeepBanana.Weights.Weights a (e : l))
instance GHC.Num.Num (DeepBanana.Weights.Weights a '[])
instance (GHC.Num.Num e, GHC.Num.Num (DeepBanana.Weights.Weights a l)) => GHC.Num.Num (DeepBanana.Weights.Weights a (e : l))
instance GHC.Real.Fractional (DeepBanana.Weights.Weights a '[])
instance (GHC.Real.Fractional e, GHC.Real.Fractional (DeepBanana.Weights.Weights a l)) => GHC.Real.Fractional (DeepBanana.Weights.Weights a (e : l))
instance GHC.Float.Floating (DeepBanana.Weights.Weights a '[])
instance (GHC.Float.Floating e, GHC.Float.Floating (DeepBanana.Weights.Weights a l)) => GHC.Float.Floating (DeepBanana.Weights.Weights a (e : l))
instance DeepBanana.Device.DeviceTransfer (DeepBanana.HList.HList l1) (DeepBanana.HList.HList l2) => DeepBanana.Device.DeviceTransfer (DeepBanana.Weights.Weights s l1) (DeepBanana.Weights.Weights s l2)
instance DeepBanana.HList.HMonoid (DeepBanana.Weights.Weights s)
instance GHC.Float.Floating a => DeepBanana.Weights.FixShape (DeepBanana.Weights.Weights a '[])
instance (DeepBanana.Weights.FixShape e, DeepBanana.Weights.FixShape (DeepBanana.Weights.Weights a l), DeepBanana.Weights.FixScalar e ~ DeepBanana.Weights.FixScalar (DeepBanana.Weights.Weights a l)) => DeepBanana.Weights.FixShape (DeepBanana.Weights.Weights a (e : l))


-- | Compositional layers which learn a set of weights through
--   backpropagation.
module DeepBanana.Layer
newtype Layer m a (w :: [*]) inp out
Layer :: (Weights a w -> inp -> m (out, out -> (Weights a w, inp))) -> Layer m a inp out
[forwardBackward] :: Layer m a inp out -> Weights a w -> inp -> m (out, out -> (Weights a w, inp))
data InitLayer m a w inp out
initWeights :: InitLayer m a w inp out -> m (Weights a w)
layer :: InitLayer m a w inp out -> Layer m a w inp out
init :: Layer m a w inp out -> m (Weights a w) -> InitLayer m a w inp out
init' :: (Applicative m) => Layer m a '[] inp out -> InitLayer m a '[] inp out

-- | Runs the forward pass of a layer.
forward :: (Monad m) => Layer m a w inp out -> Weights a w -> inp -> m out

-- | Runs the backward pass of a layer.
backward :: (Monad m) => Layer m a w inp out -> Weights a w -> inp -> out -> m (Weights a w, inp)

-- | Creates a layer from separate forward pass and backward pass
--   computations.
combinePasses :: (Monad m) => (Weights a w -> inp -> m out) -> (Weights a w -> inp -> out -> m (out -> (Weights a w, inp))) -> Layer m a w inp out
combinePasses' :: (Monad m) => (inp -> m out) -> (inp -> out -> m (out -> inp)) -> Layer m a '[] inp out
(***) :: (Monad m, Concat w1 w2) => Layer m s w1 a b -> Layer m s w2 a' b' -> Layer m s (ConcatRes w1 w2) (a, a') (b, b')
(&&&) :: (Monad m, Concat w1 w2, AdditiveGroup a) => Layer m s w1 a b -> Layer m s w2 a b' -> Layer m s (ConcatRes w1 w2) a (b, b')
first :: (AdditiveGroup b, Monad m) => Layer m s '[] (a, b) a
second :: (AdditiveGroup a, Monad m) => Layer m s '[] (a, b) b
terminal :: (AdditiveGroup inp, Monad m) => out -> Layer m a '[] inp out
(-<) :: (Monad m, VectorSpace i1, VectorSpace i2) => Layer m a w (i1, i2) out -> i1 -> Layer m a w i2 out
noWeights :: (Monad m) => (inp -> m (out, out -> inp)) -> Layer m a '[] inp out
effect :: (Monad m) => (a -> m b) -> Layer m s '[] a a
instance (GHC.Base.Monad m, Data.AdditiveGroup.AdditiveGroup out, Data.AdditiveGroup.AdditiveGroup inp, Data.AdditiveGroup.AdditiveGroup (DeepBanana.Weights.Weights a w)) => Data.AdditiveGroup.AdditiveGroup (DeepBanana.Layer.Layer m a w inp out)
instance (GHC.Base.Monad m, Data.VectorSpace.VectorSpace out, Data.VectorSpace.VectorSpace inp, Data.VectorSpace.VectorSpace (DeepBanana.Weights.Weights a w), Data.VectorSpace.Scalar out ~ a, Data.VectorSpace.Scalar inp ~ a, Data.VectorSpace.Scalar (DeepBanana.Weights.Weights a w) ~ a) => Data.VectorSpace.VectorSpace (DeepBanana.Layer.Layer m a w inp out)
instance (Data.AdditiveGroup.AdditiveGroup (DeepBanana.Weights.Weights a w), GHC.Base.Monad m) => Control.Category.Category (DeepBanana.Layer.Layer m a w)
instance GHC.Base.Monad m => DeepBanana.HList.HCategory (DeepBanana.Layer.Layer m s)
instance GHC.Base.Monad m => DeepBanana.HList.HCategory (DeepBanana.Layer.InitLayer m s)


-- | Shape datatypes for tensors.
module DeepBanana.Tensor.Shape

-- | <tt><a>Dim</a> n</tt>, where <tt>n</tt> is a type level natural, is a
--   dynamic <tt>n</tt>-dimensional shape. It is represented by an
--   <tt><a>HList</a></tt> of fixed size <tt>n</tt> where all elements are
--   integers.
type Dim (n :: Nat) = SizedList n Int

-- | <tt><a>Fixed</a> l</tt>, where <tt>l</tt> is a type level list of type
--   level natural numbers, represents a shape which is fully fixed at the
--   type level. It is represented by an <tt><a>HList</a></tt> where all
--   elements are <tt><a>Proxy</a> n</tt> for some type level natural
--   <tt>n</tt>.
type Fixed (l :: [Nat]) = HList (Fixed' l)

-- | Type class that all shape datatypes implement.
class (Eq s, Ord s, Show s, Serialize s, NFData s) => Shape s where nbdim = length . dimensions size s = case dimensions s of { [] -> 0 [i] -> i xs -> product xs }

-- | Dimensions of the shape as a list of ints.
dimensions :: Shape s => s -> [Int]

-- | Smallest shape of the datatype, meaning it can be broadcasted against
--   any other shape of the datatype.
scalarShape :: Shape s => s

-- | Number of dimensions.
nbdim :: Shape s => s -> Int

-- | Size, i.e. the product of the dimensions.
size :: Shape s => s -> Int

-- | Returns true if and only if the first shape argument can be
--   broadcasted to to the second shape argument. Currently, broadcasting
--   is limited to shapes holding the same number of dimensions. Then, a
--   dimension <tt>d1</tt> is broadcastable to a dimension <tt>d2</tt> if
--   an only if <tt>d1 == d2</tt> or <tt>d1 == 1</tt>.
broadcastable :: (Shape s1, Shape s2) => s1 -> s2 -> Bool

-- | Utility type class for shapes which are fully defined at the type
--   level.
class FixedShape (l :: [Nat]) where type family Fixed' l :: [*] type family Nbdim l :: Nat type family Size l :: Nat

-- | Utility function to define shapes fixed at the type level.
fixed :: FixedShape l => Proxy l -> HList (Fixed' l)

-- | Utility type class for shapes which are fully fixed at the type level.
class (Shape s) => IsFixed s

-- | Existential datatype wrapping any fixed shape. Useful when converting
--   from a fixed type level shape to a dynamic shape locally.
data AnyFixed
AnyFixed :: HList l -> AnyFixed

-- | Converts an arbitrary shape to its fixed version.
toAnyFixed :: (Shape s) => s -> AnyFixed
instance DeepBanana.Tensor.Shape.Shape (DeepBanana.HList.HList '[])
instance DeepBanana.Tensor.Shape.Shape (DeepBanana.HList.HList l) => DeepBanana.Tensor.Shape.Shape (DeepBanana.HList.HList (GHC.Types.Int : l))
instance (DeepBanana.Tensor.Shape.Shape (DeepBanana.HList.HList l), GHC.TypeLits.KnownNat n, Control.DeepSeq.NFData (Data.Proxy.Proxy n)) => DeepBanana.Tensor.Shape.Shape (DeepBanana.HList.HList (Data.Proxy.Proxy n : l))
instance DeepBanana.Tensor.Shape.Shape (DeepBanana.HList.HList l) => DeepBanana.Tensor.Shape.Shape (DeepBanana.HList.HList (GHC.TypeLits.SomeNat : l))
instance DeepBanana.Tensor.Shape.FixedShape '[]
instance GHC.TypeLits.KnownNat n => DeepBanana.Tensor.Shape.FixedShape '[n]
instance (DeepBanana.Tensor.Shape.FixedShape (n2 : l), GHC.TypeLits.KnownNat n1, GHC.TypeLits.KnownNat n2) => DeepBanana.Tensor.Shape.FixedShape (n1 : n2 : l)
instance DeepBanana.Tensor.Shape.IsFixed (DeepBanana.HList.HList '[])
instance (DeepBanana.Tensor.Shape.IsFixed (DeepBanana.HList.HList l), GHC.TypeLits.KnownNat n, Control.DeepSeq.NFData (Data.Proxy.Proxy n)) => DeepBanana.Tensor.Shape.IsFixed (DeepBanana.HList.HList (Data.Proxy.Proxy n : l))
instance DeepBanana.Tensor.Shape.IsFixed (DeepBanana.HList.HList l) => DeepBanana.Tensor.Shape.IsFixed (DeepBanana.HList.HList (GHC.TypeLits.SomeNat : l))
instance forall (k :: BOX) (t :: k). Data.Serialize.Serialize (Data.Proxy.Proxy t)
instance Control.DeepSeq.NFData GHC.TypeLits.SomeNat
instance forall (k :: BOX) (t :: k). Control.DeepSeq.NFData (Data.Proxy.Proxy t)
instance Data.Serialize.Serialize GHC.TypeLits.SomeNat


-- | Mutable GPU multi-dimensional dense numeric arrays, parametrized by
--   the state token of some primitive state monad.
module DeepBanana.Tensor.Mutable

-- | Mutable tensor, parametrized by some state token <tt>st</tt>.
data MTensor st d s a
MTensor :: s -> ForeignPtr a -> MTensor st d s a
[shape] :: MTensor st d s a -> s
[dataptr] :: MTensor st d s a -> ForeignPtr a

-- | Convenient synonym for mutable tensors in the <a>IO</a> monad.
type IOTensor = MTensor RealWorld

-- | Returns the CuDNN datatype identifier for the tensor.
dtype :: (PrimMonad m, TensorScalar a) => MTensor (PrimState m) d n a -> m DataType

-- | Creates an uninitialized mutable tensor with a given shape.
--   Uninitialized means the contents of the tensor are defined by whatever
--   was lying around in memory at the time.
emptyTensor :: (Shape s, Device d, TensorScalar a, PrimMonad m, MonadError t m, Variant t OutOfMemory) => s -> m (MTensor (PrimState m) d s a)

-- | Creates a mutable tensor from a list. Throws an exception at runtime
--   when the size of the list does not correspond to the desired shape.
tensorFromList :: (PrimMonad m, Device d, Shape s, TensorScalar a, MonadError t m, Variant t OutOfMemory, Variant t IncompatibleSize) => s -> [a] -> m (MTensor (PrimState m) d s a)

-- | Creates a mutable tensor filled with zeros.
zeros :: (PrimMonad m, Device d, Shape s, TensorScalar a, MonadError t m, Variant t OutOfMemory) => s -> m (MTensor (PrimState m) d s a)

-- | Creates a mutable tensor filled with ones.
ones :: (PrimMonad m, Device d, Shape s, TensorScalar a, MonadError t m, Variant t OutOfMemory) => s -> m (MTensor (PrimState m) d s a)

-- | Runs an <a>IO</a> action with the internal device pointer of a given
--   mutable tensor.
withDevicePtr :: (Storable a) => IOTensor d s a -> (DevicePtr a -> IO b) -> IO b

-- | Tensor reshaping.
reshape :: (Shape s1, Shape s2, MonadError t m, Variant t IncompatibleSize) => s2 -> MTensor st d s1 a -> m (MTensor st d s2 a)
reshape' :: (Shape s1, Shape s2) => s2 -> MTensor st d s1 a -> MTensor st d s2 a

-- | Copies the data of a mutable tensor into a new one.
copy :: (PrimMonad m, Device d2, Shape s, TensorScalar a, MonadError t m, Variant t OutOfMemory) => MTensor (PrimState m) d1 s a -> m (MTensor (PrimState m) d2 s a)

-- | Converts a mutable tensor to a list of elements.
tensorToList :: (PrimMonad m, Device d, Shape s, TensorScalar a) => MTensor (PrimState m) d s a -> m [a]

-- | Thresholds a mutable tensor in place. Used to implement dropout.
threshInplace :: (PrimMonad m, Device d, Shape s, TensorScalar a) => MTensor (PrimState m) d s a -> a -> m ()

-- | In place logarithm.
tlog :: (PrimMonad m, Device d, Shape s, TensorScalar a) => MTensor (PrimState m) d s a -> m ()

-- | In place exponential.
texp :: (PrimMonad m, Device d, Shape s, TensorScalar a) => MTensor (PrimState m) d s a -> m ()

-- | In place inverse.
inv :: (PrimMonad m, Device d, Shape s, TensorScalar a) => MTensor (PrimState m) d s a -> m ()


-- | GPU multi-dimensional dense numeric arrays.
module DeepBanana.Tensor
data Tensor d s a
Tensor :: s -> !(ForeignPtr a) -> Tensor d s a
[shape] :: Tensor d s a -> s
[dataptr] :: Tensor d s a -> !(ForeignPtr a)

-- | Returns the CuDNN datatype of a tensor.
dtype :: (TensorScalar a) => Tensor d s a -> DataType

-- | Reshaping.
reshape :: (Shape s1, Shape s2, TensorScalar a, MonadError t m, Variant t IncompatibleSize) => s2 -> Tensor d s1 a -> m (Tensor d s2 a)
reshape' :: (Shape s1, Shape s2, TensorScalar a) => s2 -> Tensor d s1 a -> Tensor d s2 a
shapeConvert :: (MonadError t m, Shape s1, Shape s2, Variant t IncompatibleShape) => s2 -> Tensor d s1 a -> m (Tensor d s2 a)
liftFixed1 :: (Shape s1) => (forall s2. (IsFixed s2) => Tensor d s2 a -> Tensor d s2 a) -> Tensor d s1 a -> Tensor d s1 a
liftFixed2 :: (Shape s1, MonadError t m, Variant t IncompatibleShape) => (forall s2. (IsFixed s2) => Tensor d s2 a -> Tensor d s2 a -> Tensor d s2 a) -> Tensor d s1 a -> Tensor d s1 a -> m (Tensor d s1 a)
transfer :: (DeviceTransfer t1 t2, MonadError t m, Variant t OutOfMemory) => t1 -> m t2
transfer' :: (DeviceTransfer t1 t2) => t1 -> t2

-- | Type-safe broadcasting.
broadcast :: (Device d, Shape s1, Shape s2, TensorScalar a, MonadError t m, Variant t IncompatibleShape, Variant t OutOfMemory) => s2 -> Tensor d s1 a -> m (Tensor d s2 a)
broadcast' :: (Device d, Shape s1, Shape s2, TensorScalar a) => s2 -> Tensor d s1 a -> Tensor d s2 a

-- | Initializes a tensor with all zeros.
zeros :: (Device d, Shape s, TensorScalar a, MonadError t m, Variant t OutOfMemory) => s -> m (Tensor d s a)
zeros' :: (Device d, Shape s, TensorScalar a) => s -> Tensor d s a

-- | Initializes a tensor with all ones.
ones :: (Device d, Shape s, TensorScalar a, MonadError t m, Variant t OutOfMemory) => s -> m (Tensor d s a)
ones' :: (Device d, Shape s, TensorScalar a) => s -> Tensor d s a

-- | Converts a mutable tensor into an immutable one in O(1) time. The data
--   is not copied, so one should make sure the input mutable tensor is not
--   modified after the the conversion. Unsafe.
unsafeFreeze :: (PrimMonad m) => MTensor (PrimState m) d s a -> m (Tensor d s a)

-- | Converts an immutable tensor into a mutable one in O(1) time. The data
--   is not copied, so one should make sure the input immutable tensor is
--   not used after the conversion. Unsafe.
unsafeThaw :: (PrimMonad m) => Tensor d s a -> m (MTensor (PrimState m) d s a)

-- | Initializes a tensor from list data. If the length of the list does
--   not correspond to the size of the desired shape, throws an exception
--   at run time.
tensorFromList :: (Device d, Shape s, TensorScalar a, MonadError t m, Variant t IncompatibleSize, Variant t OutOfMemory) => s -> [a] -> m (Tensor d s a)
tensorFromList' :: (Device d, Shape s, TensorScalar a) => s -> [a] -> Tensor d s a

-- | Converts a tensor to a list.
tensorToList :: (Shape s, Device d, TensorScalar a) => Tensor d s a -> [a]

-- | Converts a storable vector to an immutable tensor. Throws an error at
--   runtime when the input's length does not correspond to the desired
--   output size. Runs in O(n) time.
fromVector :: (Device d, Shape s, TensorScalar a, MonadError t m, Variant t OutOfMemory, Variant t IncompatibleSize) => s -> SVector a -> m (Tensor d s a)
fromVector' :: (Device d, Shape s, TensorScalar a) => s -> SVector a -> Tensor d s a

-- | Converts a tensor to a storable vector. Runs in O(n) time.
toVector :: (Device d, Shape s, TensorScalar a) => Tensor d s a -> SVector a

-- | Concatenates two 1-dimensional tensors. Inverse of tsplit. Runs in
--   O(n+m) time.
tconcat :: (Device d, TensorScalar a, MonadError t m, Variant t OutOfMemory) => Tensor d (Dim 1) a -> Tensor d (Dim 1) a -> m (Tensor d (Dim 1) a)
tconcat' :: (Device d, TensorScalar a) => Tensor d (Dim 1) a -> Tensor d (Dim 1) a -> Tensor d (Dim 1) a

-- | Splits a 1-dimensional tensor into 2 parts. Inverse of tconcat. Runs
--   in O(n+m) time.
tsplitAt :: (Device d, TensorScalar a, MonadError t m, Variant t OutOfMemory, Variant t IncompatibleSize) => Int -> Tensor d (Dim 1) a -> m (Tensor d (Dim 1) a, Tensor d (Dim 1) a)
tsplitAt' :: (Device d, TensorScalar a) => Int -> Tensor d (Dim 1) a -> (Tensor d (Dim 1) a, Tensor d (Dim 1) a)

-- | Computes the elementwise maximum of 2 tensors.
elementwiseMax :: (Device d, IsFixed s, TensorScalar a, MonadError t m, Variant t OutOfMemory, Variant t IncompatibleShape) => Tensor d s a -> Tensor d s a -> m (Tensor d s a)

-- | Flattens a tensor into a 1-dimensional vector.
flatten :: (Shape s, TensorScalar a) => Tensor d s a -> Tensor d (Dim 1) a
instance forall (k :: BOX) (d :: k) s a. (DeepBanana.Tensor.Shape.Shape s, DeepBanana.Device.Monad.Device d, DeepBanana.Tensor.TensorScalar.TensorScalar a, GHC.Classes.Eq a) => GHC.Classes.Eq (DeepBanana.Tensor.Tensor d s a)
instance forall (k :: BOX) (d :: k) s a. (DeepBanana.Device.Monad.Device d, DeepBanana.Tensor.Shape.Shape s, DeepBanana.Tensor.TensorScalar.TensorScalar a) => Data.Serialize.Serialize (DeepBanana.Tensor.Tensor d s a)
instance forall (k :: BOX) (d :: k) s a. Control.DeepSeq.NFData s => Control.DeepSeq.NFData (DeepBanana.Tensor.Tensor d s a)
instance forall (k :: BOX) (d :: k) s a. (DeepBanana.Device.Monad.Device d, DeepBanana.Tensor.Shape.Shape s, DeepBanana.Tensor.TensorScalar.TensorScalar a, GHC.Show.Show a) => GHC.Show.Show (DeepBanana.Tensor.Tensor d s a)
instance forall (k :: BOX) (d :: k) s a. (DeepBanana.Device.Monad.Device d, DeepBanana.Tensor.Shape.Shape s, DeepBanana.Tensor.TensorScalar.TensorScalar a) => DeepBanana.Weights.FixShape (DeepBanana.Tensor.Tensor d s a)
instance forall (k :: BOX) (k1 :: BOX) (d1 :: k) s a (d2 :: k1). (DeepBanana.Device.Monad.Device d1, DeepBanana.Device.Monad.Device d2, DeepBanana.Tensor.TensorScalar.TensorScalar a, DeepBanana.Tensor.Shape.Shape s) => DeepBanana.Device.DeviceTransfer (DeepBanana.Tensor.Tensor d1 s a) (DeepBanana.Tensor.Tensor d2 s a)
instance forall (k :: BOX) (d :: k) s a. (DeepBanana.Device.Monad.Device d, DeepBanana.Tensor.Shape.IsFixed s, DeepBanana.Tensor.TensorScalar.TensorScalar a) => GHC.Num.Num (DeepBanana.Tensor.Tensor d s a)
instance forall (k :: BOX) (d :: k) s a. (DeepBanana.Device.Monad.Device d, DeepBanana.Tensor.Shape.IsFixed s, DeepBanana.Tensor.TensorScalar.TensorScalar a) => GHC.Real.Fractional (DeepBanana.Tensor.Tensor d s a)
instance forall (k :: BOX) (d :: k) s a. (DeepBanana.Device.Monad.Device d, DeepBanana.Tensor.Shape.IsFixed s, DeepBanana.Tensor.TensorScalar.TensorScalar a) => GHC.Float.Floating (DeepBanana.Tensor.Tensor d s a)
instance forall (k :: BOX) (d :: k) s a. (DeepBanana.Device.Monad.Device d, DeepBanana.Tensor.Shape.IsFixed s, DeepBanana.Tensor.TensorScalar.TensorScalar a) => Data.AdditiveGroup.AdditiveGroup (DeepBanana.Tensor.Tensor d s a)
instance forall (k :: BOX) (d :: k) s a. (DeepBanana.Device.Monad.Device d, DeepBanana.Tensor.Shape.IsFixed s, DeepBanana.Tensor.TensorScalar.TensorScalar a) => Data.VectorSpace.VectorSpace (DeepBanana.Tensor.Tensor d s a)
instance forall (k :: BOX) (d :: k) s a. (DeepBanana.Device.Monad.Device d, DeepBanana.Tensor.Shape.IsFixed s, DeepBanana.Tensor.TensorScalar.TensorScalar a) => Data.VectorSpace.InnerSpace (DeepBanana.Tensor.Tensor d s a)

module DeepBanana.Data
lazy_image_loader :: (Image i, Convertible StorageImage i, Storable (ImagePixel i), MonadIO m) => Proxy i -> FilePath -> Pipe (FilePath, l) (Manifest (ImagePixel i), l) m ()
randomize :: (MonadRandom m) => [a] -> Producer a m ()
randomLabelSubset :: (MonadRandom m) => Int -> Pipe (a, [l]) (a, [l]) m ()
randomize_seq_length :: (MonadRandom m) => Int -> Int -> Pipe (a, [b]) (a, [b]) m ()
map_pixels :: (FunctorImage src dst, Monad m) => (ImagePixel src -> ImagePixel dst) -> Pipe src dst m ()
batch_images :: (Image i, Storable (PixelChannel (ImagePixel i)), Pixel (ImagePixel i), Monad m, TensorScalar a, MonadError t m, Variant t EmptyBatch) => Int -> Int -> Pipe (i, [Int]) (SVector (PixelChannel (ImagePixel i)), SVector a) m ()
batch_images_pad_labels :: (Image i, Storable (PixelChannel (ImagePixel i)), Pixel (ImagePixel i), Monad m, TensorScalar a, MonadError t m, Variant t EmptyBatch) => Int -> Int -> Int -> Pipe (i, [Int]) (SVector (PixelChannel (ImagePixel i)), [SVector a]) m ()
batch_to_gpu :: (MonadIO m, MonadError t m, Variant t OutOfMemory, Variant t IncompatibleSize, TensorScalar a, Shape s1, Shape s2, Device d) => Proxy d -> s1 -> s2 -> Pipe (SVector a, SVector a) (Tensor d s1 a, Tensor d s2 a) m ()
batch_to_gpu2 :: (MonadIO m, MonadError t m, Variant t OutOfMemory, Variant t IncompatibleSize, TensorScalar a, Shape s1, Shape s2, Device d1, Device d2) => Proxy d1 -> Proxy d2 -> s1 -> s2 -> Pipe (SVector a, SVector a) ((Tensor d1 s1 a, Tensor d1 s2 a), (Tensor d2 s1 a, Tensor d2 s2 a)) m ()
batch_to_gpu3 :: (MonadIO m, MonadError t m, Variant t OutOfMemory, Variant t IncompatibleSize, TensorScalar a, Shape s1, Shape s2, Device d1, Device d2, Device d3) => Proxy d1 -> Proxy d2 -> Proxy d3 -> s1 -> s2 -> Pipe (SVector a, SVector a) ((Tensor d1 s1 a, Tensor d1 s2 a), (Tensor d2 s1 a, Tensor d2 s2 a), (Tensor d3 s1 a, Tensor d3 s2 a)) m ()
batch_to_gpu4 :: (MonadIO m, MonadError t m, Variant t OutOfMemory, Variant t IncompatibleSize, TensorScalar a, Shape s1, Shape s2, Device d1, Device d2, Device d3, Device d4) => Proxy d1 -> Proxy d2 -> Proxy d3 -> Proxy d4 -> s1 -> s2 -> Pipe (SVector a, SVector a) ((Tensor d1 s1 a, Tensor d1 s2 a), (Tensor d2 s1 a, Tensor d2 s2 a), (Tensor d3 s1 a, Tensor d3 s2 a), (Tensor d4 s1 a, Tensor d4 s2 a)) m ()
batch_labels_to_gpu :: (MonadIO m, MonadError t m, Variant t OutOfMemory, Variant t IncompatibleSize, TensorScalar a, Shape s1, Shape s2, Device d1, Device d2) => s1 -> s2 -> Pipe (SVector a, [SVector a]) (Tensor d1 s1 a, [Tensor d2 s2 a]) m ()
runEvery :: (Monad m) => Int -> (a -> m ()) -> Pipe a a m c
serializeTo :: (MonadIO m, Serialize a) => FilePath -> a -> m ()
random_crop :: (Image i, Storable (ImagePixel i), MonadRandom m) => Proxy i -> Int -> Int -> Pipe (Manifest (ImagePixel i), l) (Manifest (ImagePixel i), l) m ()
resize_min_dim :: (Image i, Storable (ImagePixel i), MonadRandom m, Integral (ImageChannel i), Interpolable (ImagePixel i)) => Proxy i -> Int -> Pipe (Manifest (ImagePixel i), l) (Manifest (ImagePixel i), l) m ()
accuracy :: (Eq a, Floating b, Monad m) => Producer ([a], [a]) m () -> m b
precision :: (Eq a, Floating b, Monad m) => Producer ([a], [a]) m () -> m b
recall :: (Eq a, Floating b, Monad m) => Producer ([a], [a]) m () -> m b
topAccuracy :: (Eq a, Floating b, Monad m) => Producer ([a], a) m () -> m b
instance Foreign.Storable.Storable i => Data.Serialize.Serialize (Vision.Image.Type.Manifest i)

module DeepBanana.Optimize
sgd :: (Monad m, MonadTrans t, Monad (t (Pipe a (FixScalar w, w) m)), FixShape w) => Update t (Pipe a (FixScalar w, w) m) w -> (w -> a -> m (FixScalar w, w)) -> w -> Pipe a (FixScalar w, w) m ()
data Update t m w
Update :: (FixScalar w -> w -> w -> t m w) -> (forall a. t m a -> m a) -> Update t m w
[update] :: Update t m w -> FixScalar w -> w -> w -> t m w
[run] :: Update t m w -> forall a. t m a -> m a
vanilla :: (FixShape w, MonadError e m, Variant e IncompatibleShape) => FixScalar w -> Update IdentityT m w
momentum :: (FixShape w, MonadError e m, Variant e IncompatibleShape) => FixScalar w -> FixScalar w -> Update (StateT (Maybe w)) m w
rmsprop :: (MonadError e m, Variant e OutOfMemory, Variant e IncompatibleShape, HasElemwiseMax m w, FixShape w) => FixScalar w -> FixScalar w -> FixScalar w -> Update (StateT (Maybe w)) m w
instance forall (k :: BOX) (m :: * -> *) (d :: k) s a t. (Control.Monad.Error.Class.MonadError t m, DeepBanana.Exception.Variant t DeepBanana.Tensor.Exception.OutOfMemory, DeepBanana.Exception.Variant t DeepBanana.Tensor.Exception.IncompatibleShape, DeepBanana.Tensor.Shape.Shape s, DeepBanana.Device.Monad.Device d, DeepBanana.Tensor.TensorScalar.TensorScalar a) => DeepBanana.Optimize.HasElemwiseMax m (DeepBanana.Tensor.Tensor d s a)
instance (Control.Monad.Error.Class.MonadError t m, DeepBanana.Exception.Variant t DeepBanana.Tensor.Exception.IncompatibleShape, GHC.Float.Floating s) => DeepBanana.Optimize.HasElemwiseMax m (DeepBanana.Weights.Weights s '[])
instance (DeepBanana.Optimize.HasElemwiseMax m (DeepBanana.Weights.Weights s l), DeepBanana.Optimize.HasElemwiseMax m e, DeepBanana.Weights.FixScalar e ~ s, DeepBanana.Weights.FixScalar (DeepBanana.Weights.Weights s l) ~ s) => DeepBanana.Optimize.HasElemwiseMax m (DeepBanana.Weights.Weights s (e : l))

module DeepBanana.Layer.CUDA.Numeric
llog :: (Device d, MonadCudaError m, Shape s, TensorScalar a) => Layer m a '[] (Tensor d s a) (Tensor d s a)
inv :: (Device d, MonadCudaError m, Shape s, TensorScalar a) => Layer m a '[] (Tensor d s a) (Tensor d s a)
lexp :: (Device d, MonadCudaError m, Shape s, TensorScalar a) => Layer m a '[] (Tensor d s a) (Tensor d s a)
scale :: (Device d, MonadCudaError m, Shape s, TensorScalar a) => Layer m a '[] (a, Tensor d s a) (Tensor d s a)
scaleByCst :: (Device d, MonadCudaError m, Shape s, TensorScalar a) => a -> Layer m a '[] (Tensor d s a) (Tensor d s a)
scaleByCst_ :: (Monad m, VectorSpace t) => Scalar t -> Layer m (Scalar t) '[] t t
multiply :: (Device d, MonadCudaError m, Shape s, TensorScalar a) => Layer m a '[] (Tensor d s a, Tensor d s a) (Tensor d s a)
add :: (Device d, MonadCudaError m, Shape s, TensorScalar a) => Layer m a '[] (Tensor d s a, Tensor d s a) (Tensor d s a)
add_ :: (Monad m, VectorSpace t) => Layer m (Scalar t) '[] (t, t) t

module DeepBanana.Layer.CUDA.CuDNN
convolution2d :: (Device d, MonadCuda m, TensorScalar a) => (Int, Int) -> (Int, Int) -> ConvolutionFwdAlgo -> ConvolutionBwdDataAlgo -> ConvolutionBwdFilterAlgo -> Layer m a '[Tensor d (Dim 4) a] (Tensor d (Dim 4) a) (Tensor d (Dim 4) a)
data ConvolutionFwdAlgo
convolution_fwd_algo_implicit_gemm :: ConvolutionFwdAlgo
convolution_fwd_algo_implicit_precomp_gemm :: ConvolutionFwdAlgo
convolution_fwd_algo_gemm :: ConvolutionFwdAlgo
convolution_fwd_algo_direct :: ConvolutionFwdAlgo
convolution_fwd_algo_fft :: ConvolutionFwdAlgo
convolution_fwd_algo_fft_tiling :: ConvolutionFwdAlgo
data ConvolutionBwdDataAlgo
convolution_bwd_data_algo_0 :: ConvolutionBwdDataAlgo
convolution_bwd_data_algo_1 :: ConvolutionBwdDataAlgo
convolution_bwd_data_algo_fft :: ConvolutionBwdDataAlgo
convolution_bwd_data_algo_fft_tiling :: ConvolutionBwdDataAlgo
data ConvolutionBwdFilterAlgo
convolution_bwd_filter_algo_0 :: ConvolutionBwdFilterAlgo
convolution_bwd_filter_algo_1 :: ConvolutionBwdFilterAlgo
convolution_bwd_filter_algo_fft :: ConvolutionBwdFilterAlgo
convolution_bwd_filter_algo_3 :: ConvolutionBwdFilterAlgo
bias :: (Device d, MonadCuda m, TensorScalar a) => Layer m a '[Tensor d (Dim 1) a] (Tensor d (Dim 4) a) (Tensor d (Dim 4) a)
activation :: (Device d, MonadCuda m, TensorScalar a, Shape s) => ActivationMode -> Layer m a '[] (Tensor d s a) (Tensor d s a)
data ActivationMode
activation_sigmoid :: ActivationMode
activation_relu :: ActivationMode
activation_tanh :: ActivationMode
pooling2d :: (Device d, MonadCuda m, TensorScalar a) => (Int, Int) -> (Int, Int) -> (Int, Int) -> PoolingMode -> Layer m a '[] (Tensor d (Dim 4) a) (Tensor d (Dim 4) a)
data PoolingMode
pooling_max :: PoolingMode
pooling_average_count_include_padding :: PoolingMode
pooling_average_count_exclude_padding :: PoolingMode
softmax :: (Device d, MonadCuda m, TensorScalar a) => SoftmaxAlgorithm -> SoftmaxMode -> Layer m a '[] (Tensor d (Dim 2) a) (Tensor d (Dim 2) a)
data SoftmaxAlgorithm
softmax_fast :: SoftmaxAlgorithm
softmax_accurate :: SoftmaxAlgorithm
data SoftmaxMode
softmax_mode_instance :: SoftmaxMode
softmax_mode_channel :: SoftmaxMode
nhwc_to_nchw :: (Device d, MonadCuda m, TensorScalar a) => Layer m a '[] (Tensor d (Dim 4) a) (Tensor d (Dim 4) a)
nchw_to_nhwc :: (Device d, MonadCuda m, TensorScalar a) => Layer m a '[] (Tensor d (Dim 4) a) (Tensor d (Dim 4) a)
batchNormalization :: (Device d, MonadCudaError m, TensorScalar a) => BatchNormMode -> Double -> Layer m a '[Tensor d (Dim 4) a, Tensor d (Dim 4) a] (Tensor d (Dim 4) a) (Tensor d (Dim 4) a)
data BatchNormMode
batchnorm_per_activation :: BatchNormMode
batchnorm_spatial :: BatchNormMode

module DeepBanana.Layer.CUDA.CuRAND
splitGenerator :: (MonadCuda m, Device d) => Proxy d -> m Generator
uniform :: (MonadCuda m, Device d, TensorScalar a, Shape s) => s -> m (Tensor d s a)
normal :: (MonadCuda m, Device d, TensorScalar a, Shape s) => s -> a -> a -> m (Tensor d s a)
logNormal :: (MonadCuda m, Device d, TensorScalar a, Shape s) => s -> a -> a -> m (Tensor d s a)
dropout :: (MonadCuda m, Device d, TensorScalar a, Shape s) => a -> Layer m a '[] (Tensor d s a) (Tensor d s a)

module DeepBanana.Layer.CUDA
dot :: (MonadCuda m, Device d, TensorScalar a) => Layer m a '[] (Tensor d (Dim 2) a, Tensor d (Dim 2) a) (Tensor d (Dim 2) a)
linear :: (MonadCuda m, Device d, TensorScalar a) => Layer m a '[Tensor d (Dim 2) a] (Tensor d (Dim 2) a) (Tensor d (Dim 2) a)
sumRows :: (MonadCuda m, Device d, TensorScalar a) => Layer m a '[] (Tensor d (Dim 2) a) (Tensor d (Dim 1) a)
replicateAsCols :: (MonadCuda m, Device d, TensorScalar a) => Int -> Layer m a '[] (Tensor d (Dim 1) a) (Tensor d (Dim 2) a)
lreshape :: (MonadCuda m, TensorScalar a, Shape s1, Shape s2) => s2 -> Layer m a '[] (Tensor d s1 a) (Tensor d s2 a)
toScalar :: (MonadCuda m, TensorScalar a, Device d, Shape s) => Layer m a '[] (Tensor d s a) a
mlrCost :: (MonadCuda m, Device d, TensorScalar a) => Dim 2 -> Layer m a '[] (Tensor d (Dim 2) a, Tensor d (Dim 2) a) (Tensor d (Dim 1) a)

module DeepBanana.Layer.Parallel
layerPar :: (MonadCuda m, Concat w1 w2, Device d, NFData b1, NFData (Weights s w1, a1), NFData b2, NFData (Weights s w2, a2)) => Proxy d -> Layer Cuda s w1 a1 b1 -> Layer Cuda s w2 a2 b2 -> Layer m s (ConcatRes w1 w2) (a1, a2) (b1, b2)
dataPar :: (MonadCuda m, Concat w1 w2, NFData b1, NFData (Weights s w1, a1), NFData b2, NFData (Weights s w2, a2), DeviceTransfer (Weights s w1) (Weights s w2), DeviceTransfer (Weights s w2) (Weights s w1), Device d, FixShape (Weights s w1), Floating (FixScalar (Weights s w1))) => Proxy d -> Layer Cuda s w1 a1 b1 -> Layer Cuda s w2 a2 b2 -> Layer m s w1 (a1, a2) (b1, b2)

module DeepBanana
