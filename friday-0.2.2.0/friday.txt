-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A functional image processing library for Haskell.
--   
--   Friday provides functions to manipulate images in a functional way.
--   The library is designed to be fast, generic and type-safe.
--   
--   Images can be represented in two representations:
--   
--   <ul>
--   <li>the <a>Manifest</a> representation stores images in Haskell
--   <a>Vector</a>s ;</li>
--   <li>the <a>Delayed</a> representation uses functions to produce images
--   pixels. These images can be combined to produce complex
--   transformations. By some inlining, Haskell compilers are able to
--   produce fast algorithms by removing intermediate structures.</li>
--   </ul>
--   
--   The library currently support four color spaces: RGB, RGBA, HSV and
--   gray-scale images.
--   
--   Please read our <a>README</a> to get a detailed usage and some
--   examples.
@package friday
@version 0.2.2.0


-- | <a>Shape</a>s are similar to what you could found in <tt>repa</tt>.
--   <a>Shape</a> are used both for indexes and shapes.
--   
--   To create a shape/index, use the <a>ix1</a>, <a>ix2</a>, <a>ix3</a>
--   ... helpers :
--   
--   <pre>
--   size = ix2 200 100
--   </pre>
--   
--   To pull values from a shape, use the <a>Z</a> and <a>:.</a>
--   constructors :
--   
--   <pre>
--   Z :. h :. w = size
--   </pre>
module Vision.Primitive.Shape

-- | Class of types that can be used as array shapes and indices.
class Eq sh => Shape sh

-- | Gets the number of dimensions in a shape.
shapeRank :: Shape sh => sh -> Int

-- | Gets the total number of elements in an array of this shape.
shapeLength :: Shape sh => sh -> Int

-- | Gives the first index of an array.
shapeZero :: Shape sh => sh

-- | Gives the successor of an index, given the shape of the array.
shapeSucc :: Shape sh => sh -> sh -> sh

-- | Convert an index into its equivalent flat, linear, row-major version.
toLinearIndex :: Shape sh => sh -> sh -> Int

-- | Inverse of <a>toLinearIndex</a>.
fromLinearIndex :: Shape sh => sh -> Int -> sh

-- | Return the ascending list of indexes for the given shape.
shapeList :: Shape sh => sh -> [sh]

-- | Check whether an index is within a given shape.
inShape :: Shape sh => sh -> sh -> Bool

-- | An index of dimension zero.
data Z
Z :: Z

-- | Our index type, used for both shapes and indices.
data (:.) tail head
(:.) :: !tail -> !head -> (:.) tail head
type DIM0 = Z
type DIM1 = DIM0 :. Int
type DIM2 = DIM1 :. Int
type DIM3 = DIM2 :. Int
type DIM4 = DIM3 :. Int
type DIM5 = DIM4 :. Int
type DIM6 = DIM5 :. Int
type DIM7 = DIM6 :. Int
type DIM8 = DIM7 :. Int
type DIM9 = DIM8 :. Int

-- | Helper for index construction.
--   
--   Use this instead of explicit constructors like <tt>(Z :. (x ::
--   Int))</tt> The this is sometimes needed to ensure that <tt>x</tt> is
--   constrained to be in <tt>Int</tt>.
ix1 :: Int -> DIM1
ix2 :: Int -> Int -> DIM2
ix3 :: Int -> Int -> Int -> DIM3
ix4 :: Int -> Int -> Int -> Int -> DIM4
ix5 :: Int -> Int -> Int -> Int -> Int -> DIM5
ix6 :: Int -> Int -> Int -> Int -> Int -> Int -> DIM6
ix7 :: Int -> Int -> Int -> Int -> Int -> Int -> Int -> DIM7
ix8 :: Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> DIM8
ix9 :: Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> DIM9
instance (GHC.Classes.Ord tail, GHC.Classes.Ord head) => GHC.Classes.Ord (tail Vision.Primitive.Shape.:. head)
instance (GHC.Classes.Eq tail, GHC.Classes.Eq head) => GHC.Classes.Eq (tail Vision.Primitive.Shape.:. head)
instance (GHC.Read.Read tail, GHC.Read.Read head) => GHC.Read.Read (tail Vision.Primitive.Shape.:. head)
instance (GHC.Show.Show tail, GHC.Show.Show head) => GHC.Show.Show (tail Vision.Primitive.Shape.:. head)
instance GHC.Classes.Ord Vision.Primitive.Shape.Z
instance GHC.Classes.Eq Vision.Primitive.Shape.Z
instance GHC.Read.Read Vision.Primitive.Shape.Z
instance GHC.Show.Show Vision.Primitive.Shape.Z
instance Vision.Primitive.Shape.Shape Vision.Primitive.Shape.Z
instance Foreign.Storable.Storable Vision.Primitive.Shape.Z
instance Vision.Primitive.Shape.Shape sh => Vision.Primitive.Shape.Shape (sh Vision.Primitive.Shape.:. GHC.Types.Int)
instance Foreign.Storable.Storable sh => Foreign.Storable.Storable (sh Vision.Primitive.Shape.:. GHC.Types.Int)

module Vision.Primitive

-- | Coordinates inside the image.
--   
--   Can be constructed using <a>ix2</a>. The first parameter is the y
--   coordinate while the second is the x coordinate (i.e. <tt><a>ix2</a> y
--   x</tt>). Image origin (<tt><a>ix2</a> 0 0</tt>) is located in the
--   upper left corner.
type Point = DIM2

-- | Size of an object.
--   
--   Can be constructed using <a>ix2</a>. The first parameter is the height
--   while the second is the width (i.e. <tt>ix2 h w</tt>).
type Size = DIM2
data Rect
Rect :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> Rect
[rX] :: Rect -> {-# UNPACK #-} !Int
[rY] :: Rect -> {-# UNPACK #-} !Int
[rWidth] :: Rect -> {-# UNPACK #-} !Int
[rHeight] :: Rect -> {-# UNPACK #-} !Int

-- | Rational coordinates used for interpolations.
data RPoint
RPoint :: {-# UNPACK #-} !RatioInt -> {-# UNPACK #-} !RatioInt -> RPoint
[rpX] :: RPoint -> {-# UNPACK #-} !RatioInt
[rpY] :: RPoint -> {-# UNPACK #-} !RatioInt
instance GHC.Classes.Ord Vision.Primitive.RPoint
instance GHC.Classes.Eq Vision.Primitive.RPoint
instance GHC.Read.Read Vision.Primitive.RPoint
instance GHC.Show.Show Vision.Primitive.RPoint
instance GHC.Classes.Ord Vision.Primitive.Rect
instance GHC.Classes.Eq Vision.Primitive.Rect
instance GHC.Read.Read Vision.Primitive.Rect
instance GHC.Show.Show Vision.Primitive.Rect

module Vision.Image.Class

-- | Determines the number of channels and the type of each pixel of the
--   image and how images are represented.
class Pixel p where type family PixelChannel p

-- | Returns the number of channels of the pixel.
--   
--   Must not consume <tt>p</tt> (could be <a>undefined</a>).
pixNChannels :: Pixel p => p -> Int
pixIndex :: Pixel p => p -> Int -> PixelChannel p

-- | Provides an abstraction for images which are not defined for each of
--   their pixels. The interface is similar to <a>Image</a> except that
--   indexing functions don't always return.
--   
--   Image origin (<tt><tt>ix2</tt> 0 0</tt>) is located in the upper left
--   corner.
class Storable (ImagePixel i) => MaskedImage i where type family ImagePixel i maskedIndex img = (img `maskedLinearIndex`) . toLinearIndex (shape img) maskedLinearIndex img = (img `maskedIndex`) . fromLinearIndex (shape img) values !img = unfoldr step 0 where !n = shapeLength (shape img) step !i | i >= n = Nothing | Just p <- img `maskedLinearIndex` i = Just (p, i + 1) | otherwise = step (i + 1)
shape :: MaskedImage i => i -> Size

-- | Returns the pixel's value at 'Z :. y, :. x'.
maskedIndex :: MaskedImage i => i -> Point -> Maybe (ImagePixel i)

-- | Returns the pixel's value as if the image was a single dimension
--   vector (row-major representation).
maskedLinearIndex :: MaskedImage i => i -> Int -> Maybe (ImagePixel i)

-- | Returns the non-masked values of the image.
values :: MaskedImage i => i -> Vector (ImagePixel i)

-- | Provides an abstraction over the internal representation of an image.
--   
--   Image origin (<tt><tt>ix2</tt> 0 0</tt>) is located in the upper left
--   corner.
class MaskedImage i => Image i where index img = (img `linearIndex`) . toLinearIndex (shape img) linearIndex img = (img `index`) . fromLinearIndex (shape img) vector img = generate (shapeLength $ shape img) (img `linearIndex`)

-- | Returns the pixel value at 'Z :. y :. x'.
index :: Image i => i -> Point -> ImagePixel i

-- | Returns the pixel value as if the image was a single dimension vector
--   (row-major representation).
linearIndex :: Image i => i -> Int -> ImagePixel i

-- | Returns every pixel values as if the image was a single dimension
--   vector (row-major representation).
vector :: Image i => i -> Vector (ImagePixel i)
type ImageChannel i = PixelChannel (ImagePixel i)

-- | Provides ways to construct an image from a function.
class FromFunction i where type family FromFunctionPixel i fromFunctionLine size line f = fromFunction size (\ pt@(Z :. y :. _) -> f (line y) pt) fromFunctionCol size col f = fromFunction size (\ pt@(Z :. _ :. x) -> f (col x) pt) fromFunctionCached size line col f = fromFunction size (\ pt@(Z :. y :. x) -> f (line y) (col x) pt)

-- | Generates an image by calling the given function for each pixel of the
--   constructed image.
fromFunction :: FromFunction i => Size -> (Point -> FromFunctionPixel i) -> i

-- | Generates an image by calling the last function for each pixel of the
--   constructed image.
--   
--   The first function is called for each line, generating a line
--   invariant value.
--   
--   This function is faster for some image representations as some
--   recurring computation can be cached.
fromFunctionLine :: FromFunction i => Size -> (Int -> a) -> (a -> Point -> FromFunctionPixel i) -> i

-- | Generates an image by calling the last function for each pixel of the
--   constructed image.
--   
--   The first function is called for each column, generating a column
--   invariant value.
--   
--   This function *can* be faster for some image representations as some
--   recurring computations can be cached. However, it may requires a
--   vector allocation for these values. If the column invariant is cheap
--   to compute, prefer <a>fromFunction</a>.
fromFunctionCol :: (FromFunction i, Storable b) => Size -> (Int -> b) -> (b -> Point -> FromFunctionPixel i) -> i

-- | Generates an image by calling the last function for each pixel of the
--   constructed image.
--   
--   The two first functions are called for each line and for each column,
--   respectively, generating common line and column invariant values.
--   
--   This function is faster for some image representations as some
--   recurring computation can be cached. However, it may requires a vector
--   allocation for column values. If the column invariant is cheap to
--   compute, prefer <a>fromFunctionLine</a>.
fromFunctionCached :: (FromFunction i, Storable b) => Size -> (Int -> a) -> (Int -> b) -> (a -> b -> Point -> FromFunctionPixel i) -> i

-- | Defines a class for images on which a function can be applied. The
--   class is different from <a>Functor</a> as there could be some
--   constraints and transformations the pixel and image types.
class (MaskedImage src, MaskedImage res) => FunctorImage src res
map :: FunctorImage src res => (ImagePixel src -> ImagePixel res) -> src -> res

-- | Alias of <a>index</a>.
(!) :: Image i => i -> Point -> ImagePixel i

-- | Alias of <a>maskedIndex</a>.
(!?) :: MaskedImage i => i -> Point -> Maybe (ImagePixel i)

-- | Returns the number of channels of an image.
nChannels :: (Pixel (ImagePixel i), MaskedImage i) => i -> Int

-- | Returns an <a>undefined</a> instance of a pixel of the image. This is
--   sometime useful to satisfy the type checker as in a call to
--   <a>pixNChannels</a> :
--   
--   <pre>
--   nChannels img = pixNChannels (pixel img)
--   </pre>
pixel :: MaskedImage i => i -> ImagePixel i
instance Vision.Image.Class.Pixel GHC.Int.Int16
instance Vision.Image.Class.Pixel GHC.Int.Int32
instance Vision.Image.Class.Pixel GHC.Types.Int
instance Vision.Image.Class.Pixel GHC.Word.Word8
instance Vision.Image.Class.Pixel GHC.Word.Word16
instance Vision.Image.Class.Pixel GHC.Word.Word32
instance Vision.Image.Class.Pixel GHC.Types.Word
instance Vision.Image.Class.Pixel GHC.Types.Float
instance Vision.Image.Class.Pixel GHC.Types.Double
instance Vision.Image.Class.Pixel GHC.Types.Bool


-- | Provides a way to estimate the value of a pixel at rational
--   coordinates using a linear interpolation.
module Vision.Image.Interpolate

-- | Provides a way to apply the interpolation to every component of a
--   pixel.
class Interpolable p

-- | Given a function which interpolates two points over a single channel,
--   returns a function which interpolates two points over every channel of
--   two pixels.
interpol :: Interpolable p => (PixelChannel p -> PixelChannel p -> PixelChannel p) -> p -> p -> p

-- | Uses a bilinear interpolation to find the value of the pixel at the
--   rational coordinates.
--   
--   Estimates the value of a rational point <tt>p</tt> using <tt>a</tt>,
--   <tt>b</tt>, <tt>c</tt> and <tt>d</tt> :
--   
--   <pre>
--         x1       x2
--   
--   y1    a ------ b
--         -        -
--         -  p     -
--         -        -
--   y2    c ------ d
--   </pre>
bilinearInterpol :: (Image i, Interpolable (ImagePixel i), Integral (ImageChannel i)) => i -> RPoint -> ImagePixel i
instance Vision.Image.Interpolate.Interpolable GHC.Int.Int16
instance Vision.Image.Interpolate.Interpolable GHC.Int.Int32
instance Vision.Image.Interpolate.Interpolable GHC.Types.Int
instance Vision.Image.Interpolate.Interpolable GHC.Word.Word8
instance Vision.Image.Interpolate.Interpolable GHC.Word.Word16
instance Vision.Image.Interpolate.Interpolable GHC.Word.Word32
instance Vision.Image.Interpolate.Interpolable GHC.Types.Word
instance Vision.Image.Interpolate.Interpolable GHC.Types.Float
instance Vision.Image.Interpolate.Interpolable GHC.Types.Double
instance Vision.Image.Interpolate.Interpolable GHC.Types.Bool

module Vision.Image.Type

-- | Stores the image content in a <a>Vector</a>.
data Manifest p
Manifest :: !Size -> !(Vector p) -> Manifest p
[manifestSize] :: Manifest p -> !Size
[manifestVector] :: Manifest p -> !(Vector p)

-- | A delayed image is an image which is constructed using a function.
--   
--   Usually, a delayed image maps each of its pixels over another image.
--   Delayed images are useful by avoiding intermediate images in a
--   transformation pipeline of images or by avoiding the computation of
--   the whole resulting image when only a portion of its pixels will be
--   accessed.
data Delayed p
Delayed :: !Size -> !(Point -> p) -> Delayed p
[delayedSize] :: Delayed p -> !Size
[delayedFun] :: Delayed p -> !(Point -> p)
data DelayedMask p
DelayedMask :: !Size -> !(Point -> Maybe p) -> DelayedMask p
[delayedMaskSize] :: DelayedMask p -> !Size
[delayedMaskFun] :: DelayedMask p -> !(Point -> Maybe p)

-- | Delays an image in its delayed representation.
delay :: Image i => i -> Delayed (ImagePixel i)

-- | Computes the value of an image into a manifest representation.
compute :: (Image i, Storable (ImagePixel i)) => i -> Manifest (ImagePixel i)

-- | Forces an image to be in its delayed represenation. Does nothing.
delayed :: Delayed p -> Delayed p

-- | Forces an image to be in its manifest represenation. Does nothing.
manifest :: Manifest p -> Manifest p
instance (GHC.Show.Show p, Foreign.Storable.Storable p) => GHC.Show.Show (Vision.Image.Type.Manifest p)
instance (GHC.Classes.Ord p, Foreign.Storable.Storable p) => GHC.Classes.Ord (Vision.Image.Type.Manifest p)
instance (GHC.Classes.Eq p, Foreign.Storable.Storable p) => GHC.Classes.Eq (Vision.Image.Type.Manifest p)
instance Control.DeepSeq.NFData (Vision.Image.Type.Manifest p)
instance Foreign.Storable.Storable p => Vision.Image.Class.MaskedImage (Vision.Image.Type.Manifest p)
instance Foreign.Storable.Storable p => Vision.Image.Class.Image (Vision.Image.Type.Manifest p)
instance Foreign.Storable.Storable p => Vision.Image.Class.FromFunction (Vision.Image.Type.Manifest p)
instance (Vision.Image.Class.Image src, Foreign.Storable.Storable p) => Vision.Image.Class.FunctorImage src (Vision.Image.Type.Manifest p)
instance Foreign.Storable.Storable p => Vision.Image.Class.MaskedImage (Vision.Image.Type.Delayed p)
instance Foreign.Storable.Storable p => Vision.Image.Class.Image (Vision.Image.Type.Delayed p)
instance Vision.Image.Class.FromFunction (Vision.Image.Type.Delayed p)
instance (Vision.Image.Class.Image src, Foreign.Storable.Storable p) => Vision.Image.Class.FunctorImage src (Vision.Image.Type.Delayed p)
instance Foreign.Storable.Storable p => Vision.Image.Class.MaskedImage (Vision.Image.Type.DelayedMask p)
instance Foreign.Storable.Storable p => Vision.Image.Class.FromFunction (Vision.Image.Type.DelayedMask p)
instance (Vision.Image.Class.MaskedImage src, Foreign.Storable.Storable p) => Vision.Image.Class.FunctorImage src (Vision.Image.Type.DelayedMask p)
instance (Foreign.Storable.Storable p1, Foreign.Storable.Storable p2, Data.Convertible.Base.Convertible p1 p2) => Data.Convertible.Base.Convertible (Vision.Image.Type.Manifest p1) (Vision.Image.Type.Manifest p2)
instance (Foreign.Storable.Storable p1, Foreign.Storable.Storable p2, Data.Convertible.Base.Convertible p1 p2) => Data.Convertible.Base.Convertible (Vision.Image.Type.Delayed p1) (Vision.Image.Type.Delayed p2)
instance (Foreign.Storable.Storable p1, Foreign.Storable.Storable p2, Data.Convertible.Base.Convertible p1 p2) => Data.Convertible.Base.Convertible (Vision.Image.Type.Delayed p1) (Vision.Image.Type.Manifest p2)
instance (Foreign.Storable.Storable p1, Foreign.Storable.Storable p2, Data.Convertible.Base.Convertible p1 p2) => Data.Convertible.Base.Convertible (Vision.Image.Type.Manifest p1) (Vision.Image.Type.Delayed p2)

module Vision.Image.Grey.Type
type Grey = Manifest GreyPixel
newtype GreyPixel
GreyPixel :: Word8 -> GreyPixel
type GreyDelayed = Delayed GreyPixel
instance Foreign.Storable.Storable Vision.Image.Grey.Type.GreyPixel
instance GHC.Show.Show Vision.Image.Grey.Type.GreyPixel
instance GHC.Read.Read Vision.Image.Grey.Type.GreyPixel
instance GHC.Real.Real Vision.Image.Grey.Type.GreyPixel
instance GHC.Classes.Ord Vision.Image.Grey.Type.GreyPixel
instance GHC.Num.Num Vision.Image.Grey.Type.GreyPixel
instance GHC.Real.Integral Vision.Image.Grey.Type.GreyPixel
instance GHC.Classes.Eq Vision.Image.Grey.Type.GreyPixel
instance GHC.Enum.Enum Vision.Image.Grey.Type.GreyPixel
instance GHC.Enum.Bounded Vision.Image.Grey.Type.GreyPixel
instance Data.Bits.Bits Vision.Image.Grey.Type.GreyPixel
instance Vision.Image.Class.Pixel Vision.Image.Grey.Type.GreyPixel
instance Vision.Image.Interpolate.Interpolable Vision.Image.Grey.Type.GreyPixel

module Vision.Image.HSV.Type

-- | 24 bits (3 * 8 bits) HSV image.
--   
--   The Hue value is in [0..179], Saturation in [0..255] and Value in
--   [0..255].
--   
--   This image type is more respectful to human eye perception of colors
--   and can be converted (using <tt>convert</tt>) from <tt>RGB</tt>
--   images.
--   
--   Uses <a>http://en.wikipedia.org/wiki/HSL_and_HSV</a> equations to
--   convert from and to RGB.
type HSV = Manifest HSVPixel
data HSVPixel
HSVPixel :: {-# UNPACK #-} !Word8 -> {-# UNPACK #-} !Word8 -> {-# UNPACK #-} !Word8 -> HSVPixel
[hsvHue] :: HSVPixel -> {-# UNPACK #-} !Word8
[hsvSat] :: HSVPixel -> {-# UNPACK #-} !Word8
[hsvValue] :: HSVPixel -> {-# UNPACK #-} !Word8
type HSVDelayed = Delayed HSVPixel
instance GHC.Show.Show Vision.Image.HSV.Type.HSVPixel
instance GHC.Classes.Eq Vision.Image.HSV.Type.HSVPixel
instance Foreign.Storable.Storable Vision.Image.HSV.Type.HSVPixel
instance Vision.Image.Class.Pixel Vision.Image.HSV.Type.HSVPixel
instance Vision.Image.Interpolate.Interpolable Vision.Image.HSV.Type.HSVPixel

module Vision.Image.RGBA.Type
type RGBA = Manifest RGBAPixel
data RGBAPixel
RGBAPixel :: {-# UNPACK #-} !Word8 -> {-# UNPACK #-} !Word8 -> {-# UNPACK #-} !Word8 -> {-# UNPACK #-} !Word8 -> RGBAPixel
[rgbaRed] :: RGBAPixel -> {-# UNPACK #-} !Word8
[rgbaGreen] :: RGBAPixel -> {-# UNPACK #-} !Word8
[rgbaBlue] :: RGBAPixel -> {-# UNPACK #-} !Word8
[rgbaAlpha] :: RGBAPixel -> {-# UNPACK #-} !Word8
type RGBADelayed = Delayed RGBAPixel
instance GHC.Show.Show Vision.Image.RGBA.Type.RGBAPixel
instance GHC.Classes.Eq Vision.Image.RGBA.Type.RGBAPixel
instance Foreign.Storable.Storable Vision.Image.RGBA.Type.RGBAPixel
instance Vision.Image.Class.Pixel Vision.Image.RGBA.Type.RGBAPixel
instance Vision.Image.Interpolate.Interpolable Vision.Image.RGBA.Type.RGBAPixel

module Vision.Image.RGB.Type
type RGB = Manifest RGBPixel
data RGBPixel
RGBPixel :: {-# UNPACK #-} !Word8 -> {-# UNPACK #-} !Word8 -> {-# UNPACK #-} !Word8 -> RGBPixel
[rgbRed] :: RGBPixel -> {-# UNPACK #-} !Word8
[rgbGreen] :: RGBPixel -> {-# UNPACK #-} !Word8
[rgbBlue] :: RGBPixel -> {-# UNPACK #-} !Word8
type RGBDelayed = Delayed RGBPixel
instance GHC.Show.Show Vision.Image.RGB.Type.RGBPixel
instance GHC.Classes.Eq Vision.Image.RGB.Type.RGBPixel
instance Foreign.Storable.Storable Vision.Image.RGB.Type.RGBPixel
instance Vision.Image.Class.Pixel Vision.Image.RGB.Type.RGBPixel
instance Vision.Image.Interpolate.Interpolable Vision.Image.RGB.Type.RGBPixel


-- | Contains functions to compute and manipulate histograms as well as
--   some images transformations which are histogram-based.
--   
--   Every polymorphic function is specialised for histograms of
--   <a>Int32</a>, <a>Double</a> and <a>Float</a>. Other types can be
--   specialized as every polymorphic function is declared
--   <tt>INLINABLE</tt>.
module Vision.Histogram
data Histogram sh a
Histogram :: !sh -> !(Vector a) -> Histogram sh a
[shape] :: Histogram sh a -> !sh

-- | Values of the histogram in row-major order.
[vector] :: Histogram sh a -> !(Vector a)

-- | Subclass of <a>Shape</a> which defines how to resize a shape so it
--   will fit inside a resized histogram.
class Shape sh => HistogramShape sh

-- | Given a number of bins of an histogram, reduces an index so it will be
--   mapped to a bin.
toBin :: HistogramShape sh => sh -> sh -> sh -> sh

-- | This class defines how many dimensions a histogram will have and what
--   will be the default number of bins.
class (Pixel p, Shape (PixelValueSpace p)) => ToHistogram p where type family PixelValueSpace p

-- | Converts a pixel to an index.
pixToIndex :: ToHistogram p => p -> PixelValueSpace p

-- | Returns the maximum number of different values an index can take for
--   each dimension of the histogram (aka. the maximum index returned by
--   <a>pixToIndex</a> plus one).
domainSize :: ToHistogram p => p -> PixelValueSpace p
index :: (Shape sh, Storable a) => Histogram sh a -> sh -> a

-- | Alias of <a>index</a>.
(!) :: (Shape sh, Storable a) => Histogram sh a -> sh -> a

-- | Returns the value at the index as if the histogram was a single
--   dimension vector (row-major representation).
linearIndex :: (Shape sh, Storable a) => Histogram sh a -> Int -> a
map :: (Storable a, Storable b) => (a -> b) -> Histogram sh a -> Histogram sh b

-- | Returns all index/value pairs from the histogram.
assocs :: (Shape sh, Storable a) => Histogram sh a -> [(sh, a)]

-- | Given the number of bins of an histogram and a given pixel, returns
--   the corresponding bin.
pixToBin :: (HistogramShape (PixelValueSpace p), ToHistogram p) => PixelValueSpace p -> p -> PixelValueSpace p

-- | Computes an histogram from a (possibly) multi-channel image.
--   
--   If the size of the histogram is not given, there will be as many bins
--   as the range of values of pixels of the original image (see
--   <a>domainSize</a>).
--   
--   If the size of the histogram is specified, every bin of a given
--   dimension will be of the same size (uniform histogram).
histogram :: (MaskedImage i, ToHistogram (ImagePixel i), Storable a, Num a, HistogramShape (PixelValueSpace (ImagePixel i))) => Maybe (PixelValueSpace (ImagePixel i)) -> i -> Histogram (PixelValueSpace (ImagePixel i)) a

-- | Similar to <a>histogram</a> but adds two dimensions for the y and
--   x-coordinates of the sampled points. This way, the histogram will map
--   different regions of the original image.
--   
--   For example, an <tt>RGB</tt> image will be mapped as <tt><a>Z</a>
--   <a>:.</a> red channel <a>:.</a> green channel <a>:.</a> blue channel
--   <a>:.</a> y region <a>:.</a> x region</tt>.
--   
--   As there is no reason to create an histogram as large as the number of
--   pixels of the image, a size is always needed.
histogram2D :: (Image i, ToHistogram (ImagePixel i), Storable a, Num a, HistogramShape (PixelValueSpace (ImagePixel i))) => ((PixelValueSpace (ImagePixel i)) :. Int) :. Int -> i -> Histogram (((PixelValueSpace (ImagePixel i)) :. Int) :. Int) a

-- | Reduces a 2D histogram to its linear representation. See <a>resize</a>
--   for a reduction of the number of bins of an histogram.
--   
--   <pre>
--   <a>histogram</a> == <a>reduce</a> . <a>histogram2D</a>
--   </pre>
reduce :: (HistogramShape sh, Storable a, Num a) => Histogram ((sh :. Int) :. Int) a -> Histogram sh a

-- | Resizes an histogram to another index shape. See <a>reduce</a> for a
--   reduction of the number of dimensions of an histogram.
resize :: (HistogramShape sh, Storable a, Num a) => sh -> Histogram sh a -> Histogram sh a

-- | Computes the cumulative histogram of another single dimension
--   histogram.
--   
--   <tt>C(i) = SUM H(j)</tt> for each <tt>j</tt> in <tt>[0..i]</tt> where
--   <tt>C</tt> is the cumulative histogram, and <tt>H</tt> the original
--   histogram.
cumulative :: (Storable a, Num a) => Histogram DIM1 a -> Histogram DIM1 a

-- | Normalizes the histogram so that the sum of the histogram bins is
--   equal to the given value (normalisation by the <tt>L1</tt> norm).
--   
--   This is useful to compare two histograms which have been computed from
--   images with a different number of pixels.
normalize :: (Storable a, Real a, Storable b, Fractional b) => b -> Histogram sh a -> Histogram sh b

-- | Equalizes a single channel image by equalising its histogram.
--   
--   The algorithm equalizes the brightness and increases the contrast of
--   the image by mapping each pixel values to the value at the index of
--   the cumulative <tt>L1</tt>-normalized histogram :
--   
--   <tt>N(x, y) = H(I(x, y))</tt> where <tt>N</tt> is the equalized image,
--   <tt>I</tt> is the image and <tt>H</tt> the cumulative of the histogram
--   normalized over an <tt>L1</tt> norm.
--   
--   See <a>https://en.wikipedia.org/wiki/Histogram_equalization</a>.
equalizeImage :: (FunctorImage i i, Integral (ImagePixel i), ToHistogram (ImagePixel i), PixelValueSpace (ImagePixel i) ~ DIM1) => i -> i

-- | Computes the <i>Pearson's correlation coefficient</i> between each
--   corresponding bins of the two histograms.
--   
--   A value of 1 implies a perfect correlation, a value of -1 a perfect
--   opposition and a value of 0 no correlation at all.
--   
--   <pre>
--   <a>compareCorrel</a> = SUM  [ (H1(i) - µ(H1)) (H1(2) - µ(H2)) ]
--                     / (   SQRT [ SUM [ (H1(i) - µ(H1))^2 ] ]
--                         * SQRT [ SUM [ (H2(i) - µ(H2))^2 ] ] )
--   </pre>
--   
--   Where <tt>µ(H)</tt> is the average value of the histogram <tt>H</tt>.
--   
--   See
--   <a>http://en.wikipedia.org/wiki/Pearson_correlation_coefficient</a>.
compareCorrel :: (Shape sh, Storable a, Real a, Storable b, Eq b, Floating b) => Histogram sh a -> Histogram sh a -> b

-- | Computes the Chi-squared distance between two histograms.
--   
--   A value of 0 indicates a perfect match.
--   
--   <tt><a>compareChi</a> = SUM (d(i))</tt> for each indice <tt>i</tt> of
--   the histograms where <tt>d(i) = 2 * ((H1(i) - H2(i))^2 / (H1(i) +
--   H2(i)))</tt>.
compareChi :: (Shape sh, Storable a, Real a, Storable b, Fractional b) => Histogram sh a -> Histogram sh a -> b

-- | Computes the intersection of the two histograms.
--   
--   The higher the score is, the best the match is.
--   
--   <tt><a>compareIntersect</a> = SUM (min(H1(i), H2(i))</tt> for each
--   indice <tt>i</tt> of the histograms.
compareIntersect :: (Shape sh, Storable a, Num a, Ord a) => Histogram sh a -> Histogram sh a -> a

-- | Computed the <i>Earth mover's distance</i> between two histograms.
--   
--   Current algorithm only supports histograms of one dimension.
--   
--   See <a>https://en.wikipedia.org/wiki/Earth_mover's_distance</a>.
compareEMD :: (Num a, Storable a) => Histogram DIM1 a -> Histogram DIM1 a -> a
instance (GHC.Show.Show sh, GHC.Show.Show a, Foreign.Storable.Storable a) => GHC.Show.Show (Vision.Histogram.Histogram sh a)
instance (GHC.Classes.Ord sh, GHC.Classes.Ord a, Foreign.Storable.Storable a) => GHC.Classes.Ord (Vision.Histogram.Histogram sh a)
instance (GHC.Classes.Eq sh, GHC.Classes.Eq a, Foreign.Storable.Storable a) => GHC.Classes.Eq (Vision.Histogram.Histogram sh a)
instance Vision.Histogram.HistogramShape Vision.Primitive.Shape.Z
instance Vision.Histogram.HistogramShape sh => Vision.Histogram.HistogramShape (sh Vision.Primitive.Shape.:. GHC.Types.Int)
instance Vision.Histogram.ToHistogram Vision.Image.Grey.Type.GreyPixel
instance Vision.Histogram.ToHistogram Vision.Image.RGBA.Type.RGBAPixel
instance Vision.Histogram.ToHistogram Vision.Image.RGB.Type.RGBPixel
instance Vision.Histogram.ToHistogram Vision.Image.HSV.Type.HSVPixel

module Vision.Image.Conversion

-- | A typeclass that represents something that can be converted. A
--   <tt>Convertible a b</tt> instance represents an <tt>a</tt> that can be
--   converted to a <tt>b</tt>.
class Convertible a b

-- | Convert <tt>a</tt> to <tt>b</tt>, returning Right on success and Left
--   on error. For a simpler interface, see <a>convert</a>.
safeConvert :: Convertible a b => a -> ConvertResult b

-- | Convert from one type of data to another. Raises an exception if there
--   is an error with the conversion. For a function that does not raise an
--   exception in that case, see <a>safeConvert</a>.
convert :: Convertible a b => a -> b
instance Data.Convertible.Base.Convertible Vision.Image.Grey.Type.GreyPixel Vision.Image.Grey.Type.GreyPixel
instance Data.Convertible.Base.Convertible Vision.Image.HSV.Type.HSVPixel Vision.Image.Grey.Type.GreyPixel
instance Data.Convertible.Base.Convertible Vision.Image.RGBA.Type.RGBAPixel Vision.Image.Grey.Type.GreyPixel
instance Data.Convertible.Base.Convertible Vision.Image.RGB.Type.RGBPixel Vision.Image.Grey.Type.GreyPixel
instance Data.Convertible.Base.Convertible Vision.Image.HSV.Type.HSVPixel Vision.Image.HSV.Type.HSVPixel
instance Data.Convertible.Base.Convertible Vision.Image.Grey.Type.GreyPixel Vision.Image.HSV.Type.HSVPixel
instance Data.Convertible.Base.Convertible Vision.Image.RGB.Type.RGBPixel Vision.Image.HSV.Type.HSVPixel
instance Data.Convertible.Base.Convertible Vision.Image.RGBA.Type.RGBAPixel Vision.Image.HSV.Type.HSVPixel
instance Data.Convertible.Base.Convertible Vision.Image.RGB.Type.RGBPixel Vision.Image.RGB.Type.RGBPixel
instance Data.Convertible.Base.Convertible Vision.Image.Grey.Type.GreyPixel Vision.Image.RGB.Type.RGBPixel
instance Data.Convertible.Base.Convertible Vision.Image.RGBA.Type.RGBAPixel Vision.Image.RGB.Type.RGBPixel
instance Data.Convertible.Base.Convertible Vision.Image.HSV.Type.HSVPixel Vision.Image.RGB.Type.RGBPixel
instance Data.Convertible.Base.Convertible Vision.Image.RGBA.Type.RGBAPixel Vision.Image.RGBA.Type.RGBAPixel
instance Data.Convertible.Base.Convertible Vision.Image.Grey.Type.GreyPixel Vision.Image.RGBA.Type.RGBAPixel
instance Data.Convertible.Base.Convertible Vision.Image.HSV.Type.HSVPixel Vision.Image.RGBA.Type.RGBAPixel
instance Data.Convertible.Base.Convertible Vision.Image.RGB.Type.RGBPixel Vision.Image.RGBA.Type.RGBAPixel


-- | Contains an stateful image type which can be modified inside a
--   <a>ST</a> monad.
module Vision.Image.Mutable

-- | Class for images which can be constructed from a mutable image.
class Image (Freezed i) => MutableImage i where type family Freezed i read !img !ix = img `linearRead` toLinearIndex (mShape img) ix linearRead !img !ix = img `read` fromLinearIndex (mShape img) ix write !img !ix !val = linearWrite img (toLinearIndex (mShape img) ix) val linearWrite !img !ix !val = write img (fromLinearIndex (mShape img) ix) val unsafeFreeze = freeze

-- | <a>mShape</a> doesn't run in a monad as the size of a mutable image is
--   constant.
mShape :: MutableImage i => i s -> Size

-- | Creates a new mutable image of the given size. Pixels are initialized
--   with an unknown value.
new :: (MutableImage i, PrimMonad m) => Size -> m (i (PrimState m))

-- | Creates a new mutable image of the given size and fill it with the
--   given value.
new' :: (MutableImage i, PrimMonad m) => Size -> ImagePixel (Freezed i) -> m (i (PrimState m))

-- | Returns the pixel value at <tt>Z :. y :. x</tt>.
read :: (MutableImage i, PrimMonad m) => i (PrimState m) -> Point -> m (ImagePixel (Freezed i))

-- | Returns the pixel value as if the image was a single dimension vector
--   (row-major representation).
linearRead :: (MutableImage i, PrimMonad m) => i (PrimState m) -> Int -> m (ImagePixel (Freezed i))

-- | Overrides the value of the pixel at <tt>Z :. y :. x</tt>.
write :: (MutableImage i, PrimMonad m) => i (PrimState m) -> Point -> ImagePixel (Freezed i) -> m ()

-- | Overrides the value of the pixel at the given index as if the image
--   was a single dimension vector (row-major representation).
linearWrite :: (MutableImage i, PrimMonad m) => i (PrimState m) -> Int -> ImagePixel (Freezed i) -> m ()

-- | Returns an immutable copy of the mutable image.
freeze :: (MutableImage i, PrimMonad m) => i (PrimState m) -> m (Freezed i)

-- | Returns the immutable version of the mutable image. The mutable image
--   should not be modified thereafter.
unsafeFreeze :: (MutableImage i, PrimMonad m) => i (PrimState m) -> m (Freezed i)

-- | Returns a mutable copy of the immutable image.
thaw :: (MutableImage i, PrimMonad m) => Freezed i -> m (i (PrimState m))

-- | Creates an immutable image from an <a>ST</a> action creating a mutable
--   image.
create :: (MutableImage i) => (forall s. ST s (i s)) -> Freezed i
data MutableManifest p s
MutableManifest :: !Size -> !(MVector s p) -> MutableManifest p s
[mmSize] :: MutableManifest p s -> !Size
[mmVector] :: MutableManifest p s -> !(MVector s p)
instance Foreign.Storable.Storable p => Vision.Image.Mutable.MutableImage (Vision.Image.Mutable.MutableManifest p)


-- | Provides high level functions to do geometric transformations on
--   images.
--   
--   Every transformation is been declared <tt>INLINABLE</tt> so new image
--   types could be specialized.
module Vision.Image.Transform

-- | Defines the set of possible methods for pixel interpolations when
--   looking for a pixel at floating point coordinates.
data InterpolMethod

-- | Selects the top left pixel (fastest).
TruncateInteger :: InterpolMethod

-- | Selects the nearest pixel (fast).
NearestNeighbor :: InterpolMethod

-- | Does a double linear interpolation over the four surrounding points
--   (slow).
Bilinear :: InterpolMethod

-- | Maps the content of the image's rectangle in a new image.
crop :: (Image i1, FromFunction i2, ImagePixel i1 ~ FromFunctionPixel i2) => Rect -> i1 -> i2

-- | Resizes the <a>Image</a> using the given interpolation method.
resize :: (Image i1, Interpolable (ImagePixel i1), FromFunction i2, ImagePixel i1 ~ FromFunctionPixel i2, Integral (ImageChannel i1)) => InterpolMethod -> Size -> i1 -> i2

-- | Reverses the image horizontally.
horizontalFlip :: (Image i1, FromFunction i2, ImagePixel i1 ~ FromFunctionPixel i2) => i1 -> i2

-- | Reverses the image vertically.
verticalFlip :: (Image i1, FromFunction i2, ImagePixel i1 ~ FromFunctionPixel i2) => i1 -> i2

-- | Paints with a new value the pixels surrounding the given point of the
--   image which have the same value as the starting point.
floodFill :: (PrimMonad m, MutableImage i, Eq (ImagePixel (Freezed i))) => Point -> ImagePixel (Freezed i) -> i (PrimState m) -> m ()

module Vision.Image.Parallel

-- | Parallel version of <tt>compute</tt>.
--   
--   Computes the value of an image into a manifest representation in
--   parallel.
--   
--   The monad ensures that the image is fully evaluated before continuing.
computeP :: (Monad m, Image i, Storable (ImagePixel i)) => i -> m (Manifest (ImagePixel i))


-- | Provides high level functions to define and apply filters on images.
--   
--   Filters are operations on images on which the surrounding of each
--   processed pixel is considered according to a kernel.
--   
--   Please use <a>Filter</a> if you only want to apply filter to images.
--   
--   To apply a filter to an image, use the <a>apply</a> method:
--   
--   <pre>
--   let -- Creates a filter which will blur the image. Uses a <a>Double</a> as
--       -- accumulator of the Gaussian kernel.
--       filter :: <a>Blur</a> GreyPixel Double GreyPixel
--       filter = <a>gaussianBlur</a> 2 Nothing
--   in <a>apply</a> filter img :: Grey
--   </pre>
--   
--   The <tt>radius</tt> argument of some filters is used to determine the
--   kernel size. A radius as of 1 means a kernel of size 3, 2 a kernel of
--   size 5 and so on.
--   
--   The <tt>acc</tt> type argument of some filters defines the type which
--   will be used to store the accumulated value of the kernel (e.g. by
--   setting <tt>acc</tt> to <a>Double</a> in the computation of a Gaussian
--   blur, the kernel average will be computed using a <a>Double</a>).
module Vision.Image.Filter.Internal

-- | Provides an implementation to execute a type of filter.
--   
--   <tt>src</tt> is the original image, <tt>res</tt> the resulting image
--   and <tt>f</tt> the filter.
class Filterable src res f

-- | Applies the given filter on the given image.
apply :: Filterable src res f => f -> src -> res
data Filter src kernel init fold acc res
Filter :: !Size -> !KernelAnchor -> !kernel -> !(Point -> src -> init) -> !fold -> !(Point -> src -> init -> acc -> res) -> !(BorderInterpolate src) -> Filter src kernel init fold acc res
[fKernelSize] :: Filter src kernel init fold acc res -> !Size
[fKernelCenter] :: Filter src kernel init fold acc res -> !KernelAnchor

-- | See <a>Kernel</a> and <a>SeparableKernel</a>.
[fKernel] :: Filter src kernel init fold acc res -> !kernel

-- | Computes a constant value for each pixel before applying the kernel.
--   
--   This value will be passed to <a>fKernel</a> functions and to the
--   <a>fPost</a> function. For most filters, <tt>fInit</tt> will be <tt>_
--   _ -&gt; ()</tt>.
[fInit] :: Filter src kernel init fold acc res -> !(Point -> src -> init)

-- | Defines how the accumulated value is initialized.
--   
--   See <a>FilterFold</a> and <a>FilterFold1</a>.
[fFold] :: Filter src kernel init fold acc res -> !fold

-- | This function will be executed after the iteration of the kernel on a
--   given point.
--   
--   Can be used to normalize the accumulated value, for example.
[fPost] :: Filter src kernel init fold acc res -> !(Point -> src -> init -> acc -> res)
[fInterpol] :: Filter src kernel init fold acc res -> !(BorderInterpolate src)

-- | 2D filters which are initialized with a value.
type BoxFilter src init acc res = Filter src (Kernel src init acc) init (FilterFold acc) acc res

-- | 2D filters which are not initialized with a value.
type BoxFilter1 src init res = Filter src (Kernel src init src) init FilterFold1 src res

-- | Separable 2D filters which are initialized with a value.
type SeparableFilter src init acc res = Filter src (SeparableKernel src init acc) init (FilterFold acc) acc res

-- | Separable 2D filters which are not initialized with a value.
type SeparableFilter1 src init res = Filter src (SeparableKernel src init src) init FilterFold1 src res

-- | Defines how the center of the kernel will be determined.
data KernelAnchor
KernelAnchor :: !Point -> KernelAnchor
KernelAnchorCenter :: KernelAnchor

-- | A simple 2D kernel.
--   
--   The kernel function accepts the coordinates in the kernel, the value
--   of the pixel at these coordinates (<tt>src</tt>), the current
--   accumulated value and returns a new accumulated value.
--   
--   Non-separable filters computational complexity grows quadratically
--   according to the size of the sides of the kernel.
newtype Kernel src init acc
Kernel :: (init -> Point -> src -> acc -> acc) -> Kernel src init acc

-- | Some kernels can be factorized in two uni-dimensional kernels
--   (horizontal and vertical).
--   
--   Separable filters computational complexity grows linearly according to
--   the size of the sides of the kernel.
--   
--   See <a>http://http://en.wikipedia.org/wiki/Separable_filter</a>.
data SeparableKernel src init acc
SeparableKernel :: !(init -> DIM1 -> src -> acc -> acc) -> !(init -> DIM1 -> acc -> acc -> acc) -> SeparableKernel src init acc

-- | Vertical (column) kernel.
[skVertical] :: SeparableKernel src init acc -> !(init -> DIM1 -> src -> acc -> acc)

-- | Horizontal (row) kernel.
[skHorizontal] :: SeparableKernel src init acc -> !(init -> DIM1 -> acc -> acc -> acc)

-- | Used to determine the type of the accumulator image used when
--   computing separable filters.
--   
--   <tt>src</tt> and <tt>res</tt> are respectively the source and the
--   result image types while <tt>acc</tt> is the pixel type of the
--   accumulator.
class (Image (SeparableFilterAccumulator src res acc), ImagePixel (SeparableFilterAccumulator src res acc) ~ acc, FromFunction (SeparableFilterAccumulator src res acc), FromFunctionPixel (SeparableFilterAccumulator src res acc) ~ acc) => SeparatelyFiltrable src res acc where type family SeparableFilterAccumulator src res acc

-- | Uses the result of the provided function as the initial value of the
--   kernel's accumulator, depending on the center coordinates in the
--   image.
--   
--   For most filters, the function will always return the same value (i.e.
--   defined as <tt>const 0</tt>), but this kind of initialization could be
--   required for some filters.
data FilterFold acc
FilterFold :: (Point -> acc) -> FilterFold acc

-- | Uses the first pixel in the kernel as initial value. The kernel must
--   not be empty and the accumulator type must be the same as the source
--   pixel type.
--   
--   This kind of initialization is needed by morphological filters.
data FilterFold1
FilterFold1 :: FilterFold1

-- | Defines how image boundaries are extrapolated by the algorithms.
--   
--   '|' characters in examples are image borders.
data BorderInterpolate a

-- | Replicates the first and last pixels of the image.
--   
--   <pre>
--   aaaaaa|abcdefgh|hhhhhhh
--   </pre>
BorderReplicate :: BorderInterpolate a

-- | Reflects the border of the image.
--   
--   <pre>
--   fedcba|abcdefgh|hgfedcb
--   </pre>
BorderReflect :: BorderInterpolate a

-- | Considers that the last pixel of the image is before the first one.
--   
--   <pre>
--   cdefgh|abcdefgh|abcdefg
--   </pre>
BorderWrap :: BorderInterpolate a

-- | Assigns a constant value to out of image pixels.
--   
--   <pre>
--   iiiiii|abcdefgh|iiiiiii  with some specified 'i'
--   </pre>
BorderConstant :: !a -> BorderInterpolate a

-- | Given a method to compute the kernel anchor and the size of the
--   kernel, returns the anchor of the kernel as coordinates.
kernelAnchor :: KernelAnchor -> Size -> Point

-- | Given a method of interpolation, the number of pixel in the dimension
--   and an index in this dimension, returns either the index of the
--   interpolated pixel or a constant value.
borderInterpolate :: BorderInterpolate a -> Int -> Int -> Either Int a
type Morphological pix = SeparableFilter1 pix () pix
dilate :: Ord pix => Int -> Morphological pix
erode :: Ord pix => Int -> Morphological pix
type Blur src acc res = SeparableFilter src () acc res

-- | Blurs the image by averaging the pixel inside the kernel.
--   
--   Considers using a type for <tt>acc</tt> with <tt>maxBound acc &gt;=
--   maxBound src * (kernel size)²</tt>.
blur :: (Integral src, Integral acc, Num res) => Int -> Blur src acc res

-- | Blurs the image by averaging the pixel inside the kernel using a
--   Gaussian function.
--   
--   See <a>http://en.wikipedia.org/wiki/Gaussian_blur</a>
gaussianBlur :: (Integral src, Floating acc, RealFrac acc, Storable acc, Integral res) => Int -> Maybe acc -> Blur src acc res
type Derivative src res = SeparableFilter src () res res
data DerivativeType
DerivativeX :: DerivativeType
DerivativeY :: DerivativeType

-- | Estimates the first derivative using the Scharr's 3x3 kernel.
--   
--   Convolves the following kernel for the X derivative:
--   
--   <pre>
--    -3   0   3
--   -10   0  10
--    -3   0   3
--   </pre>
--   
--   And this kernel for the Y derivative:
--   
--   <pre>
--   -3 -10  -3
--    0   0   0
--    3  10   3
--   </pre>
--   
--   Considers using a signed integer type for <tt>res</tt> with
--   <tt>maxBound res &gt;= 16 * maxBound src</tt>.
scharr :: (Integral src, Integral res) => DerivativeType -> Derivative src res

-- | Estimates the first derivative using a Sobel's kernel.
--   
--   Prefer <a>scharr</a> when radius equals <tt>1</tt> as Scharr's kernel
--   is more accurate and is implemented faster.
--   
--   Considers using a signed integer type for <tt>res</tt> which is
--   significantly larger than <tt>src</tt>, especially for large kernels.
sobel :: (Integral src, Integral res, Storable res) => Int -> DerivativeType -> Derivative src res
type Mean src acc res = SeparableFilter src () acc res

-- | Computes the average of a kernel of the given size.
--   
--   This is similar to <a>blur</a> but with a rectangular kernel and a
--   <a>Fractional</a> result.
mean :: (Integral src, Integral acc, Fractional res) => Size -> SeparableFilter src () acc res
instance Foreign.Storable.Storable acc => Vision.Image.Filter.Internal.SeparatelyFiltrable src (Vision.Image.Type.Manifest p) acc
instance Foreign.Storable.Storable acc => Vision.Image.Filter.Internal.SeparatelyFiltrable src (Vision.Image.Type.Delayed p) acc
instance (Vision.Image.Class.Image src, Vision.Image.Class.FromFunction res, src_pix ~ Vision.Image.Class.ImagePixel src, res_pix ~ Vision.Image.Class.FromFunctionPixel res) => Vision.Image.Filter.Internal.Filterable src res (Vision.Image.Filter.Internal.BoxFilter src_pix init acc res_pix)
instance (Vision.Image.Class.Image src, Vision.Image.Class.FromFunction res, src_pix ~ Vision.Image.Class.ImagePixel src, res_pix ~ Vision.Image.Class.FromFunctionPixel res) => Vision.Image.Filter.Internal.Filterable src res (Vision.Image.Filter.Internal.BoxFilter1 src_pix init res_pix)
instance (Vision.Image.Class.Image src, Vision.Image.Class.FromFunction res, src_pix ~ Vision.Image.Class.ImagePixel src, res_pix ~ Vision.Image.Class.FromFunctionPixel res, Vision.Image.Filter.Internal.SeparatelyFiltrable src res acc) => Vision.Image.Filter.Internal.Filterable src res (Vision.Image.Filter.Internal.SeparableFilter src_pix init acc res_pix)
instance (Vision.Image.Class.Image src, Vision.Image.Class.FromFunction res, src_pix ~ Vision.Image.Class.ImagePixel src, res_pix ~ Vision.Image.Class.FromFunctionPixel res, Vision.Image.Filter.Internal.SeparatelyFiltrable src res src_pix) => Vision.Image.Filter.Internal.Filterable src res (Vision.Image.Filter.Internal.SeparableFilter1 src_pix init res_pix)


-- | Provides high level filtering functions for images.
--   
--   Use <a>Internal</a> if you want to create new image filters.
--   
--   Filters are operations on images on which the surrounding of each
--   processed pixel is considered according to a kernel.
--   
--   See <a>http://en.wikipedia.org/wiki/Kernel_(image_processing)</a> for
--   details.
--   
--   The <tt>radius</tt> argument of some filters is used to determine the
--   kernel size. A radius as of 1 means a kernel of size 3, 2 a kernel of
--   size 5 and so on.
--   
--   <i>Note:</i> filters are currently not supported on multi-channel
--   images (RGB, RGBA ...) are currently not supported.
module Vision.Image.Filter

-- | Provides an implementation to execute a type of filter.
--   
--   <tt>src</tt> is the original image, <tt>res</tt> the resulting image
--   and <tt>f</tt> the filter.
class Filterable src res f
data Filter src kernel init fold acc res

-- | Used to determine the type of the accumulator image used when
--   computing separable filters.
--   
--   <tt>src</tt> and <tt>res</tt> are respectively the source and the
--   result image types while <tt>acc</tt> is the pixel type of the
--   accumulator.
class (Image (SeparableFilterAccumulator src res acc), ImagePixel (SeparableFilterAccumulator src res acc) ~ acc, FromFunction (SeparableFilterAccumulator src res acc), FromFunctionPixel (SeparableFilterAccumulator src res acc) ~ acc) => SeparatelyFiltrable src res acc
dilate :: (Image src, Ord (ImagePixel src), FromFunction res, FromFunctionPixel res ~ ImagePixel src, SeparatelyFiltrable src res (ImagePixel src)) => Int -> src -> res
erode :: (Image src, Ord (ImagePixel src), FromFunction res, FromFunctionPixel res ~ ImagePixel src, SeparatelyFiltrable src res (ImagePixel src)) => Int -> src -> res

-- | Blurs the image by averaging the pixel inside the kernel.
--   
--   Uses an <a>Int32</a> as accumulator during the averaging operation.
blur :: (Image src, Integral (ImagePixel src), FromFunction res, Num (FromFunctionPixel res), SeparatelyFiltrable src res Int32) => Int -> src -> res

-- | Blurs the image by averaging the pixel inside the kernel using a
--   Gaussian function.
--   
--   See <a>http://en.wikipedia.org/wiki/Gaussian_blur</a>
gaussianBlur :: (Image src, Integral (ImagePixel src), FromFunction res, Integral (FromFunctionPixel res), Floating acc, RealFrac acc, Storable acc, SeparatelyFiltrable src res acc) => Int -> Maybe acc -> src -> res
data DerivativeType
DerivativeX :: DerivativeType
DerivativeY :: DerivativeType

-- | Estimates the first derivative using the Scharr's 3x3 kernel.
--   
--   Convolves the following kernel for the X derivative:
--   
--   <pre>
--    -3   0   3
--   -10   0  10
--    -3   0   3
--   </pre>
--   
--   And this kernel for the Y derivative:
--   
--   <pre>
--   -3 -10  -3
--    0   0   0
--    3  10   3
--   </pre>
--   
--   Uses an <a>Int32</a> as accumulator during kernel application.
scharr :: (Image src, Integral (ImagePixel src), FromFunction res, Integral (FromFunctionPixel res), Storable (FromFunctionPixel res), SeparatelyFiltrable src res (FromFunctionPixel res)) => DerivativeType -> src -> res

-- | Estimates the first derivative using a Sobel's kernel.
--   
--   Prefer <a>scharr</a> when radius equals <tt>1</tt> as Scharr's kernel
--   is more accurate and is implemented faster.
--   
--   Uses an <a>Int32</a> as accumulator during kernel application.
sobel :: (Image src, Integral (ImagePixel src), FromFunction res, Integral (FromFunctionPixel res), Storable (FromFunctionPixel res), SeparatelyFiltrable src res (FromFunctionPixel res)) => Int -> DerivativeType -> src -> res

-- | Computes the average of a kernel of the given size.
--   
--   This is similar to <a>blur</a> but with a rectangular kernel and a
--   <a>Fractional</a> result.
--   
--   Uses an <a>Int32</a> as accumulator during the averaging operation.
mean :: (Image src, Integral (ImagePixel src), FromFunction res, Fractional (FromFunctionPixel res), SeparatelyFiltrable src res Int32) => Size -> src -> res

module Vision.Image.Threshold

-- | Specifies what to do with pixels matching the threshold predicate.
--   
--   <tt><a>BinaryThreshold</a> a b</tt> will replace matching pixels by
--   <tt>a</tt> and non-matchings pixels by <tt>b</tt>.
--   
--   <tt><a>Truncate</a> a</tt> will replace matching pixels by <tt>a</tt>.
--   
--   <tt><a>TruncateInv</a> a</tt> will replace non-matching pixels by
--   <tt>a</tt>.
data ThresholdType src res
BinaryThreshold :: res -> res -> ThresholdType src res
Truncate :: src -> ThresholdType src src
TruncateInv :: src -> ThresholdType src src

-- | Given the thresholding method, a boolean indicating if the pixel match
--   the thresholding condition and the pixel, returns the new pixel value.
thresholdType :: ThresholdType src res -> Bool -> src -> res

-- | Applies the given predicate and threshold policy on the image.
threshold :: FunctorImage src res => (ImagePixel src -> Bool) -> ThresholdType (ImagePixel src) (ImagePixel res) -> src -> res

-- | Defines how pixels of the kernel of the adaptive threshold will be
--   weighted.
--   
--   With <a>MeanKernel</a>, pixels of the kernel have the same weight.
--   
--   With <tt><a>GaussianKernel</a> sigma</tt>, pixels are weighted
--   according to their distance from the thresholded pixel using a
--   Gaussian function parametred by <tt>sigma</tt>. See
--   <a>gaussianBlur</a> for details.
data AdaptiveThresholdKernel acc
MeanKernel :: AdaptiveThresholdKernel acc
GaussianKernel :: Maybe acc -> AdaptiveThresholdKernel acc
type AdaptiveThreshold src acc res = SeparableFilter src () acc res

-- | Compares every pixel to its surrounding ones in the kernel of the
--   given radius.
adaptiveThreshold :: (Image src, Integral (ImagePixel src), Ord (ImagePixel src), FromFunction res, Integral (FromFunctionPixel res), Storable acc, SeparatelyFiltrable src res acc) => AdaptiveThresholdKernel acc -> Int -> ImagePixel src -> ThresholdType (ImagePixel src) (FromFunctionPixel res) -> src -> res

-- | Creates an adaptive thresholding filter to be used with <a>apply</a>.
--   
--   Use <a>adaptiveThreshold</a> if you only want to apply the filter on
--   the image.
--   
--   Compares every pixel to its surrounding ones in the kernel of the
--   given radius.
adaptiveThresholdFilter :: (Integral src, Ord src, Storable acc) => AdaptiveThresholdKernel acc -> Int -> src -> ThresholdType src res -> AdaptiveThreshold src acc res

-- | Applies a clustering-based image thresholding using the Otsu's method.
--   
--   See <a>https://en.wikipedia.org/wiki/Otsu's_method</a>.
otsu :: (HistogramShape (PixelValueSpace (ImagePixel src)), ToHistogram (ImagePixel src), FunctorImage src res, Ord (ImagePixel src), Num (ImagePixel src), Enum (ImagePixel src)) => ThresholdType (ImagePixel src) (ImagePixel res) -> src -> res

-- | This is a sliding concentric window filter (SCW) that uses the ratio
--   of the standard deviations of two sliding windows centered on a same
--   point to detect regions of interest (ROI).
--   
--   <pre>
--   scw sizeWindowA sizeWindowB beta thresType img
--   </pre>
--   
--   Let <tt>σA</tt> be the standard deviation of a fist window around a
--   pixel and <tt>σB</tt> be the standard deviation of another window
--   around the same pixel. Then the pixel will match the threshold if
--   <tt>σB / σA &gt;= beta</tt>, and will be thresholded according to the
--   given <a>ThresholdType</a>.
--   
--   See
--   <a>http://www.academypublisher.com/jcp/vol04/no08/jcp0408771777.pdf</a>.
scw :: (Image src, Integral (ImagePixel src), FromFunction dst, Floating stdev, Fractional stdev, Ord stdev, Storable stdev) => Size -> Size -> stdev -> ThresholdType (ImagePixel src) (FromFunctionPixel dst) -> src -> dst


-- | <tt>SPECIALIZE</tt> pragma declarations for grey-scale images.
module Vision.Image.Grey.Specialize

module Vision.Image.Grey


-- | <tt>SPECIALIZE</tt> pragma declarations for HSV images.
module Vision.Image.HSV.Specialize

module Vision.Image.HSV


-- | <tt>SPECIALIZE</tt> pragma declarations for RGBA images.
module Vision.Image.RGBA.Specialize

module Vision.Image.RGBA


-- | <tt>SPECIALIZE</tt> pragma declarations for RGB images.
module Vision.Image.RGB.Specialize

module Vision.Image.RGB


-- | Images are manipulated by their <a>Image</a> and <a>MaskedImage</a>
--   type-class instances.
--   
--   The <a>Manifest</a> representation uses an internal <tt>Vector</tt> to
--   represent the image whereas the <a>Delayed</a> representation uses a
--   function to generate pixels. Most transformation functions are generic
--   to both representations in the way they apply to any type which
--   implements the type-classes.
--   
--   The <a>Delayed</a> image should be used as intermediate
--   representations of complex image transformations.
--   
--   Please refer to our <a>README file</a> for a detailed usage and
--   examples.
module Vision.Image

module Vision.Detector.Edge

-- | Detects edges using the Canny's algorithm. Edges are given the value
--   <a>maxBound</a> while non-edges are given the value <a>minBound</a>.
--   
--   This implementation doesn't perform any noise erasing (as blurring)
--   before edge detection. Noisy images might need to be pre-processed
--   using a Gaussian blur.
--   
--   The bidirectional derivative (gradient magnitude) is computed from
--   <tt>x</tt> and <tt>y</tt> derivatives using <tt>sqrt(dx² + dy²)</tt>.
--   
--   See <a>http://en.wikipedia.org/wiki/Canny_edge_detector</a> for
--   details.
--   
--   This function is specialized for <a>Grey</a> images but is declared
--   <tt>INLINABLE</tt> to be further specialized for new image types.
canny :: (Image src, Integral (ImagePixel src), Bounded res, Eq res, Storable res) => Int -> Int32 -> Int32 -> src -> Manifest res
