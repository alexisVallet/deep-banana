-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Type classes for mapping, folding, and traversing monomorphic containers
--   
--   Monomorphic variants of the Functor, Foldable, and Traversable
--   typeclasses. If you understand Haskell's basic typeclasses, you
--   understand mono-traversable. In addition to what you are used to, it
--   adds on an IsSequence typeclass and has code for marking data
--   structures as non-empty.
@package mono-traversable
@version 0.10.1.1


-- | Provides conversion functions between strict <a>ByteString</a>s and
--   storable <a>Vector</a>s.
module Data.ByteVector

-- | Convert a <a>ByteString</a> into a storable <a>Vector</a>.
--   
--   Since 0.6.1
toByteVector :: ByteString -> Vector Word8

-- | Convert a storable <a>Vector</a> into a <a>ByteString</a>.
--   
--   Since 0.6.1
fromByteVector :: Vector Word8 -> ByteString


-- | Type classes mirroring standard typeclasses, but working with
--   monomorphic containers.
--   
--   The motivation is that some commonly used data types (i.e.,
--   <tt>ByteString</tt> and <tt>Text</tt>) do not allow for instances of
--   typeclasses like <a>Functor</a> and <tt>Foldable</tt>, since they are
--   monomorphic structures. This module allows both monomorphic and
--   polymorphic data types to be instances of the same typeclasses.
--   
--   All of the laws for the polymorphic typeclasses apply to their
--   monomorphic cousins. Thus, even though a <a>MonoFunctor</a> instance
--   for <a>Set</a> could theoretically be defined, it is omitted since it
--   could violate the functor law of <tt><a>omap</a> f . <a>omap</a> g =
--   <a>omap</a> (f . g)</tt>.
--   
--   Note that all typeclasses have been prefixed with <tt>Mono</tt>, and
--   functions have been prefixed with <tt>o</tt>. The mnemonic for
--   <tt>o</tt> is "only one", or alternatively "it's mono, but m is
--   overused in Haskell, so we'll use the second letter instead." (Agreed,
--   it's not a great mangling scheme, input is welcome!)
module Data.MonoTraversable

-- | Type family for getting the type of the elements of a monomorphic
--   container.

-- | Monomorphic containers that can be mapped over.
class MonoFunctor mono where omap = fmap

-- | Map over a monomorphic container
omap :: MonoFunctor mono => (Element mono -> Element mono) -> mono -> mono

-- | Monomorphic containers that can be folded.
class MonoFoldable mono where ofoldMap = foldMap ofoldr = foldr ofoldl' = foldl' otoList t = build (\ mono n -> ofoldr mono n t) oall f = getAll . ofoldMap (All . f) oany f = getAny . ofoldMap (Any . f) onull = oall (const False) olength = ofoldl' (\ i _ -> i + 1) 0 olength64 = ofoldl' (\ i _ -> i + 1) 0 ocompareLength c0 i0 = olength c0 `compare` fromIntegral i0 otraverse_ f = ofoldr ((*>) . f) (pure ()) ofor_ = flip otraverse_ omapM_ f = ofoldr ((>>) . f) (return ()) oforM_ = flip omapM_ ofoldlM f z0 xs = ofoldr f' return xs z0 where f' x k z = f z x >>= k ofoldMap1Ex f = fromMaybe (error "Data.MonoTraversable.ofoldMap1Ex") . getOption . ofoldMap (Option . Just . f) ofoldr1Ex = foldr1 ofoldl1Ex' = foldl1 headEx = ofoldr const (error "Data.MonoTraversable.headEx: empty") lastEx = ofoldl1Ex' (flip const) unsafeHead = headEx unsafeLast = lastEx maximumByEx f = ofoldl1Ex' go where go x y = case f x y of { LT -> y _ -> x } minimumByEx f = ofoldl1Ex' go where go x y = case f x y of { GT -> y _ -> x }

-- | Map each element of a monomorphic container to a <a>Monoid</a> and
--   combine the results.
ofoldMap :: (MonoFoldable mono, Monoid m) => (Element mono -> m) -> mono -> m

-- | Right-associative fold of a monomorphic container.
ofoldr :: MonoFoldable mono => (Element mono -> b -> b) -> b -> mono -> b

-- | Strict left-associative fold of a monomorphic container.
ofoldl' :: MonoFoldable mono => (a -> Element mono -> a) -> a -> mono -> a

-- | Convert a monomorphic container to a list.
otoList :: MonoFoldable mono => mono -> [Element mono]

-- | Are <b>all</b> of the elements in a monomorphic container converted to
--   booleans <a>True</a>?
oall :: MonoFoldable mono => (Element mono -> Bool) -> mono -> Bool

-- | Are <b>any</b> of the elements in a monomorphic container converted to
--   booleans <a>True</a>?
oany :: MonoFoldable mono => (Element mono -> Bool) -> mono -> Bool

-- | Is the monomorphic container empty?
onull :: MonoFoldable mono => mono -> Bool

-- | Length of a monomorphic container, returns a <a>Int</a>.
olength :: MonoFoldable mono => mono -> Int

-- | Length of a monomorphic container, returns a <a>Int64</a>.
olength64 :: MonoFoldable mono => mono -> Int64

-- | Compare the length of a monomorphic container and a given number.
ocompareLength :: (MonoFoldable mono, Integral i) => mono -> i -> Ordering

-- | Map each element of a monomorphic container to an action, evaluate
--   these actions from left to right, and ignore the results.
otraverse_ :: (MonoFoldable mono, MonoFoldable mono, Applicative f) => (Element mono -> f b) -> mono -> f ()

-- | <a>ofor_</a> is <a>otraverse_</a> with its arguments flipped.
ofor_ :: (MonoFoldable mono, MonoFoldable mono, Applicative f) => mono -> (Element mono -> f b) -> f ()

-- | Map each element of a monomorphic container to a monadic action,
--   evaluate these actions from left to right, and ignore the results.
omapM_ :: (MonoFoldable mono, MonoFoldable mono, Monad m) => (Element mono -> m ()) -> mono -> m ()

-- | <a>oforM_</a> is <a>omapM_</a> with its arguments flipped.
oforM_ :: (MonoFoldable mono, MonoFoldable mono, Monad m) => mono -> (Element mono -> m ()) -> m ()

-- | Monadic fold over the elements of a monomorphic container, associating
--   to the left.
ofoldlM :: (MonoFoldable mono, MonoFoldable mono, Monad m) => (a -> Element mono -> m a) -> a -> mono -> m a

-- | Map each element of a monomorphic container to a semigroup, and
--   combine the results.
--   
--   Note: this is a partial function. On an empty <a>MonoFoldable</a>, it
--   will throw an exception.
--   
--   <i>See <a>ofoldMap1</a> from <a>Data.MinLen</a> for a total version of
--   this function.</i>
ofoldMap1Ex :: (MonoFoldable mono, Semigroup m) => (Element mono -> m) -> mono -> m

-- | Right-associative fold of a monomorphic container with no base
--   element.
--   
--   Note: this is a partial function. On an empty <a>MonoFoldable</a>, it
--   will throw an exception.
--   
--   <i>See <a>ofoldr1Ex</a> from <a>Data.MinLen</a> for a total version of
--   this function.</i>
ofoldr1Ex :: MonoFoldable mono => (Element mono -> Element mono -> Element mono) -> mono -> Element mono

-- | Strict left-associative fold of a monomorphic container with no base
--   element.
--   
--   Note: this is a partial function. On an empty <a>MonoFoldable</a>, it
--   will throw an exception.
--   
--   <i>See <a>ofoldl1Ex'</a> from <a>Data.MinLen</a> for a total version
--   of this function.</i>
ofoldl1Ex' :: MonoFoldable mono => (Element mono -> Element mono -> Element mono) -> mono -> Element mono

-- | Get the first element of a monomorphic container.
--   
--   Note: this is a partial function. On an empty <a>MonoFoldable</a>, it
--   will throw an exception.
--   
--   <i>See <a>head</a> from <a>Data.MinLen</a> for a total version of this
--   function.</i>
headEx :: MonoFoldable mono => mono -> Element mono

-- | Get the last element of a monomorphic container.
--   
--   Note: this is a partial function. On an empty <a>MonoFoldable</a>, it
--   will throw an exception.
--   
--   <i>See 'Data.MinLen.last from <a>Data.MinLen</a> for a total version
--   of this function.</i>
lastEx :: MonoFoldable mono => mono -> Element mono

-- | Equivalent to <a>headEx</a>.
unsafeHead :: MonoFoldable mono => mono -> Element mono

-- | Equivalent to <a>lastEx</a>.
unsafeLast :: MonoFoldable mono => mono -> Element mono

-- | Get the maximum element of a monomorphic container, using a supplied
--   element ordering function.
--   
--   Note: this is a partial function. On an empty <a>MonoFoldable</a>, it
--   will throw an exception.
--   
--   <i>See <a>maximiumBy</a> from <a>Data.MinLen</a> for a total version
--   of this function.</i>
maximumByEx :: MonoFoldable mono => (Element mono -> Element mono -> Ordering) -> mono -> Element mono

-- | Get the minimum element of a monomorphic container, using a supplied
--   element ordering function.
--   
--   Note: this is a partial function. On an empty <a>MonoFoldable</a>, it
--   will throw an exception.
--   
--   <i>See <a>minimumBy</a> from <a>Data.MinLen</a> for a total version of
--   this function.</i>
minimumByEx :: MonoFoldable mono => (Element mono -> Element mono -> Ordering) -> mono -> Element mono

-- | Safe version of <a>headEx</a>.
--   
--   Returns <a>Nothing</a> instead of throwing an exception when
--   encountering an empty monomorphic container.
headMay :: MonoFoldable mono => mono -> Maybe (Element mono)

-- | Safe version of <a>lastEx</a>.
--   
--   Returns <a>Nothing</a> instead of throwing an exception when
--   encountering an empty monomorphic container.
lastMay :: MonoFoldable mono => mono -> Maybe (Element mono)

-- | <a>osum</a> computes the sum of the numbers of a monomorphic
--   container.
osum :: (MonoFoldable mono, Num (Element mono)) => mono -> Element mono

-- | <a>oproduct</a> computes the product of the numbers of a monomorphic
--   container.
oproduct :: (MonoFoldable mono, Num (Element mono)) => mono -> Element mono

-- | Are <b>all</b> of the elements <a>True</a>?
--   
--   Since 0.6.0
oand :: (Element mono ~ Bool, MonoFoldable mono) => mono -> Bool

-- | Are <b>any</b> of the elements <a>True</a>?
--   
--   Since 0.6.0
oor :: (Element mono ~ Bool, MonoFoldable mono) => mono -> Bool

-- | A typeclass for monomorphic containers that are <a>Monoid</a>s.
class (MonoFoldable mono, Monoid mono) => MonoFoldableMonoid mono where oconcatMap = ofoldMap

-- | Map a function over a monomorphic container and combine the results.
oconcatMap :: MonoFoldableMonoid mono => (Element mono -> mono) -> mono -> mono

-- | A typeclass for monomorphic containers whose elements are an instance
--   of <a>Eq</a>.
class (MonoFoldable mono, Eq (Element mono)) => MonoFoldableEq mono where oelem e = elem e . otoList onotElem e = notElem e . otoList

-- | Checks if the monomorphic container includes the supplied element.
oelem :: MonoFoldableEq mono => Element mono -> mono -> Bool

-- | Checks if the monomorphic container does not include the supplied
--   element.
onotElem :: MonoFoldableEq mono => Element mono -> mono -> Bool

-- | A typeclass for monomorphic containers whose elements are an instance
--   of <a>Ord</a>.
class (MonoFoldable mono, Ord (Element mono)) => MonoFoldableOrd mono where maximumEx = maximumByEx compare minimumEx = minimumByEx compare

-- | Get the minimum element of a monomorphic container.
--   
--   Note: this is a partial function. On an empty <a>MonoFoldable</a>, it
--   will throw an exception.
--   
--   <i>See <a>maximum</a> from <a>Data.MinLen</a> for a total version of
--   this function.</i>
maximumEx :: MonoFoldableOrd mono => mono -> Element mono

-- | Get the maximum element of a monomorphic container.
--   
--   Note: this is a partial function. On an empty <a>MonoFoldable</a>, it
--   will throw an exception.
--   
--   <i>See <a>minimum</a> from <a>Data.MinLen</a> for a total version of
--   this function.</i>
minimumEx :: MonoFoldableOrd mono => mono -> Element mono

-- | Safe version of <a>maximumEx</a>.
--   
--   Returns <a>Nothing</a> instead of throwing an exception when
--   encountering an empty monomorphic container.
maximumMay :: MonoFoldableOrd mono => mono -> Maybe (Element mono)

-- | Safe version of <a>maximumByEx</a>.
--   
--   Returns <a>Nothing</a> instead of throwing an exception when
--   encountering an empty monomorphic container.
maximumByMay :: MonoFoldable mono => (Element mono -> Element mono -> Ordering) -> mono -> Maybe (Element mono)

-- | Safe version of <a>minimumEx</a>.
--   
--   Returns <a>Nothing</a> instead of throwing an exception when
--   encountering an empty monomorphic container.
minimumMay :: MonoFoldableOrd mono => mono -> Maybe (Element mono)

-- | Safe version of <a>minimumByEx</a>.
--   
--   Returns <a>Nothing</a> instead of throwing an exception when
--   encountering an empty monomorphic container.
minimumByMay :: MonoFoldable mono => (Element mono -> Element mono -> Ordering) -> mono -> Maybe (Element mono)

-- | Monomorphic containers that can be traversed from left to right.
class (MonoFunctor mono, MonoFoldable mono) => MonoTraversable mono where otraverse = traverse omapM = mapM

-- | Map each element of a monomorphic container to an action, evaluate
--   these actions from left to right, and collect the results.
otraverse :: (MonoTraversable mono, Applicative f) => (Element mono -> f (Element mono)) -> mono -> f mono

-- | Map each element of a monomorphic container to a monadic action,
--   evaluate these actions from left to right, and collect the results.
omapM :: (MonoTraversable mono, Monad m) => (Element mono -> m (Element mono)) -> mono -> m mono

-- | <a>ofor</a> is <a>otraverse</a> with its arguments flipped.
ofor :: (MonoTraversable mono, Applicative f) => mono -> (Element mono -> f (Element mono)) -> f mono

-- | <a>oforM</a> is <a>omapM</a> with its arguments flipped.
oforM :: (MonoTraversable mono, Monad f) => mono -> (Element mono -> f (Element mono)) -> f mono

-- | A strict left fold, together with an unwrap function.
--   
--   This is convenient when the accumulator value is not the same as the
--   final expected type. It is provided mainly for integration with the
--   <tt>foldl</tt> package, to be used in conjunction with
--   <tt>purely</tt>.
--   
--   Since 0.3.1
ofoldlUnwrap :: MonoFoldable mono => (x -> Element mono -> x) -> x -> (x -> b) -> mono -> b

-- | A monadic strict left fold, together with an unwrap function.
--   
--   Similar to <tt>foldlUnwrap</tt>, but allows monadic actions. To be
--   used with <tt>impurely</tt> from <tt>foldl</tt>.
--   
--   Since 0.3.1
ofoldMUnwrap :: (Monad m, MonoFoldable mono) => (x -> Element mono -> m x) -> m x -> (x -> m b) -> mono -> m b

-- | Typeclass for monomorphic containers that an element can be lifted
--   into.
--   
--   For any <a>MonoFunctor</a>, the following law holds:
--   
--   <pre>
--   <a>omap</a> f . <a>opoint</a> = <a>opoint</a> . f
--   </pre>
class MonoPointed mono where opoint = pure

-- | Lift an element into a monomorphic container.
--   
--   <a>opoint</a> is the same as <a>pure</a> for an <a>Applicative</a>
opoint :: MonoPointed mono => Element mono -> mono

-- | Typeclass for monomorphic containers where it is always okay to
--   "extract" a value from with <a>oextract</a>, and where you can
--   extrapolate any "extracting" function to be a function on the whole
--   part with <a>oextend</a>.
--   
--   <a>oextend</a> and <a>oextract</a> should work together following the
--   laws:
--   
--   <pre>
--   <a>oextend</a> <a>oextract</a>      = <a>id</a>
--   <a>oextract</a> . <a>oextend</a> f  = f
--   <a>oextend</a> f . <a>oextend</a> g = <a>oextend</a> (f . <a>oextend</a> g)
--   </pre>
--   
--   As an intuition, <tt><a>oextend</a> f</tt> uses <tt>f</tt> to "build
--   up" a new <tt>mono</tt> with pieces from the old one received by
--   <tt>f</tt>.
class MonoFunctor mono => MonoComonad mono where oextract = extract oextend = extend

-- | Extract an element from <tt>mono</tt>. Can be thought of as a dual
--   concept to <tt>opoint</tt>.
oextract :: MonoComonad mono => mono -> Element mono

-- | <a>Extend</a> a <tt>mono -&gt; <a>Element</a> mono</tt> function to be
--   a <tt>mono -&gt; mono</tt>; that is, builds a new <tt>mono</tt> from
--   the old one by using pieces glimpsed from the given function.
oextend :: MonoComonad mono => (mono -> Element mono) -> mono -> mono
instance Data.MonoTraversable.MonoFunctor Data.ByteString.Internal.ByteString
instance Data.MonoTraversable.MonoFunctor Data.ByteString.Lazy.Internal.ByteString
instance Data.MonoTraversable.MonoFunctor Data.Text.Internal.Text
instance Data.MonoTraversable.MonoFunctor Data.Text.Internal.Lazy.Text
instance Data.MonoTraversable.MonoFunctor [a]
instance Data.MonoTraversable.MonoFunctor (GHC.Types.IO a)
instance Data.MonoTraversable.MonoFunctor (Control.Applicative.ZipList a)
instance Data.MonoTraversable.MonoFunctor (GHC.Base.Maybe a)
instance Data.MonoTraversable.MonoFunctor (Data.Tree.Tree a)
instance Data.MonoTraversable.MonoFunctor (Data.Sequence.Seq a)
instance Data.MonoTraversable.MonoFunctor (Data.DList.DList a)
instance Data.MonoTraversable.MonoFunctor (Data.Sequence.ViewL a)
instance Data.MonoTraversable.MonoFunctor (Data.Sequence.ViewR a)
instance Data.MonoTraversable.MonoFunctor (Data.IntMap.Base.IntMap a)
instance Data.MonoTraversable.MonoFunctor (Data.Semigroup.Option a)
instance Data.MonoTraversable.MonoFunctor (Data.List.NonEmpty.NonEmpty a)
instance Data.MonoTraversable.MonoFunctor (Data.Functor.Identity.Identity a)
instance Data.MonoTraversable.MonoFunctor (r -> a)
instance Data.MonoTraversable.MonoFunctor (Data.Either.Either a b)
instance Data.MonoTraversable.MonoFunctor (a, b)
instance Data.MonoTraversable.MonoFunctor (Control.Applicative.Const m a)
instance GHC.Base.Monad m => Data.MonoTraversable.MonoFunctor (Control.Applicative.WrappedMonad m a)
instance Data.MonoTraversable.MonoFunctor (Data.Map.Base.Map k v)
instance Data.MonoTraversable.MonoFunctor (Data.HashMap.Base.HashMap k v)
instance Data.MonoTraversable.MonoFunctor (Data.Vector.Vector a)
instance Data.MonoTraversable.MonoFunctor (Data.Semigroup.Arg a b)
instance GHC.Base.Functor w => Data.MonoTraversable.MonoFunctor (Control.Comonad.Trans.Env.EnvT e w a)
instance GHC.Base.Functor w => Data.MonoTraversable.MonoFunctor (Control.Comonad.Trans.Store.StoreT s w a)
instance GHC.Base.Functor w => Data.MonoTraversable.MonoFunctor (Control.Comonad.Trans.Traced.TracedT m w a)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => Data.MonoTraversable.MonoFunctor (Data.Functor.Coproduct.Coproduct f g a)
instance Control.Arrow.Arrow a => Data.MonoTraversable.MonoFunctor (Control.Applicative.WrappedArrow a b c)
instance GHC.Base.Functor f => Data.MonoTraversable.MonoFunctor (Data.Functor.Bind.Class.MaybeApply f a)
instance GHC.Base.Functor f => Data.MonoTraversable.MonoFunctor (Data.Functor.Bind.Class.WrappedApplicative f a)
instance Data.MonoTraversable.MonoFunctor (Control.Comonad.Cokleisli w a b)
instance GHC.Base.Functor m => Data.MonoTraversable.MonoFunctor (Control.Monad.Trans.Maybe.MaybeT m a)
instance GHC.Base.Functor m => Data.MonoTraversable.MonoFunctor (Control.Monad.Trans.List.ListT m a)
instance GHC.Base.Functor m => Data.MonoTraversable.MonoFunctor (Control.Monad.Trans.Identity.IdentityT m a)
instance GHC.Base.Functor m => Data.MonoTraversable.MonoFunctor (Control.Monad.Trans.Writer.Lazy.WriterT w m a)
instance GHC.Base.Functor m => Data.MonoTraversable.MonoFunctor (Control.Monad.Trans.Writer.Strict.WriterT w m a)
instance GHC.Base.Functor m => Data.MonoTraversable.MonoFunctor (Control.Monad.Trans.State.Lazy.StateT s m a)
instance GHC.Base.Functor m => Data.MonoTraversable.MonoFunctor (Control.Monad.Trans.State.Strict.StateT s m a)
instance GHC.Base.Functor m => Data.MonoTraversable.MonoFunctor (Control.Monad.Trans.RWS.Lazy.RWST r w s m a)
instance GHC.Base.Functor m => Data.MonoTraversable.MonoFunctor (Control.Monad.Trans.RWS.Strict.RWST r w s m a)
instance GHC.Base.Functor m => Data.MonoTraversable.MonoFunctor (Control.Monad.Trans.Reader.ReaderT r m a)
instance GHC.Base.Functor m => Data.MonoTraversable.MonoFunctor (Control.Monad.Trans.Error.ErrorT e m a)
instance GHC.Base.Functor m => Data.MonoTraversable.MonoFunctor (Control.Monad.Trans.Cont.ContT r m a)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => Data.MonoTraversable.MonoFunctor (Data.Functor.Compose.Compose f g a)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => Data.MonoTraversable.MonoFunctor (Data.Functor.Product.Product f g a)
instance GHC.Base.Functor f => Data.MonoTraversable.MonoFunctor (Data.Semigroupoid.Static.Static f a b)
instance Data.Vector.Unboxed.Base.Unbox a => Data.MonoTraversable.MonoFunctor (Data.Vector.Unboxed.Base.Vector a)
instance Foreign.Storable.Storable a => Data.MonoTraversable.MonoFunctor (Data.Vector.Storable.Vector a)
instance Data.MonoTraversable.MonoFoldable Data.ByteString.Internal.ByteString
instance Data.MonoTraversable.MonoFoldable Data.ByteString.Lazy.Internal.ByteString
instance Data.MonoTraversable.MonoFoldable Data.Text.Internal.Text
instance Data.MonoTraversable.MonoFoldable Data.Text.Internal.Lazy.Text
instance Data.MonoTraversable.MonoFoldable Data.IntSet.Base.IntSet
instance Data.MonoTraversable.MonoFoldable [a]
instance Data.MonoTraversable.MonoFoldable (GHC.Base.Maybe a)
instance Data.MonoTraversable.MonoFoldable (Data.Tree.Tree a)
instance Data.MonoTraversable.MonoFoldable (Data.Sequence.Seq a)
instance Data.MonoTraversable.MonoFoldable (Data.Sequence.ViewL a)
instance Data.MonoTraversable.MonoFoldable (Data.Sequence.ViewR a)
instance Data.MonoTraversable.MonoFoldable (Data.IntMap.Base.IntMap a)
instance Data.MonoTraversable.MonoFoldable (Data.Semigroup.Option a)
instance Data.MonoTraversable.MonoFoldable (Data.List.NonEmpty.NonEmpty a)
instance Data.MonoTraversable.MonoFoldable (Data.Functor.Identity.Identity a)
instance Data.MonoTraversable.MonoFoldable (Data.Map.Base.Map k v)
instance Data.MonoTraversable.MonoFoldable (Data.HashMap.Base.HashMap k v)
instance Data.MonoTraversable.MonoFoldable (Data.Vector.Vector a)
instance Data.MonoTraversable.MonoFoldable (Data.Set.Base.Set e)
instance Data.MonoTraversable.MonoFoldable (Data.HashSet.HashSet e)
instance Data.MonoTraversable.MonoFoldable (Data.DList.DList a)
instance Data.Vector.Unboxed.Base.Unbox a => Data.MonoTraversable.MonoFoldable (Data.Vector.Unboxed.Base.Vector a)
instance Foreign.Storable.Storable a => Data.MonoTraversable.MonoFoldable (Data.Vector.Storable.Vector a)
instance Data.MonoTraversable.MonoFoldable (Data.Either.Either a b)
instance Data.MonoTraversable.MonoFoldable (a, b)
instance Data.MonoTraversable.MonoFoldable (Control.Applicative.Const m a)
instance Data.Foldable.Foldable f => Data.MonoTraversable.MonoFoldable (Control.Monad.Trans.Maybe.MaybeT f a)
instance Data.Foldable.Foldable f => Data.MonoTraversable.MonoFoldable (Control.Monad.Trans.List.ListT f a)
instance Data.Foldable.Foldable f => Data.MonoTraversable.MonoFoldable (Control.Monad.Trans.Identity.IdentityT f a)
instance Data.Foldable.Foldable f => Data.MonoTraversable.MonoFoldable (Control.Monad.Trans.Writer.Lazy.WriterT w f a)
instance Data.Foldable.Foldable f => Data.MonoTraversable.MonoFoldable (Control.Monad.Trans.Writer.Strict.WriterT w f a)
instance Data.Foldable.Foldable f => Data.MonoTraversable.MonoFoldable (Control.Monad.Trans.Error.ErrorT e f a)
instance (Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.MonoTraversable.MonoFoldable (Data.Functor.Compose.Compose f g a)
instance (Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.MonoTraversable.MonoFoldable (Data.Functor.Product.Product f g a)
instance (Data.MonoTraversable.MonoFoldable (t a), GHC.Base.Monoid (t a)) => Data.MonoTraversable.MonoFoldableMonoid (t a)
instance Data.MonoTraversable.MonoFoldableMonoid Data.ByteString.Internal.ByteString
instance Data.MonoTraversable.MonoFoldableMonoid Data.ByteString.Lazy.Internal.ByteString
instance Data.MonoTraversable.MonoFoldableMonoid Data.Text.Internal.Text
instance Data.MonoTraversable.MonoFoldableMonoid Data.Text.Internal.Lazy.Text
instance GHC.Classes.Eq a => Data.MonoTraversable.MonoFoldableEq (Data.Sequence.Seq a)
instance GHC.Classes.Eq a => Data.MonoTraversable.MonoFoldableEq (Data.Vector.Vector a)
instance (GHC.Classes.Eq a, Data.Vector.Unboxed.Base.Unbox a) => Data.MonoTraversable.MonoFoldableEq (Data.Vector.Unboxed.Base.Vector a)
instance (GHC.Classes.Eq a, Foreign.Storable.Storable a) => Data.MonoTraversable.MonoFoldableEq (Data.Vector.Storable.Vector a)
instance GHC.Classes.Eq a => Data.MonoTraversable.MonoFoldableEq (Data.List.NonEmpty.NonEmpty a)
instance Data.MonoTraversable.MonoFoldableEq Data.Text.Internal.Text
instance Data.MonoTraversable.MonoFoldableEq Data.Text.Internal.Lazy.Text
instance Data.MonoTraversable.MonoFoldableEq Data.IntSet.Base.IntSet
instance GHC.Classes.Eq a => Data.MonoTraversable.MonoFoldableEq (GHC.Base.Maybe a)
instance GHC.Classes.Eq a => Data.MonoTraversable.MonoFoldableEq (Data.Tree.Tree a)
instance GHC.Classes.Eq a => Data.MonoTraversable.MonoFoldableEq (Data.Sequence.ViewL a)
instance GHC.Classes.Eq a => Data.MonoTraversable.MonoFoldableEq (Data.Sequence.ViewR a)
instance GHC.Classes.Eq a => Data.MonoTraversable.MonoFoldableEq (Data.IntMap.Base.IntMap a)
instance GHC.Classes.Eq a => Data.MonoTraversable.MonoFoldableEq (Data.Semigroup.Option a)
instance GHC.Classes.Eq a => Data.MonoTraversable.MonoFoldableEq (Data.Functor.Identity.Identity a)
instance GHC.Classes.Eq v => Data.MonoTraversable.MonoFoldableEq (Data.Map.Base.Map k v)
instance GHC.Classes.Eq v => Data.MonoTraversable.MonoFoldableEq (Data.HashMap.Base.HashMap k v)
instance GHC.Classes.Eq a => Data.MonoTraversable.MonoFoldableEq (Data.HashSet.HashSet a)
instance GHC.Classes.Eq a => Data.MonoTraversable.MonoFoldableEq (Data.DList.DList a)
instance GHC.Classes.Eq b => Data.MonoTraversable.MonoFoldableEq (Data.Either.Either a b)
instance GHC.Classes.Eq b => Data.MonoTraversable.MonoFoldableEq (a, b)
instance GHC.Classes.Eq a => Data.MonoTraversable.MonoFoldableEq (Control.Applicative.Const m a)
instance (GHC.Classes.Eq a, Data.Foldable.Foldable f) => Data.MonoTraversable.MonoFoldableEq (Control.Monad.Trans.Maybe.MaybeT f a)
instance (GHC.Classes.Eq a, Data.Foldable.Foldable f) => Data.MonoTraversable.MonoFoldableEq (Control.Monad.Trans.List.ListT f a)
instance (GHC.Classes.Eq a, Data.Foldable.Foldable f) => Data.MonoTraversable.MonoFoldableEq (Control.Monad.Trans.Identity.IdentityT f a)
instance (GHC.Classes.Eq a, Data.Foldable.Foldable f) => Data.MonoTraversable.MonoFoldableEq (Control.Monad.Trans.Writer.Lazy.WriterT w f a)
instance (GHC.Classes.Eq a, Data.Foldable.Foldable f) => Data.MonoTraversable.MonoFoldableEq (Control.Monad.Trans.Writer.Strict.WriterT w f a)
instance (GHC.Classes.Eq a, Data.Foldable.Foldable f) => Data.MonoTraversable.MonoFoldableEq (Control.Monad.Trans.Error.ErrorT e f a)
instance (GHC.Classes.Eq a, Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.MonoTraversable.MonoFoldableEq (Data.Functor.Compose.Compose f g a)
instance (GHC.Classes.Eq a, Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.MonoTraversable.MonoFoldableEq (Data.Functor.Product.Product f g a)
instance GHC.Classes.Eq a => Data.MonoTraversable.MonoFoldableEq [a]
instance Data.MonoTraversable.MonoFoldableEq Data.ByteString.Internal.ByteString
instance Data.MonoTraversable.MonoFoldableEq Data.ByteString.Lazy.Internal.ByteString
instance (GHC.Classes.Eq a, GHC.Classes.Ord a) => Data.MonoTraversable.MonoFoldableEq (Data.Set.Base.Set a)
instance Data.MonoTraversable.MonoFoldableOrd Data.ByteString.Internal.ByteString
instance Data.MonoTraversable.MonoFoldableOrd Data.ByteString.Lazy.Internal.ByteString
instance Data.MonoTraversable.MonoFoldableOrd Data.Text.Internal.Text
instance Data.MonoTraversable.MonoFoldableOrd Data.Text.Internal.Lazy.Text
instance Data.MonoTraversable.MonoFoldableOrd Data.IntSet.Base.IntSet
instance GHC.Classes.Ord a => Data.MonoTraversable.MonoFoldableOrd [a]
instance GHC.Classes.Ord a => Data.MonoTraversable.MonoFoldableOrd (GHC.Base.Maybe a)
instance GHC.Classes.Ord a => Data.MonoTraversable.MonoFoldableOrd (Data.Tree.Tree a)
instance GHC.Classes.Ord a => Data.MonoTraversable.MonoFoldableOrd (Data.Sequence.Seq a)
instance GHC.Classes.Ord a => Data.MonoTraversable.MonoFoldableOrd (Data.Sequence.ViewL a)
instance GHC.Classes.Ord a => Data.MonoTraversable.MonoFoldableOrd (Data.Sequence.ViewR a)
instance GHC.Classes.Ord a => Data.MonoTraversable.MonoFoldableOrd (Data.IntMap.Base.IntMap a)
instance GHC.Classes.Ord a => Data.MonoTraversable.MonoFoldableOrd (Data.Semigroup.Option a)
instance GHC.Classes.Ord a => Data.MonoTraversable.MonoFoldableOrd (Data.List.NonEmpty.NonEmpty a)
instance GHC.Classes.Ord a => Data.MonoTraversable.MonoFoldableOrd (Data.Functor.Identity.Identity a)
instance GHC.Classes.Ord v => Data.MonoTraversable.MonoFoldableOrd (Data.Map.Base.Map k v)
instance GHC.Classes.Ord v => Data.MonoTraversable.MonoFoldableOrd (Data.HashMap.Base.HashMap k v)
instance GHC.Classes.Ord a => Data.MonoTraversable.MonoFoldableOrd (Data.Vector.Vector a)
instance GHC.Classes.Ord e => Data.MonoTraversable.MonoFoldableOrd (Data.Set.Base.Set e)
instance GHC.Classes.Ord e => Data.MonoTraversable.MonoFoldableOrd (Data.HashSet.HashSet e)
instance (Data.Vector.Unboxed.Base.Unbox a, GHC.Classes.Ord a) => Data.MonoTraversable.MonoFoldableOrd (Data.Vector.Unboxed.Base.Vector a)
instance (GHC.Classes.Ord a, Foreign.Storable.Storable a) => Data.MonoTraversable.MonoFoldableOrd (Data.Vector.Storable.Vector a)
instance GHC.Classes.Ord b => Data.MonoTraversable.MonoFoldableOrd (Data.Either.Either a b)
instance GHC.Classes.Ord a => Data.MonoTraversable.MonoFoldableOrd (Data.DList.DList a)
instance GHC.Classes.Ord b => Data.MonoTraversable.MonoFoldableOrd (a, b)
instance GHC.Classes.Ord a => Data.MonoTraversable.MonoFoldableOrd (Control.Applicative.Const m a)
instance (GHC.Classes.Ord a, Data.Foldable.Foldable f) => Data.MonoTraversable.MonoFoldableOrd (Control.Monad.Trans.Maybe.MaybeT f a)
instance (GHC.Classes.Ord a, Data.Foldable.Foldable f) => Data.MonoTraversable.MonoFoldableOrd (Control.Monad.Trans.List.ListT f a)
instance (GHC.Classes.Ord a, Data.Foldable.Foldable f) => Data.MonoTraversable.MonoFoldableOrd (Control.Monad.Trans.Identity.IdentityT f a)
instance (GHC.Classes.Ord a, Data.Foldable.Foldable f) => Data.MonoTraversable.MonoFoldableOrd (Control.Monad.Trans.Writer.Lazy.WriterT w f a)
instance (GHC.Classes.Ord a, Data.Foldable.Foldable f) => Data.MonoTraversable.MonoFoldableOrd (Control.Monad.Trans.Writer.Strict.WriterT w f a)
instance (GHC.Classes.Ord a, Data.Foldable.Foldable f) => Data.MonoTraversable.MonoFoldableOrd (Control.Monad.Trans.Error.ErrorT e f a)
instance (GHC.Classes.Ord a, Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.MonoTraversable.MonoFoldableOrd (Data.Functor.Compose.Compose f g a)
instance (GHC.Classes.Ord a, Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.MonoTraversable.MonoFoldableOrd (Data.Functor.Product.Product f g a)
instance Data.MonoTraversable.MonoTraversable Data.ByteString.Internal.ByteString
instance Data.MonoTraversable.MonoTraversable Data.ByteString.Lazy.Internal.ByteString
instance Data.MonoTraversable.MonoTraversable Data.Text.Internal.Text
instance Data.MonoTraversable.MonoTraversable Data.Text.Internal.Lazy.Text
instance Data.MonoTraversable.MonoTraversable [a]
instance Data.MonoTraversable.MonoTraversable (GHC.Base.Maybe a)
instance Data.MonoTraversable.MonoTraversable (Data.Tree.Tree a)
instance Data.MonoTraversable.MonoTraversable (Data.Sequence.Seq a)
instance Data.MonoTraversable.MonoTraversable (Data.Sequence.ViewL a)
instance Data.MonoTraversable.MonoTraversable (Data.Sequence.ViewR a)
instance Data.MonoTraversable.MonoTraversable (Data.IntMap.Base.IntMap a)
instance Data.MonoTraversable.MonoTraversable (Data.Semigroup.Option a)
instance Data.MonoTraversable.MonoTraversable (Data.List.NonEmpty.NonEmpty a)
instance Data.MonoTraversable.MonoTraversable (Data.DList.DList a)
instance Data.MonoTraversable.MonoTraversable (Data.Functor.Identity.Identity a)
instance Data.MonoTraversable.MonoTraversable (Data.Map.Base.Map k v)
instance Data.MonoTraversable.MonoTraversable (Data.HashMap.Base.HashMap k v)
instance Data.MonoTraversable.MonoTraversable (Data.Vector.Vector a)
instance Data.Vector.Unboxed.Base.Unbox a => Data.MonoTraversable.MonoTraversable (Data.Vector.Unboxed.Base.Vector a)
instance Foreign.Storable.Storable a => Data.MonoTraversable.MonoTraversable (Data.Vector.Storable.Vector a)
instance Data.MonoTraversable.MonoTraversable (Data.Either.Either a b)
instance Data.MonoTraversable.MonoTraversable (a, b)
instance Data.MonoTraversable.MonoTraversable (Control.Applicative.Const m a)
instance Data.Traversable.Traversable f => Data.MonoTraversable.MonoTraversable (Control.Monad.Trans.Maybe.MaybeT f a)
instance Data.Traversable.Traversable f => Data.MonoTraversable.MonoTraversable (Control.Monad.Trans.List.ListT f a)
instance Data.Traversable.Traversable f => Data.MonoTraversable.MonoTraversable (Control.Monad.Trans.Identity.IdentityT f a)
instance Data.Traversable.Traversable f => Data.MonoTraversable.MonoTraversable (Control.Monad.Trans.Writer.Lazy.WriterT w f a)
instance Data.Traversable.Traversable f => Data.MonoTraversable.MonoTraversable (Control.Monad.Trans.Writer.Strict.WriterT w f a)
instance Data.Traversable.Traversable f => Data.MonoTraversable.MonoTraversable (Control.Monad.Trans.Error.ErrorT e f a)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.MonoTraversable.MonoTraversable (Data.Functor.Compose.Compose f g a)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.MonoTraversable.MonoTraversable (Data.Functor.Product.Product f g a)
instance Data.MonoTraversable.MonoPointed Data.ByteString.Internal.ByteString
instance Data.MonoTraversable.MonoPointed Data.ByteString.Lazy.Internal.ByteString
instance Data.MonoTraversable.MonoPointed Data.Text.Internal.Text
instance Data.MonoTraversable.MonoPointed Data.Text.Internal.Lazy.Text
instance Data.MonoTraversable.MonoPointed [a]
instance Data.MonoTraversable.MonoPointed (GHC.Base.Maybe a)
instance Data.MonoTraversable.MonoPointed (Data.Semigroup.Option a)
instance Data.MonoTraversable.MonoPointed (Data.List.NonEmpty.NonEmpty a)
instance Data.MonoTraversable.MonoPointed (Data.Functor.Identity.Identity a)
instance Data.MonoTraversable.MonoPointed (Data.Vector.Vector a)
instance Data.MonoTraversable.MonoPointed (Data.DList.DList a)
instance Data.MonoTraversable.MonoPointed (GHC.Types.IO a)
instance Data.MonoTraversable.MonoPointed (Control.Applicative.ZipList a)
instance Data.MonoTraversable.MonoPointed (r -> a)
instance GHC.Base.Monoid a => Data.MonoTraversable.MonoPointed (a, b)
instance GHC.Base.Monoid m => Data.MonoTraversable.MonoPointed (Control.Applicative.Const m a)
instance GHC.Base.Monad m => Data.MonoTraversable.MonoPointed (Control.Applicative.WrappedMonad m a)
instance GHC.Base.Applicative m => Data.MonoTraversable.MonoPointed (Control.Monad.Trans.List.ListT m a)
instance GHC.Base.Applicative m => Data.MonoTraversable.MonoPointed (Control.Monad.Trans.Identity.IdentityT m a)
instance GHC.Base.Applicative f => Data.MonoTraversable.MonoPointed (Data.Functor.Bind.Class.WrappedApplicative f a)
instance Control.Arrow.Arrow a => Data.MonoTraversable.MonoPointed (Control.Applicative.WrappedArrow a b c)
instance (GHC.Base.Monoid w, GHC.Base.Applicative m) => Data.MonoTraversable.MonoPointed (Control.Monad.Trans.Writer.Lazy.WriterT w m a)
instance (GHC.Base.Monoid w, GHC.Base.Applicative m) => Data.MonoTraversable.MonoPointed (Control.Monad.Trans.Writer.Strict.WriterT w m a)
instance GHC.Base.Applicative m => Data.MonoTraversable.MonoPointed (Control.Monad.Trans.Reader.ReaderT r m a)
instance Data.MonoTraversable.MonoPointed (Control.Monad.Trans.Cont.ContT r m a)
instance (GHC.Base.Applicative f, GHC.Base.Applicative g) => Data.MonoTraversable.MonoPointed (Data.Functor.Compose.Compose f g a)
instance (GHC.Base.Applicative f, GHC.Base.Applicative g) => Data.MonoTraversable.MonoPointed (Data.Functor.Product.Product f g a)
instance Data.MonoTraversable.MonoPointed (Control.Comonad.Cokleisli w a b)
instance GHC.Base.Applicative f => Data.MonoTraversable.MonoPointed (Data.Semigroupoid.Static.Static f a b)
instance Data.MonoTraversable.MonoPointed (Data.Sequence.Seq a)
instance Data.Vector.Unboxed.Base.Unbox a => Data.MonoTraversable.MonoPointed (Data.Vector.Unboxed.Base.Vector a)
instance Foreign.Storable.Storable a => Data.MonoTraversable.MonoPointed (Data.Vector.Storable.Vector a)
instance Data.MonoTraversable.MonoPointed (Data.Either.Either a b)
instance Data.MonoTraversable.MonoPointed Data.IntSet.Base.IntSet
instance Data.MonoTraversable.MonoPointed (Data.Set.Base.Set a)
instance Data.Hashable.Class.Hashable a => Data.MonoTraversable.MonoPointed (Data.HashSet.HashSet a)
instance GHC.Base.Applicative m => Data.MonoTraversable.MonoPointed (Control.Monad.Trans.Error.ErrorT e m a)
instance Data.MonoTraversable.MonoPointed (Data.Functor.Bind.Class.MaybeApply f a)
instance GHC.Base.Applicative f => Data.MonoTraversable.MonoPointed (Control.Monad.Trans.Maybe.MaybeT f a)
instance (GHC.Base.Monoid w, GHC.Base.Applicative m) => Data.MonoTraversable.MonoPointed (Control.Monad.Trans.RWS.Lazy.RWST r w s m a)
instance (GHC.Base.Monoid w, GHC.Base.Applicative m) => Data.MonoTraversable.MonoPointed (Control.Monad.Trans.RWS.Strict.RWST r w s m a)
instance GHC.Base.Applicative m => Data.MonoTraversable.MonoPointed (Control.Monad.Trans.State.Lazy.StateT s m a)
instance GHC.Base.Applicative m => Data.MonoTraversable.MonoPointed (Control.Monad.Trans.State.Strict.StateT s m a)
instance Data.MonoTraversable.MonoPointed (Data.Sequence.ViewL a)
instance Data.MonoTraversable.MonoPointed (Data.Sequence.ViewR a)
instance Data.MonoTraversable.MonoPointed (Data.Tree.Tree a)
instance Data.MonoTraversable.MonoComonad (Data.Tree.Tree a)
instance Data.MonoTraversable.MonoComonad (Data.List.NonEmpty.NonEmpty a)
instance Data.MonoTraversable.MonoComonad (Data.Functor.Identity.Identity a)
instance GHC.Base.Monoid m => Data.MonoTraversable.MonoComonad (m -> a)
instance Data.MonoTraversable.MonoComonad (e, a)
instance Data.MonoTraversable.MonoComonad (Data.Semigroup.Arg a b)
instance Control.Comonad.Comonad w => Data.MonoTraversable.MonoComonad (Control.Monad.Trans.Identity.IdentityT w a)
instance Control.Comonad.Comonad w => Data.MonoTraversable.MonoComonad (Control.Comonad.Trans.Env.EnvT e w a)
instance Control.Comonad.Comonad w => Data.MonoTraversable.MonoComonad (Control.Comonad.Trans.Store.StoreT s w a)
instance (Control.Comonad.Comonad w, GHC.Base.Monoid m) => Data.MonoTraversable.MonoComonad (Control.Comonad.Trans.Traced.TracedT m w a)
instance (Control.Comonad.Comonad f, Control.Comonad.Comonad g) => Data.MonoTraversable.MonoComonad (Data.Functor.Coproduct.Coproduct f g a)
instance Data.MonoTraversable.MonoComonad (Data.Sequence.ViewL a)
instance Data.MonoTraversable.MonoComonad (Data.Sequence.ViewR a)


-- | Warning: This module should be considered highly experimental.
module Data.Containers

-- | A container whose values are stored in Key-Value pairs.
class (Monoid set, Semigroup set, MonoFoldable set, Eq (ContainerKey set), GrowingAppend set) => SetContainer set where type family ContainerKey set

-- | Check if there is a value with the supplied key in the container.
member :: SetContainer set => ContainerKey set -> set -> Bool

-- | Check if there isn't a value with the supplied key in the container.
notMember :: SetContainer set => ContainerKey set -> set -> Bool

-- | Get the union of two containers.
union :: SetContainer set => set -> set -> set

-- | Get the difference of two containers.
difference :: SetContainer set => set -> set -> set

-- | Get the intersection of two containers.
intersection :: SetContainer set => set -> set -> set

-- | Get a list of all of the keys in the container.
keys :: SetContainer set => set -> [ContainerKey set]

-- | This instance uses the functions from <a>Data.Map.Strict</a>.

-- | This instance uses the functions from <a>Data.HashMap.Strict</a>.

-- | This instance uses the functions from <a>Data.IntMap.Strict</a>.

-- | A guaranteed-polymorphic <tt>Map</tt>, which allows for more
--   polymorphic versions of functions.
class PolyMap map

-- | Get the difference between two maps, using the left map's values.
differenceMap :: PolyMap map => map value1 -> map value2 -> map value1

-- | Get the intersection of two maps, using the left map's values.
intersectionMap :: PolyMap map => map value1 -> map value2 -> map value1

-- | Get the intersection of two maps with a supplied function that takes
--   in the left map's value and the right map's value.
intersectionWithMap :: PolyMap map => (value1 -> value2 -> value3) -> map value1 -> map value2 -> map value3

-- | This instance uses the functions from <a>Data.Map.Strict</a>.

-- | This instance uses the functions from <a>Data.HashMap.Strict</a>.

-- | This instance uses the functions from <a>Data.IntMap.Strict</a>.

-- | A <tt>Map</tt> type polymorphic in both its key and value.
class BiPolyMap map where type family BPMKeyConstraint map key :: Constraint
mapKeysWith :: (BiPolyMap map, BPMKeyConstraint map k1, BPMKeyConstraint map k2) => (v -> v -> v) -> (k1 -> k2) -> map k1 v -> map k2 v

-- | Polymorphic typeclass for interacting with different map types
class (MonoTraversable map, SetContainer map) => IsMap map where type family MapValue map findWithDefault def key = fromMaybe def . lookup key insertWith f k v m = v' `seq` insertMap k v' m where v' = case lookup k m of { Nothing -> v Just vold -> f v vold } insertWithKey f k v m = v' `seq` insertMap k v' m where v' = case lookup k m of { Nothing -> v Just vold -> f k v vold } insertLookupWithKey f k v m = v' `seq` (mold, insertMap k v' m) where (mold, v') = case lookup k m of { Nothing -> (Nothing, v) Just vold -> (Just vold, f k v vold) } adjustMap f k m = case lookup k m of { Nothing -> m Just v -> let v' = f v in v' `seq` insertMap k v' m } adjustWithKey f k m = case lookup k m of { Nothing -> m Just v -> let v' = f k v in v' `seq` insertMap k v' m } updateMap f k m = case lookup k m of { Nothing -> m Just v -> case f v of { Nothing -> deleteMap k m Just v' -> v' `seq` insertMap k v' m } } updateWithKey f k m = case lookup k m of { Nothing -> m Just v -> case f k v of { Nothing -> deleteMap k m Just v' -> v' `seq` insertMap k v' m } } updateLookupWithKey f k m = case lookup k m of { Nothing -> (Nothing, m) Just v -> case f k v of { Nothing -> (Just v, deleteMap k m) Just v' -> v' `seq` (Just v', insertMap k v' m) } } alterMap f k m = case f mold of { Nothing -> case mold of { Nothing -> m Just _ -> deleteMap k m } Just v -> insertMap k v m } where mold = lookup k m unionWith f x y = mapFromList $ loop $ mapToList x ++ mapToList y where loop [] = [] loop ((k, v) : rest) = case lookup k rest of { Nothing -> (k, v) : loop rest Just v' -> (k, f v v') : loop (deleteMap k rest) } unionWithKey f x y = mapFromList $ loop $ mapToList x ++ mapToList y where loop [] = [] loop ((k, v) : rest) = case lookup k rest of { Nothing -> (k, v) : loop rest Just v' -> (k, f k v v') : loop (deleteMap k rest) } unionsWith _ [] = mempty unionsWith _ [x] = x unionsWith f (x : y : z) = unionsWith f (unionWith f x y : z) mapWithKey f = mapFromList . map go . mapToList where go (k, v) = (k, f k v) omapKeysWith g f = mapFromList . unionsWith g . map go . mapToList where go (k, v) = [(f k, v)]

-- | Look up a value in a map with a specified key.
lookup :: IsMap map => ContainerKey map -> map -> Maybe (MapValue map)

-- | Insert a key-value pair into a map.
insertMap :: IsMap map => ContainerKey map -> MapValue map -> map -> map

-- | Delete a key-value pair of a map using a specified key.
deleteMap :: IsMap map => ContainerKey map -> map -> map

-- | Create a map from a single key-value pair.
singletonMap :: IsMap map => ContainerKey map -> MapValue map -> map

-- | Convert a list of key-value pairs to a map
mapFromList :: IsMap map => [(ContainerKey map, MapValue map)] -> map

-- | Convert a map to a list of key-value pairs.
mapToList :: IsMap map => map -> [(ContainerKey map, MapValue map)]

-- | Like <a>lookup</a>, but uses a default value when the key does not
--   exist in the map.
findWithDefault :: IsMap map => MapValue map -> ContainerKey map -> map -> MapValue map

-- | Insert a key-value pair into a map.
--   
--   Inserts the value directly if the key does not exist in the map.
--   Otherwise, apply a supplied function that accepts the new value and
--   the previous value and insert that result into the map.
insertWith :: IsMap map => (MapValue map -> MapValue map -> MapValue map) -> ContainerKey map -> MapValue map -> map -> map

-- | Insert a key-value pair into a map.
--   
--   Inserts the value directly if the key does not exist in the map.
--   Otherwise, apply a supplied function that accepts the key, the new
--   value, and the previous value and insert that result into the map.
insertWithKey :: IsMap map => (ContainerKey map -> MapValue map -> MapValue map -> MapValue map) -> ContainerKey map -> MapValue map -> map -> map

-- | Insert a key-value pair into a map, return the previous key's value if
--   it existed.
--   
--   Inserts the value directly if the key does not exist in the map.
--   Otherwise, apply a supplied function that accepts the key, the new
--   value, and the previous value and insert that result into the map.
insertLookupWithKey :: IsMap map => (ContainerKey map -> MapValue map -> MapValue map -> MapValue map) -> ContainerKey map -> MapValue map -> map -> (Maybe (MapValue map), map)

-- | Apply a function to the value of a given key.
--   
--   Returns the input map when the key-value pair does not exist.
adjustMap :: IsMap map => (MapValue map -> MapValue map) -> ContainerKey map -> map -> map

-- | Equivalent to <a>adjustMap</a>, but the function accepts the key, as
--   well as the previous value.
adjustWithKey :: IsMap map => (ContainerKey map -> MapValue map -> MapValue map) -> ContainerKey map -> map -> map

-- | Apply a function to the value of a given key.
--   
--   If the function returns <a>Nothing</a>, this deletes the key-value
--   pair.
--   
--   Returns the input map when the key-value pair does not exist.
updateMap :: IsMap map => (MapValue map -> Maybe (MapValue map)) -> ContainerKey map -> map -> map

-- | Equivalent to <a>updateMap</a>, but the function accepts the key, as
--   well as the previous value.
updateWithKey :: IsMap map => (ContainerKey map -> MapValue map -> Maybe (MapValue map)) -> ContainerKey map -> map -> map

-- | Apply a function to the value of a given key.
--   
--   If the map does not contain the key this returns <a>Nothing</a> and
--   the input map.
--   
--   If the map does contain the key but the function returns
--   <a>Nothing</a>, this returns the previous value and the map with the
--   key-value pair removed.
--   
--   If the map contains the key and the function returns a value, this
--   returns the new value and the map with the key-value pair with the new
--   value.
updateLookupWithKey :: IsMap map => (ContainerKey map -> MapValue map -> Maybe (MapValue map)) -> ContainerKey map -> map -> (Maybe (MapValue map), map)

-- | Update/Delete the value of a given key.
--   
--   Applies a function to previous value of a given key, if it results in
--   <a>Nothing</a> delete the key-value pair from the map, otherwise
--   replace the previous value with the new value.
alterMap :: IsMap map => (Maybe (MapValue map) -> Maybe (MapValue map)) -> ContainerKey map -> map -> map

-- | Combine two maps.
--   
--   When a key exists in both maps, apply a function to both of the values
--   and use the result of that as the value of the key in the resulting
--   map.
unionWith :: IsMap map => (MapValue map -> MapValue map -> MapValue map) -> map -> map -> map
unionWithKey :: IsMap map => (ContainerKey map -> MapValue map -> MapValue map -> MapValue map) -> map -> map -> map

-- | Combine a list of maps.
--   
--   When a key exists in two different maps, apply a function to both of
--   the values and use the result of that as the value of the key in the
--   resulting map.
unionsWith :: IsMap map => (MapValue map -> MapValue map -> MapValue map) -> [map] -> map

-- | Apply a function over every key-value pair of a map.
mapWithKey :: IsMap map => (ContainerKey map -> MapValue map -> MapValue map) -> map -> map

-- | Apply a function over every key of a pair and run <a>unionsWith</a>
--   over the results.
omapKeysWith :: IsMap map => (MapValue map -> MapValue map -> MapValue map) -> (ContainerKey map -> ContainerKey map) -> map -> map

-- | This instance uses the functions from <a>Data.Map.Strict</a>.

-- | This instance uses the functions from <a>Data.HashMap.Strict</a>.

-- | This instance uses the functions from <a>Data.IntMap.Strict</a>.

-- | Polymorphic typeclass for interacting with different set types
class (SetContainer set, Element set ~ ContainerKey set) => IsSet set

-- | Insert a value into a set.
insertSet :: IsSet set => Element set -> set -> set

-- | Delete a value from a set.
deleteSet :: IsSet set => Element set -> set -> set

-- | Create a set from a single element.
singletonSet :: IsSet set => Element set -> set

-- | Convert a list to a set.
setFromList :: IsSet set => [Element set] -> set

-- | Convert a set to a list.
setToList :: IsSet set => set -> [Element set]

-- | Zip operations on <a>MonoFunctor</a>s.
class MonoFunctor mono => MonoZip mono

-- | Combine each element of two <a>MonoZip</a>s using a supplied function.
ozipWith :: MonoZip mono => (Element mono -> Element mono -> Element mono) -> mono -> mono -> mono

-- | Take two <a>MonoZip</a>s and return a list of the pairs of their
--   elements.
ozip :: MonoZip mono => mono -> mono -> [(Element mono, Element mono)]

-- | Take a list of pairs of elements and return a <a>MonoZip</a> of the
--   first components and a <a>MonoZip</a> of the second components.
ounzip :: MonoZip mono => [(Element mono, Element mono)] -> (mono, mono)

-- | Type class for maps whose keys can be converted into sets.
class SetContainer set => HasKeysSet set where type family KeySet set

-- | Convert a map into a set of its keys.
keysSet :: HasKeysSet set => set -> KeySet set
instance GHC.Classes.Ord k => Data.Containers.SetContainer (Data.Map.Base.Map k v)
instance (GHC.Classes.Eq key, Data.Hashable.Class.Hashable key) => Data.Containers.SetContainer (Data.HashMap.Base.HashMap key value)
instance Data.Containers.SetContainer (Data.IntMap.Base.IntMap value)
instance GHC.Classes.Ord element => Data.Containers.SetContainer (Data.Set.Base.Set element)
instance (GHC.Classes.Eq element, Data.Hashable.Class.Hashable element) => Data.Containers.SetContainer (Data.HashSet.HashSet element)
instance Data.Containers.SetContainer Data.IntSet.Base.IntSet
instance GHC.Classes.Eq key => Data.Containers.SetContainer [(key, value)]
instance GHC.Classes.Ord key => Data.Containers.PolyMap (Data.Map.Base.Map key)
instance (GHC.Classes.Eq key, Data.Hashable.Class.Hashable key) => Data.Containers.PolyMap (Data.HashMap.Base.HashMap key)
instance Data.Containers.PolyMap Data.IntMap.Base.IntMap
instance Data.Containers.BiPolyMap Data.Map.Base.Map
instance Data.Containers.BiPolyMap Data.HashMap.Base.HashMap
instance GHC.Classes.Ord key => Data.Containers.IsMap (Data.Map.Base.Map key value)
instance (GHC.Classes.Eq key, Data.Hashable.Class.Hashable key) => Data.Containers.IsMap (Data.HashMap.Base.HashMap key value)
instance Data.Containers.IsMap (Data.IntMap.Base.IntMap value)
instance GHC.Classes.Eq key => Data.Containers.IsMap [(key, value)]
instance GHC.Classes.Ord element => Data.Containers.IsSet (Data.Set.Base.Set element)
instance (GHC.Classes.Eq element, Data.Hashable.Class.Hashable element) => Data.Containers.IsSet (Data.HashSet.HashSet element)
instance Data.Containers.IsSet Data.IntSet.Base.IntSet
instance Data.Containers.MonoZip Data.ByteString.Internal.ByteString
instance Data.Containers.MonoZip Data.ByteString.Lazy.Internal.ByteString
instance Data.Containers.MonoZip Data.Text.Internal.Text
instance Data.Containers.MonoZip Data.Text.Internal.Lazy.Text
instance GHC.Classes.Ord k => Data.Containers.HasKeysSet (Data.Map.Base.Map k v)
instance Data.Containers.HasKeysSet (Data.IntMap.Base.IntMap v)
instance (Data.Hashable.Class.Hashable k, GHC.Classes.Eq k) => Data.Containers.HasKeysSet (Data.HashMap.Base.HashMap k v)


-- | Warning: This module should be considered highly experimental.
module Data.Sequences

-- | <a>SemiSequence</a> was created to share code between
--   <a>IsSequence</a> and <tt>MinLen</tt>.
--   
--   <tt>Semi</tt> means <tt>SemiGroup</tt> A <a>SemiSequence</a> can
--   accomodate a <tt>SemiGroup</tt> such as <tt>NonEmpty</tt> or
--   <tt>MinLen</tt> A Monoid should be able to fill out <a>IsSequence</a>.
--   
--   <a>SemiSequence</a> operations maintain the same type because they all
--   maintain the same number of elements or increase them. However, a
--   decreasing function such as filter may change they type. For example,
--   from <tt>NonEmpty</tt> to '[]' This type-changing function exists on
--   <tt>NonNull</tt> as <tt>nfilter</tt>
--   
--   <a>filter</a> and other such functions are placed in <a>IsSequence</a>
class (Integral (Index seq), GrowingAppend seq) => SemiSequence seq where type family Index seq

-- | <a>intersperse</a> takes an element and intersperses that element
--   between the elements of the sequence.
--   
--   <pre>
--   &gt; <a>intersperse</a> ',' "abcde"
--   "a,b,c,d,e"
--   </pre>
intersperse :: SemiSequence seq => Element seq -> seq -> seq

-- | Reverse a sequence
--   
--   <pre>
--   &gt; <a>reverse</a> "hello world"
--   "dlrow olleh"
--   </pre>
reverse :: SemiSequence seq => seq -> seq

-- | <a>find</a> takes a predicate and a sequence and returns the first
--   element in the sequence matching the predicate, or <a>Nothing</a> if
--   there isn't an element that matches the predicate.
--   
--   <pre>
--   &gt; <a>find</a> (== 5) [1 .. 10]
--   <a>Just</a> 5
--   
--   &gt; <a>find</a> (== 15) [1 .. 10]
--   <a>Nothing</a>
--   </pre>
find :: SemiSequence seq => (Element seq -> Bool) -> seq -> Maybe (Element seq)

-- | Sort a sequence using an supplied element ordering function.
--   
--   <pre>
--   &gt; let compare' x y = case <a>compare</a> x y of LT -&gt; GT; EQ -&gt; EQ; GT -&gt; LT
--   &gt; <a>sortBy</a> compare' [5,3,6,1,2,4]
--   [6,5,4,3,2,1]
--   </pre>
sortBy :: SemiSequence seq => (Element seq -> Element seq -> Ordering) -> seq -> seq

-- | Prepend an element onto a sequence.
--   
--   <pre>
--   &gt; 4 `<a>cons</a>` [1,2,3]
--   [4,1,2,3]
--   </pre>
cons :: SemiSequence seq => Element seq -> seq -> seq

-- | Append an element onto a sequence.
--   
--   <pre>
--   &gt; [1,2,3] `<a>snoc</a>` 4
--   [1,2,3,4]
--   </pre>
snoc :: SemiSequence seq => seq -> Element seq -> seq

-- | Create a sequence from a single element.
--   
--   <pre>
--   &gt; <a>singleton</a> <tt>a</tt> :: <tt>String</tt>
--   "a"
--   &gt; <a>singleton</a> <tt>a</tt> :: <tt>Vector</tt> <a>Char</a>
--   <a>fromList</a> "a"
--   </pre>
singleton :: IsSequence seq => Element seq -> seq

-- | Sequence Laws:
--   
--   <pre>
--   <a>fromList</a> . <a>otoList</a> = <a>id</a>
--   <a>fromList</a> (x &lt;&gt; y) = <a>fromList</a> x &lt;&gt; <a>fromList</a> y
--   <a>otoList</a> (<a>fromList</a> x &lt;&gt; <a>fromList</a> y) = x &lt;&gt; y
--   </pre>
class (Monoid seq, MonoTraversable seq, SemiSequence seq, MonoPointed seq) => IsSequence seq where fromList = mconcat . fmap singleton break f = (fromList *** fromList) . break f . otoList span f = (fromList *** fromList) . span f . otoList dropWhile f = fromList . dropWhile f . otoList takeWhile f = fromList . takeWhile f . otoList splitAt i = (fromList *** fromList) . genericSplitAt i . otoList unsafeSplitAt i seq = (unsafeTake i seq, unsafeDrop i seq) take i = fst . splitAt i unsafeTake = take drop i = snd . splitAt i unsafeDrop = drop partition f = (fromList *** fromList) . partition f . otoList uncons = fmap (second fromList) . uncons . otoList unsnoc = fmap (first fromList) . unsnoc . otoList filter f = fromList . filter f . otoList filterM f = liftM fromList . filterM f . otoList replicate i = fromList . genericReplicate i replicateM i = liftM fromList . replicateM (fromIntegral i) groupBy f = fmap fromList . groupBy f . otoList groupAllOn f = fmap fromList . groupAllOn f . otoList subsequences = map fromList . subsequences . otoList permutations = map fromList . permutations . otoList tailEx = snd . maybe (error "Data.Sequences.tailEx") id . uncons initEx = fst . maybe (error "Data.Sequences.initEx") id . unsnoc unsafeTail = tailEx unsafeInit = initEx index seq' idx = headMay (drop idx seq') indexEx seq' idx = maybe (error "Data.Sequences.indexEx") id (index seq' idx) unsafeIndex = indexEx intercalate = defaultIntercalate splitWhen = defaultSplitWhen

-- | Convert a list to a sequence.
--   
--   <pre>
--   &gt; <a>fromList</a> [<tt>a</tt>, <tt>b</tt>, <tt>c</tt>] :: Text
--   "abc"
--   </pre>
fromList :: IsSequence seq => [Element seq] -> seq

-- | <a>break</a> applies a predicate to a sequence, and returns a tuple
--   where the first element is the longest prefix (possibly empty) of
--   elements that <i>do not satisfy</i> the predicate. The second element
--   of the tuple is the remainder of the sequence.
--   
--   <tt><a>break</a> p</tt> is equivalent to <tt><a>span</a> (<tt>not</tt>
--   . p)</tt>
--   
--   <pre>
--   &gt; <a>break</a> (&gt; 3) (<a>fromList</a> [1,2,3,4,1,2,3,4] :: <tt>Vector</tt> <a>Int</a>)
--   (fromList [1,2,3],fromList [4,1,2,3,4])
--   
--   &gt; <a>break</a> (&lt; <tt>z</tt>) (<a>fromList</a> "abc" :: <tt>Text</tt>)
--   ("","abc")
--   
--   &gt; <a>break</a> (&gt; <tt>z</tt>) (<a>fromList</a> "abc" :: <tt>Text</tt>)
--   ("abc","")
--   </pre>
break :: IsSequence seq => (Element seq -> Bool) -> seq -> (seq, seq)

-- | <a>span</a> applies a predicate to a sequence, and returns a tuple
--   where the first element is the longest prefix (possibly empty) that
--   <i>does satisfy</i> the predicate. The second element of the tuple is
--   the remainder of the sequence.
--   
--   <tt><a>span</a> p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>
--   
--   <pre>
--   &gt; <a>span</a> (&lt; 3) (<a>fromList</a> [1,2,3,4,1,2,3,4] :: <tt>Vector</tt> <a>Int</a>)
--   (fromList [1,2],fromList [3,4,1,2,3,4])
--   
--   &gt; <a>span</a> (&lt; <tt>z</tt>) (<a>fromList</a> "abc" :: <tt>Text</tt>)
--   ("abc","")
--   
--   &gt; <a>span</a> (&lt; 0) <a>1,2,3</a>
--   </pre>
span :: IsSequence seq => (Element seq -> Bool) -> seq -> (seq, seq)

-- | <a>dropWhile</a> returns the suffix remaining after <a>takeWhile</a>.
--   
--   <pre>
--   &gt; <a>dropWhile</a> (&lt; 3) [1,2,3,4,5,1,2,3]
--   [3,4,5,1,2,3]
--   
--   &gt; <a>dropWhile</a> (&lt; <tt>z</tt>) (<a>fromList</a> "abc" :: <tt>Text</tt>)
--   ""
--   </pre>
dropWhile :: IsSequence seq => (Element seq -> Bool) -> seq -> seq

-- | <a>takeWhile</a> applies a predicate to a sequence, and returns the
--   longest prefix (possibly empty) of the sequence of elements that
--   <i>satisfy</i> the predicate.
--   
--   <pre>
--   &gt; <a>takeWhile</a> (&lt; 3) [1,2,3,4,5,1,2,3]
--   [1,2]
--   
--   &gt; <a>takeWhile</a> (&lt; <tt>z</tt>) (<a>fromList</a> "abc" :: <tt>Text</tt>)
--   "abc"
--   </pre>
takeWhile :: IsSequence seq => (Element seq -> Bool) -> seq -> seq

-- | <tt><a>splitAt</a> n se</tt> returns a tuple where the first element
--   is the prefix of the sequence <tt>se</tt> with length <tt>n</tt>, and
--   the second element is the remainder of the sequence.
--   
--   <pre>
--   &gt; <a>splitAt</a> 6 "Hello world!"
--   ("Hello ","world!")
--   
--   &gt; <a>splitAt</a> 3 (<a>fromList</a> [1,2,3,4,5] :: <tt>Vector</tt> <a>Int</a>)
--   (fromList [1,2,3],fromList [4,5])
--   </pre>
splitAt :: IsSequence seq => Index seq -> seq -> (seq, seq)

-- | Equivalent to <a>splitAt</a>.
unsafeSplitAt :: IsSequence seq => Index seq -> seq -> (seq, seq)

-- | <tt><a>take</a> n</tt> returns the prefix of a sequence of length
--   <tt>n</tt>, or the sequence itself if <tt>n &gt; <a>olength</a>
--   seq</tt>.
--   
--   <pre>
--   &gt; <a>take</a> 3 "abcdefg"
--   "abc"
--   &gt; <a>take</a> 4 (<a>fromList</a> [1,2,3,4,5,6] :: <tt>Vector</tt> <a>Int</a>)
--   fromList [1,2,3,4]
--   </pre>
take :: IsSequence seq => Index seq -> seq -> seq

-- | Equivalent to <a>take</a>.
unsafeTake :: IsSequence seq => Index seq -> seq -> seq

-- | <tt><a>drop</a> n</tt> returns the suffix of a sequence after the
--   first <tt>n</tt> elements, or an empty sequence if <tt>n &gt;
--   <a>olength</a> seq</tt>.
--   
--   <pre>
--   &gt; <a>drop</a> 3 "abcdefg"
--   "defg"
--   &gt; <a>drop</a> 4 (<a>fromList</a> [1,2,3,4,5,6] :: <tt>Vector</tt> <a>Int</a>)
--   fromList [5,6]
--   </pre>
drop :: IsSequence seq => Index seq -> seq -> seq

-- | Equivalent to <a>drop</a>
unsafeDrop :: IsSequence seq => Index seq -> seq -> seq

-- | <a>partition</a> takes a predicate and a sequence and returns the pair
--   of sequences of elements which do and do not satisfy the predicate.
--   
--   <pre>
--   <a>partition</a> p se = (<a>filter</a> p se, <a>filter</a> (<tt>not</tt> . p) se)
--   </pre>
partition :: IsSequence seq => (Element seq -> Bool) -> seq -> (seq, seq)

-- | <a>uncons</a> returns the tuple of the first element of a sequence and
--   the rest of the sequence, or <a>Nothing</a> if the sequence is empty.
--   
--   <pre>
--   &gt; <a>uncons</a> (<a>fromList</a> [1,2,3,4] :: <tt>Vector</tt> <a>Int</a>)
--   <a>Just</a> (1,fromList [2,3,4])
--   
--   &gt; <a>uncons</a> ([] :: [<a>Int</a>])
--   <a>Nothing</a>
--   </pre>
uncons :: IsSequence seq => seq -> Maybe (Element seq, seq)

-- | <a>unsnoc</a> returns the tuple of the init of a sequence and the last
--   element, or <a>Nothing</a> if the sequence is empty.
--   
--   <pre>
--   &gt; <a>uncons</a> (<a>fromList</a> [1,2,3,4] :: <tt>Vector</tt> <a>Int</a>)
--   <a>Just</a> (fromList [1,2,3],4)
--   
--   &gt; <a>uncons</a> ([] :: [<a>Int</a>])
--   <a>Nothing</a>
--   </pre>
unsnoc :: IsSequence seq => seq -> Maybe (seq, Element seq)

-- | <a>filter</a> given a predicate returns a sequence of all elements
--   that satisfy the predicate.
--   
--   <pre>
--   &gt; <a>filter</a> (&lt; 5) [1 .. 10]
--   [1,2,3,4]
--   </pre>
filter :: IsSequence seq => (Element seq -> Bool) -> seq -> seq

-- | The monadic version of <a>filter</a>.
filterM :: (IsSequence seq, Monad m) => (Element seq -> m Bool) -> seq -> m seq

-- | <tt><a>replicate</a> n x</tt> is a sequence of length <tt>n</tt> with
--   <tt>x</tt> as the value of every element.
--   
--   <pre>
--   &gt; <a>replicate</a> 10 <tt>a</tt> :: Text
--   "aaaaaaaaaa"
--   </pre>
replicate :: IsSequence seq => Index seq -> Element seq -> seq

-- | The monadic version of <a>replicateM</a>.
replicateM :: (IsSequence seq, Monad m) => Index seq -> m (Element seq) -> m seq

-- | <a>group</a> takes a sequence and returns a list of sequences such
--   that the concatenation of the result is equal to the argument. Each
--   subsequence in the result contains only equal elements, using the
--   supplied equality test.
--   
--   <pre>
--   &gt; <a>groupBy</a> (==) <a>Mississippi</a>
--   [<a>M</a>,"i","ss","i","ss","i","pp","i"]
--   </pre>
groupBy :: IsSequence seq => (Element seq -> Element seq -> Bool) -> seq -> [seq]

-- | Similar to standard <a>groupBy</a>, but operates on the whole
--   collection, not just the consecutive items.
groupAllOn :: (IsSequence seq, Eq b) => (Element seq -> b) -> seq -> [seq]

-- | <a>subsequences</a> returns a list of all subsequences of the
--   argument.
--   
--   <pre>
--   &gt; <a>subsequences</a> "abc"
--   ["","a","b","ab","c","ac","bc","abc"]
--   </pre>
subsequences :: IsSequence seq => seq -> [seq]

-- | <a>permutations</a> returns a list of all permutations of the
--   argument.
--   
--   <pre>
--   &gt; <a>permutations</a> "abc"
--   ["abc","bac","cba","bca","cab","acb"]
--   </pre>
permutations :: IsSequence seq => seq -> [seq]

-- | <b>Unsafe</b>
--   
--   Get the tail of a sequence, throw an exception if the sequence is
--   empty.
--   
--   <pre>
--   &gt; <a>tailEx</a> [1,2,3]
--   [2,3]
--   </pre>
tailEx :: IsSequence seq => seq -> seq

-- | <b>Unsafe</b>
--   
--   Get the init of a sequence, throw an exception if the sequence is
--   empty.
--   
--   <pre>
--   &gt; <a>initEx</a> [1,2,3]
--   [1,2]
--   </pre>
initEx :: IsSequence seq => seq -> seq

-- | Equivalent to <a>tailEx</a>.
unsafeTail :: IsSequence seq => seq -> seq

-- | Equivalent to <a>initEx</a>.
unsafeInit :: IsSequence seq => seq -> seq

-- | Get the element of a sequence at a certain index, returns
--   <a>Nothing</a> if that index does not exist.
--   
--   <pre>
--   &gt; <a>index</a> (<a>fromList</a> [1,2,3] :: <tt>Vector</tt> <a>Int</a>) 1
--   <a>Just</a> 2
--   &gt; <a>index</a> (<a>fromList</a> [1,2,3] :: <tt>Vector</tt> <a>Int</a>) 4
--   <a>Nothing</a>
--   </pre>
index :: IsSequence seq => seq -> Index seq -> Maybe (Element seq)

-- | <b>Unsafe</b>
--   
--   Get the element of a sequence at a certain index, throws an exception
--   if the index does not exist.
indexEx :: IsSequence seq => seq -> Index seq -> Element seq

-- | Equivalent to <a>indexEx</a>.
unsafeIndex :: IsSequence seq => seq -> Index seq -> Element seq

-- | <a>intercalate</a> <tt>seq seqs</tt> inserts <tt>seq</tt> in between
--   <tt>seqs</tt> and concatenates the result.
--   
--   Since 0.9.3
intercalate :: IsSequence seq => seq -> [seq] -> seq

-- | <a>splitWhen</a> splits a sequence into components delimited by
--   separators, where the predicate returns True for a separator element.
--   The resulting components do not contain the separators. Two adjacent
--   separators result in an empty component in the output. The number of
--   resulting components is greater by one than number of separators.
--   
--   Since 0.9.3
splitWhen :: IsSequence seq => (Element seq -> Bool) -> seq -> [seq]

-- | Use <a>Data.List</a>'s implementation of <a>find</a>.
defaultFind :: MonoFoldable seq => (Element seq -> Bool) -> seq -> Maybe (Element seq)

-- | Use <a>Data.List</a>'s implementation of <a>intersperse</a>.
defaultIntersperse :: IsSequence seq => Element seq -> seq -> seq

-- | Use <a>Data.List</a>'s implementation of <a>reverse</a>.
defaultReverse :: IsSequence seq => seq -> seq

-- | Use <a>Data.List</a>'s implementation of <a>sortBy</a>.
defaultSortBy :: IsSequence seq => (Element seq -> Element seq -> Ordering) -> seq -> seq

-- | Default <a>intercalate</a>
defaultIntercalate :: (IsSequence seq) => seq -> [seq] -> seq

-- | Use <a>splitWhen</a> from <a>Data.List.Split</a>
defaultSplitWhen :: IsSequence seq => (Element seq -> Bool) -> seq -> [seq]

-- | Sort a vector using an supplied element ordering function.
vectorSortBy :: Vector v e => (e -> e -> Ordering) -> v e -> v e

-- | Sort a vector.
vectorSort :: (Vector v e, Ord e) => v e -> v e

-- | Use <a>Data.List</a>'s <a>:</a> to prepend an element to a sequence.
defaultCons :: IsSequence seq => Element seq -> seq -> seq

-- | Use <a>Data.List</a>'s <a>++</a> to append an element to a sequence.
defaultSnoc :: IsSequence seq => seq -> Element seq -> seq

-- | like Data.List.tail, but an input of <a>mempty</a> returns
--   <a>mempty</a>
tailDef :: IsSequence seq => seq -> seq

-- | like Data.List.init, but an input of <a>mempty</a> returns
--   <a>mempty</a>
initDef :: IsSequence seq => seq -> seq

-- | A typeclass for sequences whose elements have the <a>Eq</a> typeclass
class (MonoFoldableEq seq, IsSequence seq, Eq (Element seq)) => EqSequence seq where splitElem x = splitWhen (== x) splitSeq = defaultSplitOn stripPrefix x y = fmap fromList (otoList x `stripPrefix` otoList y) stripSuffix x y = fmap fromList (otoList x `stripSuffix` otoList y) isPrefixOf x y = otoList x `isPrefixOf` otoList y isSuffixOf x y = otoList x `isSuffixOf` otoList y isInfixOf x y = otoList x `isInfixOf` otoList y group = groupBy (==) groupAll = groupAllOn id

-- | <tt><a>splitElem</a></tt> splits a sequence into components delimited
--   by separator element. It's equivalent to <a>splitWhen</a> with
--   equality predicate:
--   
--   <pre>
--   splitElem sep === splitWhen (== sep)
--   </pre>
--   
--   Since 0.9.3
splitElem :: EqSequence seq => Element seq -> seq -> [seq]

-- | <tt><a>splitSeq</a></tt> splits a sequence into components delimited
--   by separator subsequence. <a>splitSeq</a> is the right inverse of
--   <a>intercalate</a>:
--   
--   <pre>
--   intercalate x . splitSeq x === id
--   </pre>
--   
--   <a>splitElem</a> can be considered a special case of <a>splitSeq</a>
--   
--   <pre>
--   splitSeq (singleton sep) === splitElem sep
--   </pre>
--   
--   <tt><a>splitSeq</a> mempty</tt> is another special case: it splits
--   just before each element, and in line with <a>splitWhen</a> rules, it
--   has at least one output component:
--   
--   <pre>
--   &gt; <a>splitSeq</a> "" ""
--   [""]
--   &gt; <a>splitSeq</a> "" "a"
--   ["", "a"]
--   &gt; <a>splitSeq</a> "" "ab"
--   ["", "a", "b"]
--   </pre>
--   
--   Since 0.9.3
splitSeq :: EqSequence seq => seq -> seq -> [seq]

-- | <a>stripPrefix</a> drops the given prefix from a sequence. It returns
--   <a>Nothing</a> if the sequence did not start with the prefix given, or
--   <a>Just</a> the sequence after the prefix, if it does.
--   
--   <pre>
--   &gt; <a>stripPrefix</a> "foo" "foobar"
--   <a>Just</a> "foo"
--   &gt; <a>stripPrefix</a> "abc" "foobar"
--   <a>Nothing</a>
--   </pre>
stripPrefix :: EqSequence seq => seq -> seq -> Maybe seq

-- | <a>stripSuffix</a> drops the given suffix from a sequence. It returns
--   <a>Nothing</a> if the sequence did not end with the suffix given, or
--   <a>Just</a> the sequence before the suffix, if it does.
--   
--   <pre>
--   &gt; <a>stripSuffix</a> "bar" "foobar"
--   <a>Just</a> "foo"
--   &gt; <a>stripSuffix</a> "abc" "foobar"
--   <a>Nothing</a>
--   </pre>
stripSuffix :: EqSequence seq => seq -> seq -> Maybe seq

-- | <a>isPrefixOf</a> takes two sequences and returns <a>True</a> if the
--   first sequence is a prefix of the second.
isPrefixOf :: EqSequence seq => seq -> seq -> Bool

-- | <a>isSuffixOf</a> takes two sequences and returns <a>True</a> if the
--   first sequence is a suffix of the second.
isSuffixOf :: EqSequence seq => seq -> seq -> Bool

-- | <a>isInfixOf</a> takes two sequences and returns <tt>true</tt> if the
--   first sequence is contained, wholly and intact, anywhere within the
--   second.
isInfixOf :: EqSequence seq => seq -> seq -> Bool

-- | Equivalent to <tt><a>groupBy</a> (==)</tt>
group :: EqSequence seq => seq -> [seq]

-- | Similar to standard <a>group</a>, but operates on the whole
--   collection, not just the consecutive items.
--   
--   Equivalent to <tt><a>groupAllOn</a> id</tt>
groupAll :: EqSequence seq => seq -> [seq]

-- | <i>Deprecated: use oelem</i>
elem :: EqSequence seq => Element seq -> seq -> Bool

-- | <i>Deprecated: use onotElem</i>
notElem :: EqSequence seq => Element seq -> seq -> Bool

-- | Use <tt>splitOn</tt> from <a>Data.List.Split</a>
defaultSplitOn :: EqSequence s => s -> s -> [s]

-- | A typeclass for sequences whose elements have the <a>Ord</a> typeclass
class (EqSequence seq, MonoFoldableOrd seq) => OrdSequence seq where sort = fromList . sort . otoList

-- | Sort a ordered sequence.
--   
--   <pre>
--   &gt; <a>sort</a> [4,3,1,2]
--   [1,2,3,4]
--   </pre>
sort :: OrdSequence seq => seq -> seq

-- | A typeclass for sequences whose elements are <a>Char</a>s.
class (IsSequence t, IsString t, Element t ~ Char) => Textual t where breakWord = fmap (dropWhile isSpace) . break isSpace breakLine = (killCR *** drop 1) . break (== '\n') where killCR t = case unsnoc t of { Just (t', '\r') -> t' _ -> t }

-- | Break up a textual sequence into a list of words, which were delimited
--   by white space.
--   
--   <pre>
--   &gt; <a>words</a> "abc  def ghi"
--   ["abc","def","ghi"]
--   </pre>
words :: Textual t => t -> [t]

-- | Join a list of textual sequences using seperating spaces.
--   
--   <pre>
--   &gt; <a>unwords</a> ["abc","def","ghi"]
--   "abc def ghi"
--   </pre>
unwords :: Textual t => [t] -> t

-- | Break up a textual sequence at newline characters.
--   
--   <pre>
--   &gt; <a>lines</a> "hello\nworld"
--   ["hello","world"]
--   </pre>
lines :: Textual t => t -> [t]

-- | Join a list of textual sequences using newlines.
--   
--   <pre>
--   &gt; <a>unlines</a> ["abc","def","ghi"]
--   "abc\ndef\nghi"
--   </pre>
unlines :: Textual t => [t] -> t

-- | Convert a textual sequence to lower-case.
--   
--   <pre>
--   &gt; <a>toLower</a> "HELLO WORLD"
--   "hello world"
--   </pre>
toLower :: Textual t => t -> t

-- | Convert a textual sequence to upper-case.
--   
--   <pre>
--   &gt; <a>toUpper</a> "hello world"
--   "HELLO WORLD"
--   </pre>
toUpper :: Textual t => t -> t

-- | Convert a textual sequence to folded-case.
--   
--   Slightly different from <a>toLower</a>, see
--   <tt><a>Data.Text</a>.<a>toCaseFold</a></tt>
toCaseFold :: Textual t => t -> t

-- | Split a textual sequence into two parts, split at the first space.
--   
--   <pre>
--   &gt; <a>breakWord</a> "hello world"
--   ("hello","world")
--   </pre>
breakWord :: Textual t => t -> (t, t)

-- | Split a textual sequence into two parts, split at the newline.
--   
--   <pre>
--   &gt; <a>breakLine</a> "abc\ndef"
--   ("abc","def")
--   </pre>
breakLine :: Textual t => t -> (t, t)

-- | Takes all of the <a>Just</a> values from a sequence of <tt>Maybe
--   t</tt>s and concatenates them into an unboxed sequence of <tt>t</tt>s.
--   
--   Since 0.6.2
catMaybes :: (IsSequence (f (Maybe t)), Functor f, Element (f (Maybe t)) ~ Maybe t) => f (Maybe t) -> f t

-- | Same as <tt>sortBy . comparing</tt>.
--   
--   Since 0.7.0
sortOn :: (Ord o, SemiSequence seq) => (Element seq -> o) -> seq -> seq
instance Data.Sequences.SemiSequence [a]
instance Data.Sequences.IsSequence [a]
instance Data.Sequences.SemiSequence (Data.List.NonEmpty.NonEmpty a)
instance Data.Sequences.SemiSequence Data.ByteString.Internal.ByteString
instance Data.Sequences.IsSequence Data.ByteString.Internal.ByteString
instance Data.Sequences.SemiSequence Data.Text.Internal.Text
instance Data.Sequences.IsSequence Data.Text.Internal.Text
instance Data.Sequences.SemiSequence Data.ByteString.Lazy.Internal.ByteString
instance Data.Sequences.IsSequence Data.ByteString.Lazy.Internal.ByteString
instance Data.Sequences.SemiSequence Data.Text.Internal.Lazy.Text
instance Data.Sequences.IsSequence Data.Text.Internal.Lazy.Text
instance Data.Sequences.SemiSequence (Data.Sequence.Seq a)
instance Data.Sequences.IsSequence (Data.Sequence.Seq a)
instance Data.Sequences.SemiSequence (Data.DList.DList a)
instance Data.Sequences.IsSequence (Data.DList.DList a)
instance Data.Sequences.SemiSequence (Data.Vector.Vector a)
instance Data.Sequences.IsSequence (Data.Vector.Vector a)
instance Data.Vector.Unboxed.Base.Unbox a => Data.Sequences.SemiSequence (Data.Vector.Unboxed.Base.Vector a)
instance Data.Vector.Unboxed.Base.Unbox a => Data.Sequences.IsSequence (Data.Vector.Unboxed.Base.Vector a)
instance Foreign.Storable.Storable a => Data.Sequences.SemiSequence (Data.Vector.Storable.Vector a)
instance Foreign.Storable.Storable a => Data.Sequences.IsSequence (Data.Vector.Storable.Vector a)
instance GHC.Classes.Eq a => Data.Sequences.EqSequence [a]
instance Data.Sequences.EqSequence Data.ByteString.Internal.ByteString
instance Data.Sequences.EqSequence Data.ByteString.Lazy.Internal.ByteString
instance Data.Sequences.EqSequence Data.Text.Internal.Text
instance Data.Sequences.EqSequence Data.Text.Internal.Lazy.Text
instance GHC.Classes.Eq a => Data.Sequences.EqSequence (Data.Sequence.Seq a)
instance GHC.Classes.Eq a => Data.Sequences.EqSequence (Data.Vector.Vector a)
instance (GHC.Classes.Eq a, Data.Vector.Unboxed.Base.Unbox a) => Data.Sequences.EqSequence (Data.Vector.Unboxed.Base.Vector a)
instance (GHC.Classes.Eq a, Foreign.Storable.Storable a) => Data.Sequences.EqSequence (Data.Vector.Storable.Vector a)
instance GHC.Classes.Ord a => Data.Sequences.OrdSequence [a]
instance Data.Sequences.OrdSequence Data.ByteString.Internal.ByteString
instance Data.Sequences.OrdSequence Data.ByteString.Lazy.Internal.ByteString
instance Data.Sequences.OrdSequence Data.Text.Internal.Text
instance Data.Sequences.OrdSequence Data.Text.Internal.Lazy.Text
instance GHC.Classes.Ord a => Data.Sequences.OrdSequence (Data.Sequence.Seq a)
instance GHC.Classes.Ord a => Data.Sequences.OrdSequence (Data.Vector.Vector a)
instance (GHC.Classes.Ord a, Data.Vector.Unboxed.Base.Unbox a) => Data.Sequences.OrdSequence (Data.Vector.Unboxed.Base.Vector a)
instance (GHC.Classes.Ord a, Foreign.Storable.Storable a) => Data.Sequences.OrdSequence (Data.Vector.Storable.Vector a)
instance (c ~ GHC.Types.Char) => Data.Sequences.Textual [c]
instance Data.Sequences.Textual Data.Text.Internal.Text
instance Data.Sequences.Textual Data.Text.Internal.Lazy.Text

module Data.MinLen

-- | <a>Zero</a> is the base value for the Peano numbers.
data Zero
Zero :: Zero

-- | <a>Succ</a> represents the next number in the sequence of natural
--   numbers.
--   
--   It takes a <tt>nat</tt> (a natural number) as an argument.
--   
--   <a>Zero</a> is a <tt>nat</tt>, allowing <tt><a>Succ</a>
--   <a>Zero</a></tt> to represent 1.
--   
--   <a>Succ</a> is also a <tt>nat</tt>, so it can be applied to itself,
--   allowing <tt><a>Succ</a> (<a>Succ</a> <a>Zero</a>)</tt> to represent
--   2, <tt><a>Succ</a> (<a>Succ</a> (<a>Succ</a> <a>Zero</a>))</tt> to
--   represent 3, and so on.
data Succ nat
Succ :: nat -> Succ nat

-- | Type-level natural number utility typeclass
class TypeNat nat

-- | Turn a type-level natural number into a number
--   
--   <pre>
--   &gt; <a>toValueNat</a> <a>Zero</a>
--   0
--   &gt; <a>toValueNat</a> (<a>Succ</a> (<a>Succ</a> (<a>Succ</a> <a>Zero</a>)))
--   3
--   </pre>
toValueNat :: (TypeNat nat, Num i) => nat -> i

-- | Get a data representation of a natural number type
--   
--   <pre>
--   &gt; <a>typeNat</a> :: <a>Succ</a> (<a>Succ</a> <a>Zero</a>)
--   Succ (Succ Zero) -- Errors because Succ and Zero have no Show typeclass,
--                    -- But this is what it would look like if it did.
--   </pre>
typeNat :: TypeNat nat => nat

-- | Adds two type-level naturals.
--   
--   See the <a>mlappend</a> type signature for an example.
--   
--   <pre>
--   &gt; :t <a>typeNat</a> :: <a>AddNat</a> (<a>Succ</a> (<a>Succ</a> <a>Zero</a>)) (<a>Succ</a> <a>Zero</a>)
--   
--   <a>typeNat</a> :: <a>AddNat</a> (<a>Succ</a> (<a>Succ</a> <a>Zero</a>)) (<a>Succ</a> <a>Zero</a>)
--     :: <a>Succ</a> (<a>Succ</a> (<a>Succ</a> <a>Zero</a>))
--   </pre>

-- | Calculates the maximum of two type-level naturals.
--   
--   See the <a>mlunion</a> type signature for an example.
--   
--   <pre>
--   &gt; :t <a>typeNat</a> :: <a>MaxNat</a> (<a>Succ</a> (<a>Succ</a> <a>Zero</a>)) (<a>Succ</a> <a>Zero</a>)
--   
--   <a>typeNat</a> :: <a>MaxNat</a> (<a>Succ</a> (<a>Succ</a> <a>Zero</a>)) (<a>Succ</a> <a>Zero</a>)
--     :: <a>Succ</a> (<a>Succ</a> <a>Zero</a>)
--   </pre>

-- | A wrapper around a container which encodes its minimum length in the
--   type system. This allows functions like <a>head</a> and <a>maximum</a>
--   to be made safe without using <a>Maybe</a>.
--   
--   The length, <tt>nat</tt>, is encoded as a <a>Peano number</a>, which
--   starts with the <a>Zero</a> constructor and is made one larger with
--   each application of <a>Succ</a> (<a>Zero</a> for 0, <tt><a>Succ</a>
--   <a>Zero</a></tt> for 1, <tt><a>Succ</a> (<a>Succ</a> <a>Zero</a>)</tt>
--   for 2, etc.). Functions which require at least one element, then, are
--   typed with <tt>Succ nat</tt>, where <tt>nat</tt> is either <a>Zero</a>
--   or any number of applications of <a>Succ</a>:
--   
--   <pre>
--   <a>head</a> :: <a>MonoTraversable</a> mono =&gt; <a>MinLen</a> (<a>Succ</a> nat) mono -&gt; <a>Element</a> mono
--   </pre>
--   
--   The length is also a <a>phantom type</a>, i.e. it is only used on the
--   left hand side of the type and doesn't exist at runtime. Notice how
--   <tt><a>Succ</a> <a>Zero</a></tt> isn't included in the printed output:
--   
--   <pre>
--   &gt; <a>toMinLen</a> [1,2,3] :: <a>Maybe</a> (<a>MinLen</a> (<a>Succ</a> <a>Zero</a>) [<a>Int</a>])
--   <a>Just</a> (<a>MinLen</a> {unMinLen = [1,2,3]})
--   </pre>
--   
--   You can still use GHCI's <tt>:i</tt> command to see the phantom type
--   information:
--   
--   <pre>
--   &gt; let xs = <a>mlcons</a> 1 $ <a>toMinLenZero</a> []
--   &gt; :i xs
--   xs :: <a>Num</a> t =&gt; <a>MinLen</a> (<a>Succ</a> <a>Zero</a>) [t]
--   </pre>
data MinLen nat mono

-- | Get the monomorphic container out of a <a>MinLen</a> wrapper.
unMinLen :: MinLen nat mono -> mono

-- | Types a container as having a minimum length of zero. This is useful
--   when combined with other <a>MinLen</a> functions that increase the
--   size of the container.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; 1 `mlcons` <a>toMinLenZero</a> []
--   <a>MinLen</a> {unMinLen = [1]}
--   </pre>
toMinLenZero :: (MonoFoldable mono) => mono -> MinLen Zero mono

-- | Attempts to add a <a>MinLen</a> constraint to a monomorphic container.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = <a>toMinLen</a> [1,2,3] :: <a>Maybe</a> (<a>MinLen</a> (<a>Succ</a> <a>Zero</a>) [<a>Int</a>])
--   &gt; xs
--   <a>Just</a> (<a>MinLen</a> {unMinLen = [1,2,3]})
--   
--   &gt; :i xs
--   xs :: <a>Maybe</a> (<a>MinLen</a> (<a>Succ</a> <a>Zero</a>) [<a>Int</a>])
--   </pre>
--   
--   <pre>
--   &gt; <a>toMinLen</a> [] :: <a>Maybe</a> (<a>MinLen</a> (<a>Succ</a> <a>Zero</a>) [<a>Int</a>])
--   <a>Nothing</a>
--   </pre>
toMinLen :: (MonoFoldable mono, TypeNat nat) => mono -> Maybe (MinLen nat mono)

-- | <b>Unsafe</b>
--   
--   Although this function itself cannot cause a segfault, it breaks the
--   safety guarantees of <a>MinLen</a> and can lead to a segfault when
--   using otherwise safe functions.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = <a>unsafeToMinLen</a> [] :: <a>MinLen</a> (<a>Succ</a> <a>Zero</a>) [<a>Int</a>]
--   &gt; <a>olength</a> xs
--   0
--   &gt; <a>head</a> xs
--   *** Exception: Data.MonoTraversable.headEx: empty
--   </pre>
unsafeToMinLen :: mono -> MinLen nat mono

-- | Adds an element to the front of a list, increasing its minimum length
--   by 1.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = <a>unsafeToMinLen</a> [1,2,3] :: <a>MinLen</a> (<a>Succ</a> <a>Zero</a>) [<a>Int</a>]
--   &gt; 0 `mlcons` xs
--   <a>MinLen</a> {unMinLen = [0,1,2,3]}
--   </pre>
mlcons :: IsSequence seq => Element seq -> MinLen nat seq -> MinLen (Succ nat) seq

-- | Concatenate two sequences, adding their minimum lengths together.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = <a>unsafeToMinLen</a> [1,2,3] :: <a>MinLen</a> (<a>Succ</a> <a>Zero</a>) [<a>Int</a>]
--   &gt; xs `mlappend` xs
--   <a>MinLen</a> {unMinLen = [1,2,3,1,2,3]}
--   </pre>
mlappend :: IsSequence seq => MinLen x seq -> MinLen y seq -> MinLen (AddNat x y) seq

-- | Joins two semigroups, keeping the larger <a>MinLen</a> of the two.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = <a>unsafeToMinLen</a> [1] :: <a>MinLen</a> (<a>Succ</a> <a>Zero</a>) [<a>Int</a>]
--   &gt; let ys = xs `mlunion` xs
--   &gt; ys
--   <a>MinLen</a> {unMinLen = [1,1]}
--   
--   &gt; :i ys
--   ys :: <a>MinLen</a> (<a>Succ</a> <a>Zero</a>) [<a>Int</a>]
--   </pre>
mlunion :: GrowingAppend mono => MinLen x mono -> MinLen y mono -> MinLen (MaxNat x y) mono

-- | Return the first element of a monomorphic container.
--   
--   Safe version of <a>headEx</a>, only works on monomorphic containers
--   wrapped in a <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
head :: MonoFoldable mono => MinLen (Succ nat) mono -> Element mono

-- | Return the last element of a monomorphic container.
--   
--   Safe version of <a>lastEx</a>, only works on monomorphic containers
--   wrapped in a <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
last :: MonoFoldable mono => MinLen (Succ nat) mono -> Element mono

-- | Returns all but the first element of a sequence, reducing its
--   <a>MinLen</a> by 1.
--   
--   Safe, only works on sequences wrapped in a <tt><a>MinLen</a>
--   (<a>Succ</a> nat)</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = <a>toMinLen</a> [1,2,3] :: <a>Maybe</a> (<a>MinLen</a> (<a>Succ</a> <a>Zero</a>) [<a>Int</a>])
--   &gt; <a>fmap</a> <a>tailML</a> xs
--   <a>Just</a> (<a>MinLen</a> {unMinLen = [2,3]})
--   </pre>
tailML :: IsSequence seq => MinLen (Succ nat) seq -> MinLen nat seq

-- | Returns all but the last element of a sequence, reducing its
--   <a>MinLen</a> by 1.
--   
--   Safe, only works on sequences wrapped in a <tt><a>MinLen</a>
--   (<a>Succ</a> nat)</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = <a>toMinLen</a> [1,2,3] :: <a>Maybe</a> (<a>MinLen</a> (<a>Succ</a> <a>Zero</a>) [<a>Int</a>])
--   &gt; <a>fmap</a> <a>initML</a> xs
--   <a>Just</a> (<a>MinLen</a> {unMinLen = [1,2]})
--   </pre>
initML :: IsSequence seq => MinLen (Succ nat) seq -> MinLen nat seq

-- | olength (x &lt;&gt; y) &gt;= olength x + olength y
class (Semigroup mono, MonoFoldable mono) => GrowingAppend mono

-- | Map each element of a monomorphic container to a semigroup, and
--   combine the results.
--   
--   Safe version of <a>ofoldMap1Ex</a>, only works on monomorphic
--   containers wrapped in a <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = ("hello", 1 :: <tt>Integer</tt>) `mlcons` (" world", 2) `mlcons` (<a>toMinLenZero</a> [])
--   &gt; <a>ofoldMap1</a> <tt>fst</tt> xs
--   "hello world"
--   </pre>
ofoldMap1 :: (MonoFoldable mono, Semigroup m) => (Element mono -> m) -> MinLen (Succ nat) mono -> m

-- | Join a monomorphic container, whose elements are <a>Semigroup</a>s,
--   together.
--   
--   Safe, only works on monomorphic containers wrapped in a
--   <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = "a" `mlcons` "b" `mlcons` "c" `mlcons` (<a>toMinLenZero</a> [])
--   &gt; xs
--   <a>MinLen</a> {unMinLen = ["a","b","c"]}
--   
--   &gt; <a>ofold1</a> xs
--   "abc"
--   </pre>
ofold1 :: (MonoFoldable mono, Semigroup (Element mono)) => MinLen (Succ nat) mono -> Element mono

-- | Right-associative fold of a monomorphic container with no base
--   element.
--   
--   Safe version of <a>ofoldr1Ex</a>, only works on monomorphic containers
--   wrapped in a <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
--   
--   <pre>
--   <tt>foldr1</tt> f = <a>Prelude</a>.<a>foldr1</a> f . <a>otoList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = "a" `mlcons` "b" `mlcons` "c" `mlcons` (<a>toMinLenZero</a> [])
--   &gt; <a>ofoldr1</a> (++) xs
--   "abc"
--   </pre>
ofoldr1 :: MonoFoldable mono => (Element mono -> Element mono -> Element mono) -> MinLen (Succ nat) mono -> Element mono

-- | Strict left-associative fold of a monomorphic container with no base
--   element.
--   
--   Safe version of <a>ofoldl1Ex'</a>, only works on monomorphic
--   containers wrapped in a <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
--   
--   <pre>
--   <tt>foldl1'</tt> f = <a>Prelude</a>.<a>foldl1'</a> f . <a>otoList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = "a" `mlcons` "b" `mlcons` "c" `mlcons` (<a>toMinLenZero</a> [])
--   &gt; <a>ofoldl1'</a> (++) xs
--   "abc"
--   </pre>
ofoldl1' :: MonoFoldable mono => (Element mono -> Element mono -> Element mono) -> MinLen (Succ nat) mono -> Element mono

-- | Get the maximum element of a monomorphic container.
--   
--   Safe version of <a>maximumEx</a>, only works on monomorphic containers
--   wrapped in a <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = <a>toMinLen</a> [1,2,3] :: <a>Maybe</a> (<a>MinLen</a> (<a>Succ</a> <a>Zero</a>) [<a>Int</a>])
--   &gt; <a>fmap</a> <a>maximum</a> xs
--   <a>Just</a> 3
--   </pre>
maximum :: MonoFoldableOrd mono => MinLen (Succ nat) mono -> Element mono

-- | Get the minimum element of a monomorphic container.
--   
--   Safe version of <a>minimumEx</a>, only works on monomorphic containers
--   wrapped in a <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = <a>toMinLen</a> [1,2,3] :: <a>Maybe</a> (<a>MinLen</a> (<a>Succ</a> <a>Zero</a>) [<a>Int</a>])
--   &gt; <a>fmap</a> <a>minimum</a> xs
--   <a>Just</a> 1
--   </pre>
minimum :: MonoFoldableOrd mono => MinLen (Succ nat) mono -> Element mono

-- | Get the maximum element of a monomorphic container, using a supplied
--   element ordering function.
--   
--   Safe version of <a>maximumByEx</a>, only works on monomorphic
--   containers wrapped in a <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
maximumBy :: MonoFoldable mono => (Element mono -> Element mono -> Ordering) -> MinLen (Succ nat) mono -> Element mono

-- | Get the minimum element of a monomorphic container, using a supplied
--   element ordering function.
--   
--   Safe version of <a>minimumByEx</a>, only works on monomorphic
--   containers wrapped in a <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
minimumBy :: MonoFoldable mono => (Element mono -> Element mono -> Ordering) -> MinLen (Succ nat) mono -> Element mono
instance (Data.Data.Data nat, Data.Data.Data mono) => Data.Data.Data (Data.MinLen.MinLen nat mono)
instance GHC.Show.Show mono => GHC.Show.Show (Data.MinLen.MinLen nat mono)
instance GHC.Read.Read mono => GHC.Read.Read (Data.MinLen.MinLen nat mono)
instance GHC.Classes.Ord mono => GHC.Classes.Ord (Data.MinLen.MinLen nat mono)
instance GHC.Classes.Eq mono => GHC.Classes.Eq (Data.MinLen.MinLen nat mono)
instance Data.MonoTraversable.MonoFunctor mono => Data.MonoTraversable.MonoFunctor (Data.MinLen.MinLen nat mono)
instance Data.MonoTraversable.MonoFoldable mono => Data.MonoTraversable.MonoFoldable (Data.MinLen.MinLen nat mono)
instance Data.MonoTraversable.MonoFoldableEq mono => Data.MonoTraversable.MonoFoldableEq (Data.MinLen.MinLen nat mono)
instance Data.MonoTraversable.MonoFoldableOrd mono => Data.MonoTraversable.MonoFoldableOrd (Data.MinLen.MinLen nat mono)
instance Data.GrowingAppend.GrowingAppend mono => Data.GrowingAppend.GrowingAppend (Data.MinLen.MinLen nat mono)
instance Data.MinLen.TypeNat Data.MinLen.Zero
instance Data.MinLen.TypeNat nat => Data.MinLen.TypeNat (Data.MinLen.Succ nat)
instance Data.MonoTraversable.MonoTraversable mono => Data.MonoTraversable.MonoTraversable (Data.MinLen.MinLen nat mono)
instance Data.GrowingAppend.GrowingAppend mono => Data.Semigroup.Semigroup (Data.MinLen.MinLen nat mono)
instance Data.Sequences.SemiSequence seq => Data.Sequences.SemiSequence (Data.MinLen.MinLen nat seq)
instance Data.MonoTraversable.MonoPointed mono => Data.MonoTraversable.MonoPointed (Data.MinLen.MinLen Data.MinLen.Zero mono)
instance Data.MonoTraversable.MonoPointed mono => Data.MonoTraversable.MonoPointed (Data.MinLen.MinLen (Data.MinLen.Succ Data.MinLen.Zero) mono)
instance Data.Sequences.IsSequence mono => Data.MonoTraversable.MonoComonad (Data.MinLen.MinLen (Data.MinLen.Succ Data.MinLen.Zero) mono)


-- | Warning, this is Experimental!
--   
--   <a>Data.NonNull</a> attempts to extend the concepts from
--   <a>Data.List.NonEmpty</a> to any <a>MonoFoldable</a>.
--   
--   <a>NonNull</a> is a typeclass for a container with 1 or more elements.
--   <a>Data.List.NonEmpty</a> and 'NotEmpty a' are members of the
--   typeclass
module Data.NonNull

-- | A monomorphic container that is not null.
type NonNull mono = MinLen (Succ Zero) mono

-- | <b>Safely</b> convert from an <b>unsafe</b> monomorphic container to a
--   <b>safe</b> non-null monomorphic container.
fromNullable :: MonoFoldable mono => mono -> Maybe (NonNull mono)

-- | <b>Unsafely</b> convert from an <b>unsafe</b> monomorphic container to
--   a <b>safe</b> non-null monomorphic container.
--   
--   Throws an exception if the monomorphic container is empty.
nonNull :: MonoFoldable mono => mono -> NonNull mono

-- | <b>Safely</b> convert from a non-null monomorphic container to a
--   nullable monomorphic container.
toNullable :: NonNull mono -> mono

-- | <b>Safely</b> convert from a <tt>NonEmpty</tt> list to a non-null
--   monomorphic container.
fromNonEmpty :: IsSequence seq => NonEmpty (Element seq) -> NonNull seq

-- | Prepend an element to a <a>SemiSequence</a>, creating a non-null
--   <a>SemiSequence</a>.
--   
--   Generally this uses cons underneath. cons is not efficient for most
--   data structures.
--   
--   Alternatives:
--   
--   <ul>
--   <li>if you don't need to cons, use <a>fromNullable</a> or
--   <a>nonNull</a> if you can create your structure in one go.</li>
--   <li>if you need to cons, you might be able to start off with an
--   efficient data structure such as a <tt>NonEmpty</tt> List.
--   <tt>fronNonEmpty</tt> will convert that to your data structure using
--   the structure's fromList function.</li>
--   </ul>
ncons :: SemiSequence seq => Element seq -> seq -> NonNull seq

-- | Extract the first element of a sequnce and the rest of the non-null
--   sequence if it exists.
nuncons :: IsSequence seq => NonNull seq -> (Element seq, Maybe (NonNull seq))

-- | Same as <a>nuncons</a> with no guarantee that the rest of the sequence
--   is non-null.
splitFirst :: IsSequence seq => NonNull seq -> (Element seq, seq)

-- | Equivalent to <tt><a>Data.Sequence</a>.<a>filter</a></tt>, but works
--   on non-nullable sequences.
nfilter :: IsSequence seq => (Element seq -> Bool) -> NonNull seq -> seq

-- | Equivalent to <tt><a>Data.Sequence</a>.<a>filterM</a></tt>, but works
--   on non-nullable sequences.
nfilterM :: (Monad m, IsSequence seq) => (Element seq -> m Bool) -> NonNull seq -> m seq

-- | Equivalent to <tt><a>Data.Sequence</a>.<a>replicate</a></tt>
--   
--   <tt>i</tt> must be <tt>&gt; 0</tt>
--   
--   <tt>i &lt;= 0</tt> is treated the same as providing <tt>1</tt>
nReplicate :: IsSequence seq => Index seq -> Element seq -> NonNull seq

-- | Return the first element of a monomorphic container.
--   
--   Safe version of <a>headEx</a>, only works on monomorphic containers
--   wrapped in a <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
head :: MonoFoldable mono => MinLen (Succ nat) mono -> Element mono

-- | <b>Safe</b> version of <a>tailEx</a>, only working on non-nullable
--   sequences.
tail :: IsSequence seq => NonNull seq -> seq

-- | Return the last element of a monomorphic container.
--   
--   Safe version of <a>lastEx</a>, only works on monomorphic containers
--   wrapped in a <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
last :: MonoFoldable mono => MinLen (Succ nat) mono -> Element mono

-- | <b>Safe</b> version of <a>initEx</a>, only working on non-nullable
--   sequences.
init :: IsSequence seq => NonNull seq -> seq

-- | Map each element of a monomorphic container to a semigroup, and
--   combine the results.
--   
--   Safe version of <a>ofoldMap1Ex</a>, only works on monomorphic
--   containers wrapped in a <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = ("hello", 1 :: <tt>Integer</tt>) `mlcons` (" world", 2) `mlcons` (<a>toMinLenZero</a> [])
--   &gt; <a>ofoldMap1</a> <tt>fst</tt> xs
--   "hello world"
--   </pre>
ofoldMap1 :: (MonoFoldable mono, Semigroup m) => (Element mono -> m) -> MinLen (Succ nat) mono -> m

-- | Join a monomorphic container, whose elements are <a>Semigroup</a>s,
--   together.
--   
--   Safe, only works on monomorphic containers wrapped in a
--   <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = "a" `mlcons` "b" `mlcons` "c" `mlcons` (<a>toMinLenZero</a> [])
--   &gt; xs
--   <a>MinLen</a> {unMinLen = ["a","b","c"]}
--   
--   &gt; <a>ofold1</a> xs
--   "abc"
--   </pre>
ofold1 :: (MonoFoldable mono, Semigroup (Element mono)) => MinLen (Succ nat) mono -> Element mono

-- | Right-associative fold of a monomorphic container with no base
--   element.
--   
--   Safe version of <a>ofoldr1Ex</a>, only works on monomorphic containers
--   wrapped in a <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
--   
--   <pre>
--   <tt>foldr1</tt> f = <a>Prelude</a>.<a>foldr1</a> f . <a>otoList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = "a" `mlcons` "b" `mlcons` "c" `mlcons` (<a>toMinLenZero</a> [])
--   &gt; <a>ofoldr1</a> (++) xs
--   "abc"
--   </pre>
ofoldr1 :: MonoFoldable mono => (Element mono -> Element mono -> Element mono) -> MinLen (Succ nat) mono -> Element mono

-- | Strict left-associative fold of a monomorphic container with no base
--   element.
--   
--   Safe version of <a>ofoldl1Ex'</a>, only works on monomorphic
--   containers wrapped in a <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
--   
--   <pre>
--   <tt>foldl1'</tt> f = <a>Prelude</a>.<a>foldl1'</a> f . <a>otoList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = "a" `mlcons` "b" `mlcons` "c" `mlcons` (<a>toMinLenZero</a> [])
--   &gt; <a>ofoldl1'</a> (++) xs
--   "abc"
--   </pre>
ofoldl1' :: MonoFoldable mono => (Element mono -> Element mono -> Element mono) -> MinLen (Succ nat) mono -> Element mono

-- | Get the maximum element of a monomorphic container.
--   
--   Safe version of <a>maximumEx</a>, only works on monomorphic containers
--   wrapped in a <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = <a>toMinLen</a> [1,2,3] :: <a>Maybe</a> (<a>MinLen</a> (<a>Succ</a> <a>Zero</a>) [<a>Int</a>])
--   &gt; <a>fmap</a> <a>maximum</a> xs
--   <a>Just</a> 3
--   </pre>
maximum :: MonoFoldableOrd mono => MinLen (Succ nat) mono -> Element mono

-- | Get the maximum element of a monomorphic container, using a supplied
--   element ordering function.
--   
--   Safe version of <a>maximumByEx</a>, only works on monomorphic
--   containers wrapped in a <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
maximumBy :: MonoFoldable mono => (Element mono -> Element mono -> Ordering) -> MinLen (Succ nat) mono -> Element mono

-- | Get the minimum element of a monomorphic container.
--   
--   Safe version of <a>minimumEx</a>, only works on monomorphic containers
--   wrapped in a <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = <a>toMinLen</a> [1,2,3] :: <a>Maybe</a> (<a>MinLen</a> (<a>Succ</a> <a>Zero</a>) [<a>Int</a>])
--   &gt; <a>fmap</a> <a>minimum</a> xs
--   <a>Just</a> 1
--   </pre>
minimum :: MonoFoldableOrd mono => MinLen (Succ nat) mono -> Element mono

-- | Get the minimum element of a monomorphic container, using a supplied
--   element ordering function.
--   
--   Safe version of <a>minimumByEx</a>, only works on monomorphic
--   containers wrapped in a <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
minimumBy :: MonoFoldable mono => (Element mono -> Element mono -> Ordering) -> MinLen (Succ nat) mono -> Element mono

-- | Prepend an element to a non-null <a>SemiSequence</a>.
(<|) :: SemiSequence seq => Element seq -> NonNull seq -> NonNull seq

-- | Specializes <a>fromNonEmpty</a> to lists only.
toMinList :: NonEmpty a -> NonNull [a]
instance GHC.Show.Show Data.NonNull.NullError
instance GHC.Exception.Exception Data.NonNull.NullError
