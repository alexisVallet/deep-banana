-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Vector & affine spaces, linear maps, and derivatives
--   
--   <i>vector-space</i> provides classes and generic operations for vector
--   spaces and affine spaces. It also defines a type of infinite towers of
--   generalized derivatives. A generalized derivative is a linear
--   transformation rather than one of the common concrete representations
--   (scalars, vectors, matrices, ...).
--   
--   <i>Warning</i>: this package depends on type families working fairly
--   well, requiring GHC version at least 6.9.
--   
--   Project wiki page: <a>http://haskell.org/haskellwiki/vector-space</a>
--   
--   Â© 2008-2012 by Conal Elliott; BSD3 license.
@package vector-space
@version 0.10.3


-- | Groups: zero, addition, and negation (additive inverse)
module Data.AdditiveGroup

-- | Additive group <tt>v</tt>.
class AdditiveGroup v where v ^-^ v' = v ^+^ negateV v'

-- | The zero element: identity for '(^+^)'
zeroV :: AdditiveGroup v => v

-- | Add vectors
(^+^) :: AdditiveGroup v => v -> v -> v

-- | Additive inverse
negateV :: AdditiveGroup v => v -> v

-- | Group subtraction
(^-^) :: AdditiveGroup v => v -> v -> v

-- | Sum over several vectors
sumV :: (Foldable f, AdditiveGroup v) => f v -> v

-- | Monoid under group addition. Alternative to the <tt>Sum</tt> in
--   <a>Data.Monoid</a>, which uses <a>Num</a> instead of
--   <a>AdditiveGroup</a>.
newtype Sum a
Sum :: a -> Sum a
[getSum] :: Sum a -> a

-- | Application a unary function inside a <a>Sum</a>
inSum :: (a -> b) -> (Sum a -> Sum b)

-- | Application a binary function inside a <a>Sum</a>
inSum2 :: (a -> b -> c) -> (Sum a -> Sum b -> Sum c)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.AdditiveGroup.Sum a)
instance GHC.Show.Show a => GHC.Show.Show (Data.AdditiveGroup.Sum a)
instance GHC.Read.Read a => GHC.Read.Read (Data.AdditiveGroup.Sum a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.AdditiveGroup.Sum a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.AdditiveGroup.Sum a)
instance Data.AdditiveGroup.AdditiveGroup ()
instance Data.AdditiveGroup.AdditiveGroup GHC.Types.Int
instance Data.AdditiveGroup.AdditiveGroup GHC.Integer.Type.Integer
instance Data.AdditiveGroup.AdditiveGroup GHC.Types.Float
instance Data.AdditiveGroup.AdditiveGroup GHC.Types.Double
instance Data.AdditiveGroup.AdditiveGroup Foreign.C.Types.CSChar
instance Data.AdditiveGroup.AdditiveGroup Foreign.C.Types.CInt
instance Data.AdditiveGroup.AdditiveGroup Foreign.C.Types.CShort
instance Data.AdditiveGroup.AdditiveGroup Foreign.C.Types.CLong
instance Data.AdditiveGroup.AdditiveGroup Foreign.C.Types.CLLong
instance Data.AdditiveGroup.AdditiveGroup Foreign.C.Types.CIntMax
instance Data.AdditiveGroup.AdditiveGroup Foreign.C.Types.CFloat
instance Data.AdditiveGroup.AdditiveGroup Foreign.C.Types.CDouble
instance GHC.Real.Integral a => Data.AdditiveGroup.AdditiveGroup (GHC.Real.Ratio a)
instance (GHC.Float.RealFloat v, Data.AdditiveGroup.AdditiveGroup v) => Data.AdditiveGroup.AdditiveGroup (Data.Complex.Complex v)
instance (Data.AdditiveGroup.AdditiveGroup u, Data.AdditiveGroup.AdditiveGroup v) => Data.AdditiveGroup.AdditiveGroup (u, v)
instance (Data.AdditiveGroup.AdditiveGroup u, Data.AdditiveGroup.AdditiveGroup v, Data.AdditiveGroup.AdditiveGroup w) => Data.AdditiveGroup.AdditiveGroup (u, v, w)
instance (Data.AdditiveGroup.AdditiveGroup u, Data.AdditiveGroup.AdditiveGroup v, Data.AdditiveGroup.AdditiveGroup w, Data.AdditiveGroup.AdditiveGroup x) => Data.AdditiveGroup.AdditiveGroup (u, v, w, x)
instance Data.AdditiveGroup.AdditiveGroup v => Data.AdditiveGroup.AdditiveGroup (a -> v)
instance Data.AdditiveGroup.AdditiveGroup a => Data.AdditiveGroup.AdditiveGroup (GHC.Base.Maybe a)
instance (Data.MemoTrie.HasTrie u, Data.AdditiveGroup.AdditiveGroup v) => Data.AdditiveGroup.AdditiveGroup (u Data.MemoTrie.:->: v)
instance GHC.Base.Functor Data.AdditiveGroup.Sum
instance GHC.Base.Applicative Data.AdditiveGroup.Sum
instance Data.AdditiveGroup.AdditiveGroup a => GHC.Base.Monoid (Data.AdditiveGroup.Sum a)
instance Data.AdditiveGroup.AdditiveGroup a => Data.AdditiveGroup.AdditiveGroup (Data.AdditiveGroup.Sum a)


-- | Vector spaces
--   
--   This version uses associated types instead of fundeps and requires
--   ghc-6.10 or later
module Data.VectorSpace

-- | Vector space <tt>v</tt>.
class AdditiveGroup v => VectorSpace v where type family Scalar v :: *

-- | Scale a vector
(*^) :: VectorSpace v => Scalar v -> v -> v

-- | Vector divided by scalar
(^/) :: (VectorSpace v, s ~ Scalar v, Fractional s) => v -> s -> v

-- | Vector multiplied by scalar
(^*) :: (VectorSpace v, s ~ Scalar v) => v -> s -> v

-- | Adds inner (dot) products.
class (VectorSpace v, AdditiveGroup (Scalar v)) => InnerSpace v

-- | Inner/dot product
(<.>) :: InnerSpace v => v -> v -> Scalar v

-- | Linear interpolation between <tt>a</tt> (when <tt>t==0</tt>) and
--   <tt>b</tt> (when <tt>t==1</tt>).
lerp :: VectorSpace v => v -> v -> Scalar v -> v

-- | Linear combination of vectors
linearCombo :: VectorSpace v => [(v, Scalar v)] -> v

-- | Square of the length of a vector. Sometimes useful for efficiency. See
--   also <a>magnitude</a>.
magnitudeSq :: (InnerSpace v, s ~ Scalar v) => v -> s

-- | Length of a vector. See also <a>magnitudeSq</a>.
magnitude :: (InnerSpace v, s ~ Scalar v, Floating s) => v -> s

-- | Vector in same direction as given one but with length of one. If given
--   the zero vector, then return it.
normalized :: (InnerSpace v, s ~ Scalar v, Floating s) => v -> v

-- | <tt>project u v</tt> computes the projection of <tt>v</tt> onto
--   <tt>u</tt>.
project :: (InnerSpace v, s ~ Scalar v, Fractional s) => v -> v -> v
instance Data.VectorSpace.VectorSpace GHC.Types.Int
instance Data.VectorSpace.InnerSpace GHC.Types.Int
instance Data.VectorSpace.VectorSpace GHC.Integer.Type.Integer
instance Data.VectorSpace.InnerSpace GHC.Integer.Type.Integer
instance Data.VectorSpace.VectorSpace GHC.Types.Double
instance Data.VectorSpace.InnerSpace GHC.Types.Double
instance Data.VectorSpace.VectorSpace GHC.Types.Float
instance Data.VectorSpace.InnerSpace GHC.Types.Float
instance Data.VectorSpace.VectorSpace Foreign.C.Types.CSChar
instance Data.VectorSpace.InnerSpace Foreign.C.Types.CSChar
instance Data.VectorSpace.VectorSpace Foreign.C.Types.CInt
instance Data.VectorSpace.InnerSpace Foreign.C.Types.CInt
instance Data.VectorSpace.VectorSpace Foreign.C.Types.CShort
instance Data.VectorSpace.InnerSpace Foreign.C.Types.CShort
instance Data.VectorSpace.VectorSpace Foreign.C.Types.CLong
instance Data.VectorSpace.InnerSpace Foreign.C.Types.CLong
instance Data.VectorSpace.VectorSpace Foreign.C.Types.CLLong
instance Data.VectorSpace.InnerSpace Foreign.C.Types.CLLong
instance Data.VectorSpace.VectorSpace Foreign.C.Types.CIntMax
instance Data.VectorSpace.InnerSpace Foreign.C.Types.CIntMax
instance Data.VectorSpace.VectorSpace Foreign.C.Types.CDouble
instance Data.VectorSpace.InnerSpace Foreign.C.Types.CDouble
instance Data.VectorSpace.VectorSpace Foreign.C.Types.CFloat
instance Data.VectorSpace.InnerSpace Foreign.C.Types.CFloat
instance GHC.Real.Integral a => Data.VectorSpace.VectorSpace (GHC.Real.Ratio a)
instance GHC.Real.Integral a => Data.VectorSpace.InnerSpace (GHC.Real.Ratio a)
instance (GHC.Float.RealFloat v, Data.VectorSpace.VectorSpace v) => Data.VectorSpace.VectorSpace (Data.Complex.Complex v)
instance (GHC.Float.RealFloat v, Data.VectorSpace.InnerSpace v) => Data.VectorSpace.InnerSpace (Data.Complex.Complex v)
instance (Data.VectorSpace.VectorSpace u, s ~ Data.VectorSpace.Scalar u, Data.VectorSpace.VectorSpace v, s ~ Data.VectorSpace.Scalar v) => Data.VectorSpace.VectorSpace (u, v)
instance (Data.VectorSpace.InnerSpace u, s ~ Data.VectorSpace.Scalar u, Data.VectorSpace.InnerSpace v, s ~ Data.VectorSpace.Scalar v) => Data.VectorSpace.InnerSpace (u, v)
instance (Data.VectorSpace.VectorSpace u, s ~ Data.VectorSpace.Scalar u, Data.VectorSpace.VectorSpace v, s ~ Data.VectorSpace.Scalar v, Data.VectorSpace.VectorSpace w, s ~ Data.VectorSpace.Scalar w) => Data.VectorSpace.VectorSpace (u, v, w)
instance (Data.VectorSpace.InnerSpace u, s ~ Data.VectorSpace.Scalar u, Data.VectorSpace.InnerSpace v, s ~ Data.VectorSpace.Scalar v, Data.VectorSpace.InnerSpace w, s ~ Data.VectorSpace.Scalar w) => Data.VectorSpace.InnerSpace (u, v, w)
instance (Data.VectorSpace.VectorSpace u, s ~ Data.VectorSpace.Scalar u, Data.VectorSpace.VectorSpace v, s ~ Data.VectorSpace.Scalar v, Data.VectorSpace.VectorSpace w, s ~ Data.VectorSpace.Scalar w, Data.VectorSpace.VectorSpace x, s ~ Data.VectorSpace.Scalar x) => Data.VectorSpace.VectorSpace (u, v, w, x)
instance (Data.VectorSpace.InnerSpace u, s ~ Data.VectorSpace.Scalar u, Data.VectorSpace.InnerSpace v, s ~ Data.VectorSpace.Scalar v, Data.VectorSpace.InnerSpace w, s ~ Data.VectorSpace.Scalar w, Data.VectorSpace.InnerSpace x, s ~ Data.VectorSpace.Scalar x) => Data.VectorSpace.InnerSpace (u, v, w, x)
instance Data.VectorSpace.VectorSpace v => Data.VectorSpace.VectorSpace (GHC.Base.Maybe v)
instance Data.VectorSpace.VectorSpace v => Data.VectorSpace.VectorSpace (a -> v)
instance Data.VectorSpace.InnerSpace v => Data.VectorSpace.InnerSpace (a -> v)
instance (Data.MemoTrie.HasTrie a, Data.VectorSpace.VectorSpace v) => Data.VectorSpace.VectorSpace (a Data.MemoTrie.:->: v)
instance Data.VectorSpace.InnerSpace a => Data.VectorSpace.InnerSpace (GHC.Base.Maybe a)


-- | Basis of a vector space, as an associated type This module requires
--   ghc-6.10 or later
module Data.Basis
class VectorSpace v => HasBasis v where type family Basis v :: *

-- | Interpret basis rep as a vector
basisValue :: HasBasis v => Basis v -> v

-- | Extract coordinates
decompose :: HasBasis v => v -> [(Basis v, Scalar v)]

-- | Experimental version. More elegant definitions, and friendly to
--   infinite-dimensional vector spaces.
decompose' :: HasBasis v => v -> (Basis v -> Scalar v)

-- | Linear combination of vectors
linearCombo :: VectorSpace v => [(v, Scalar v)] -> v
recompose :: HasBasis v => [(Basis v, Scalar v)] -> v
instance Data.Basis.HasBasis GHC.Types.Float
instance Data.Basis.HasBasis Foreign.C.Types.CFloat
instance Data.Basis.HasBasis GHC.Types.Double
instance Data.Basis.HasBasis Foreign.C.Types.CDouble
instance GHC.Real.Integral a => Data.Basis.HasBasis (GHC.Real.Ratio a)
instance (Data.Basis.HasBasis u, s ~ Data.VectorSpace.Scalar u, Data.Basis.HasBasis v, s ~ Data.VectorSpace.Scalar v) => Data.Basis.HasBasis (u, v)
instance (Data.Basis.HasBasis u, s ~ Data.VectorSpace.Scalar u, Data.Basis.HasBasis v, s ~ Data.VectorSpace.Scalar v, Data.Basis.HasBasis w, s ~ Data.VectorSpace.Scalar w) => Data.Basis.HasBasis (u, v, w)


-- | Affine spaces.
module Data.AffineSpace
class AdditiveGroup (Diff p) => AffineSpace p where type family Diff p

-- | Subtract points
(.-.) :: AffineSpace p => p -> p -> Diff p

-- | Point plus vector
(.+^) :: AffineSpace p => p -> Diff p -> p

-- | Point minus vector
(.-^) :: AffineSpace p => p -> Diff p -> p

-- | Square of the distance between two points. Sometimes useful for
--   efficiency. See also <a>distance</a>.
distanceSq :: (AffineSpace p, v ~ Diff p, InnerSpace v) => p -> p -> Scalar v

-- | Distance between two points. See also <a>distanceSq</a>.
distance :: (AffineSpace p, v ~ Diff p, InnerSpace v, s ~ Scalar v, Floating (Scalar v)) => p -> p -> s

-- | Affine linear interpolation. Varies from <tt>p</tt> to <tt>p'</tt> as
--   <tt>s</tt> varies from 0 to 1. See also <a>lerp</a> (on vector
--   spaces).
alerp :: (AffineSpace p, VectorSpace (Diff p)) => p -> p -> Scalar (Diff p) -> p

-- | Compute an affine combination (weighted average) of points. The first
--   element is used as origin and is weighted such that all coefficients
--   sum to 1. For example,
--   
--   <pre>
--   affineCombo a [(0.3,b), (0.2,c)]
--   </pre>
--   
--   is equal to
--   
--   <pre>
--   a .+^ (0.3 *^ (b .-. a) ^+^ 0.2 *^ (c .-. a))
--   </pre>
--   
--   and if <tt>a</tt>, <tt>b</tt>, and <tt>c</tt> were in a vector space
--   would also be equal to
--   
--   <pre>
--   0.5 *^ a ^+^ 0.3 *^ b ^+^ 0.2 *^ c
--   </pre>
--   
--   See also <a>linearCombo</a> (on vector spaces).
affineCombo :: (AffineSpace p, v ~ Diff p, VectorSpace v) => p -> [(p, Scalar v)] -> p
instance Data.AffineSpace.AffineSpace GHC.Types.Int
instance Data.AffineSpace.AffineSpace GHC.Integer.Type.Integer
instance Data.AffineSpace.AffineSpace GHC.Types.Double
instance Data.AffineSpace.AffineSpace GHC.Types.Float
instance Data.AffineSpace.AffineSpace Foreign.C.Types.CSChar
instance Data.AffineSpace.AffineSpace Foreign.C.Types.CInt
instance Data.AffineSpace.AffineSpace Foreign.C.Types.CShort
instance Data.AffineSpace.AffineSpace Foreign.C.Types.CLong
instance Data.AffineSpace.AffineSpace Foreign.C.Types.CLLong
instance Data.AffineSpace.AffineSpace Foreign.C.Types.CIntMax
instance Data.AffineSpace.AffineSpace Foreign.C.Types.CDouble
instance Data.AffineSpace.AffineSpace Foreign.C.Types.CFloat
instance GHC.Real.Integral a => Data.AffineSpace.AffineSpace (GHC.Real.Ratio a)
instance (Data.AffineSpace.AffineSpace p, Data.AffineSpace.AffineSpace q) => Data.AffineSpace.AffineSpace (p, q)
instance (Data.AffineSpace.AffineSpace p, Data.AffineSpace.AffineSpace q, Data.AffineSpace.AffineSpace r) => Data.AffineSpace.AffineSpace (p, q, r)
instance Data.AffineSpace.AffineSpace p => Data.AffineSpace.AffineSpace (a -> p)


-- | Linear maps
module Data.LinearMap

-- | Linear map, represented as an optional memo-trie from basis to values,
--   where <a>Nothing</a> means the zero map (an optimization).
data (:-*) u v

-- | Function (assumed linear) as linear map.
linear :: (HasBasis u, HasTrie (Basis u)) => (u -> v) -> (u :-* v)

-- | Apply a linear map to a vector.
lapply :: (VectorSpace v, Scalar u ~ Scalar v, HasBasis u, HasTrie (Basis u)) => (u :-* v) -> (u -> v)

-- | Evaluate a linear map on a basis element.
atBasis :: (AdditiveGroup v, HasTrie (Basis u)) => (u :-* v) -> Basis u -> v

-- | Identity linear map
idL :: (HasBasis u, HasTrie (Basis u)) => u :-* u

-- | Compose linear maps
(*.*) :: (HasBasis u, HasTrie (Basis u), HasBasis v, HasTrie (Basis v), VectorSpace w, Scalar v ~ Scalar w) => (v :-* w) -> (u :-* v) -> (u :-* w)
inLMap :: (LMap' r s -> LMap' t u) -> ((r :-* s) -> (t :-* u))
inLMap2 :: (LMap' r s -> LMap' t u -> LMap' v w) -> ((r :-* s) -> (t :-* u) -> (v :-* w))
inLMap3 :: (LMap' r s -> LMap' t u -> LMap' v w -> LMap' x y) -> ((r :-* s) -> (t :-* u) -> (v :-* w) -> (x :-* y))
liftMS :: (AdditiveGroup a) => (a -> b) -> (MSum a -> MSum b)
liftMS2 :: (AdditiveGroup a, AdditiveGroup b) => (a -> b -> c) -> (MSum a -> MSum b -> MSum c)
liftMS3 :: (AdditiveGroup a, AdditiveGroup b, AdditiveGroup c) => (a -> b -> c -> d) -> (MSum a -> MSum b -> MSum c -> MSum d)

-- | Apply a linear function to each element of a linear map. <tt>liftL f l
--   == linear f *.* l</tt>, but works more efficiently.
liftL :: (Functor f, AdditiveGroup (f a)) => (a -> b) -> MSum (f a) -> MSum (f b)

-- | Apply a linear binary function (not to be confused with a bilinear
--   function) to each element of a linear map.
liftL2 :: (Applicative f, AdditiveGroup (f a), AdditiveGroup (f b)) => (a -> b -> c) -> (MSum (f a) -> MSum (f b) -> MSum (f c))

-- | Apply a linear ternary function (not to be confused with a trilinear
--   function) to each element of a linear map.
liftL3 :: (Applicative f, AdditiveGroup (f a), AdditiveGroup (f b), AdditiveGroup (f c)) => (a -> b -> c -> d) -> (MSum (f a) -> MSum (f b) -> MSum (f c) -> MSum (f d))
firstL :: (HasBasis u, HasBasis u', HasBasis v, HasTrie (Basis u), HasTrie (Basis v), Scalar u ~ Scalar v, Scalar u ~ Scalar u') => (u :-* u') -> ((u, v) :-* (u', v))
instance (Data.MemoTrie.HasTrie (Data.Basis.Basis u), Data.AdditiveGroup.AdditiveGroup v) => Data.AdditiveGroup.AdditiveGroup (u Data.LinearMap.:-* v)
instance (Data.MemoTrie.HasTrie (Data.Basis.Basis u), Data.VectorSpace.VectorSpace v) => Data.VectorSpace.VectorSpace (u Data.LinearMap.:-* v)


-- | Infinite derivative towers via linear maps, using the Maclaurin
--   representation. See blog posts
--   <a>http://conal.net/blog/tag/derivatives/</a>.
module Data.Maclaurin

-- | Tower of derivatives.
data (:>) a b
D :: b -> a :-* (a :> b) -> (:>) a b
[powVal] :: (:>) a b -> b
[derivative] :: (:>) a b -> a :-* (a :> b)

-- | Sample the derivative at a basis element. Optimized for partial
--   application to save work for non-scalar derivatives.
derivAtBasis :: (HasTrie (Basis a), HasBasis a, AdditiveGroup b) => (a :> b) -> (Basis a -> (a :> b))

-- | Infinitely differentiable functions
type (:~>) a b = a -> (a :> b)

-- | Constant derivative tower.
pureD :: (AdditiveGroup b, HasBasis a, HasTrie (Basis a)) => b -> a :> b

-- | Map a <i>linear</i> function over a derivative tower.
fmapD :: (HasBasis a, HasTrie (Basis a), AdditiveGroup b) => (b -> c) -> (a :> b) -> (a :> c)

-- | Map a <i>linear</i> function over a derivative tower.
(<$>>) :: (HasBasis a, HasTrie (Basis a), AdditiveGroup b) => (b -> c) -> (a :> b) -> (a :> c)

-- | Apply a <i>linear</i> binary function over derivative towers.
liftD2 :: (HasBasis a, HasTrie (Basis a), AdditiveGroup b, AdditiveGroup c) => (b -> c -> d) -> (a :> b) -> (a :> c) -> (a :> d)

-- | Apply a <i>linear</i> ternary function over derivative towers.
liftD3 :: (HasBasis a, HasTrie (Basis a), AdditiveGroup b, AdditiveGroup c, AdditiveGroup d) => (b -> c -> d -> e) -> (a :> b) -> (a :> c) -> (a :> d) -> (a :> e)

-- | Differentiable identity function. Sometimes called "the derivation
--   variable" or similar, but it's not really a variable.
idD :: (VectorSpace u, s ~ Scalar u, VectorSpace (u :> u), VectorSpace s, HasBasis u, HasTrie (Basis u)) => u :~> u

-- | Differentiable version of <a>fst</a>
fstD :: (HasBasis a, HasTrie (Basis a), HasBasis b, HasTrie (Basis b), Scalar a ~ Scalar b) => (a, b) :~> a

-- | Differentiable version of <a>snd</a>
sndD :: (HasBasis a, HasTrie (Basis a), HasBasis b, HasTrie (Basis b), Scalar a ~ Scalar b) => (a, b) :~> b

-- | Every linear function has a constant derivative equal to the function
--   itself (as a linear map).
linearD :: (HasBasis u, HasTrie (Basis u), AdditiveGroup v) => (u -> v) -> (u :~> v)

-- | Derivative tower for applying a binary function that distributes over
--   addition, such as multiplication. A bit weaker assumption than
--   bilinearity. Is bilinearity necessary for correctness here?
distrib :: (HasBasis a, HasTrie (Basis a), AdditiveGroup b, AdditiveGroup c, AdditiveGroup u) => (b -> c -> u) -> (a :> b) -> (a :> c) -> (a :> u)

-- | Specialized chain rule. See also '(@.)'
(>-<) :: (HasBasis a, HasTrie (Basis a), VectorSpace u, AdditiveGroup (Scalar u)) => (u -> u) -> ((a :> u) -> (a :> Scalar u)) -> (a :> u) -> (a :> u)
pairD :: (HasBasis a, HasTrie (Basis a), VectorSpace b, VectorSpace c, Scalar b ~ Scalar c) => (a :> b, a :> c) -> a :> (b, c)
unpairD :: (HasBasis a, HasTrie (Basis a), VectorSpace a, VectorSpace b, VectorSpace c, Scalar b ~ Scalar c) => (a :> (b, c)) -> (a :> b, a :> c)
tripleD :: (HasBasis a, HasTrie (Basis a), VectorSpace b, VectorSpace c, VectorSpace d, Scalar b ~ Scalar c, Scalar c ~ Scalar d) => (a :> b, a :> c, a :> d) -> a :> (b, c, d)
untripleD :: (HasBasis a, HasTrie (Basis a), VectorSpace a, VectorSpace b, VectorSpace c, VectorSpace d, Scalar b ~ Scalar c, Scalar c ~ Scalar d) => (a :> (b, c, d)) -> (a :> b, a :> c, a :> d)
instance GHC.Show.Show b => GHC.Show.Show (a Data.Maclaurin.:> b)
instance GHC.Classes.Eq b => GHC.Classes.Eq (a Data.Maclaurin.:> b)
instance (Data.AdditiveGroup.AdditiveGroup v, Data.Basis.HasBasis u, Data.MemoTrie.HasTrie (Data.Basis.Basis u), Data.Boolean.IfB v) => Data.Boolean.IfB (u Data.Maclaurin.:> v)
instance (Data.AdditiveGroup.AdditiveGroup v, Data.Basis.HasBasis u, Data.MemoTrie.HasTrie (Data.Basis.Basis u), Data.Boolean.OrdB v) => Data.Boolean.OrdB (u Data.Maclaurin.:> v)
instance (Data.AdditiveGroup.AdditiveGroup b, Data.Basis.HasBasis a, Data.MemoTrie.HasTrie (Data.Basis.Basis a), Data.Boolean.OrdB b, Data.Boolean.IfB b, GHC.Classes.Ord b) => GHC.Classes.Ord (a Data.Maclaurin.:> b)
instance (Data.Basis.HasBasis a, Data.MemoTrie.HasTrie (Data.Basis.Basis a), Data.AdditiveGroup.AdditiveGroup u) => Data.AdditiveGroup.AdditiveGroup (a Data.Maclaurin.:> u)
instance (Data.Basis.HasBasis a, Data.MemoTrie.HasTrie (Data.Basis.Basis a), Data.VectorSpace.VectorSpace u, Data.AdditiveGroup.AdditiveGroup (Data.VectorSpace.Scalar u)) => Data.VectorSpace.VectorSpace (a Data.Maclaurin.:> u)
instance (Data.VectorSpace.InnerSpace u, s ~ Data.VectorSpace.Scalar u, Data.AdditiveGroup.AdditiveGroup s, Data.Basis.HasBasis a, Data.MemoTrie.HasTrie (Data.Basis.Basis a)) => Data.VectorSpace.InnerSpace (a Data.Maclaurin.:> u)
instance (Data.Basis.HasBasis a, s ~ Data.VectorSpace.Scalar a, Data.MemoTrie.HasTrie (Data.Basis.Basis a), GHC.Num.Num s, Data.VectorSpace.VectorSpace s, Data.VectorSpace.Scalar s ~ s) => GHC.Num.Num (a Data.Maclaurin.:> s)
instance (Data.Basis.HasBasis a, s ~ Data.VectorSpace.Scalar a, Data.MemoTrie.HasTrie (Data.Basis.Basis a), GHC.Real.Fractional s, Data.VectorSpace.VectorSpace s, Data.VectorSpace.Scalar s ~ s) => GHC.Real.Fractional (a Data.Maclaurin.:> s)
instance (Data.Basis.HasBasis a, s ~ Data.VectorSpace.Scalar a, Data.MemoTrie.HasTrie (Data.Basis.Basis a), GHC.Float.Floating s, Data.VectorSpace.VectorSpace s, Data.VectorSpace.Scalar s ~ s) => GHC.Float.Floating (a Data.Maclaurin.:> s)


-- | Module indirection module. For Maclaurin- vs Horner-based derivative
--   towers.
module Data.Derivative


-- | Cross products and normals
module Data.Cross

-- | Thing with a normal vector (not necessarily normalized).
class HasNormal v
normalVec :: HasNormal v => v -> v

-- | Normalized normal vector. See also <tt>cross</tt>.
normal :: (HasNormal v, InnerSpace v, Floating (Scalar v)) => v -> v

-- | Singleton
type One s = s

-- | Homogeneous pair
type Two s = (s, s)

-- | Homogeneous triple
type Three s = (s, s, s)

-- | Cross product of various forms of 2D vectors
class HasCross2 v
cross2 :: HasCross2 v => v -> v

-- | Cross product of various forms of 3D vectors
class HasCross3 v
cross3 :: HasCross3 v => v -> v -> v
instance Data.AdditiveGroup.AdditiveGroup u => Data.Cross.HasCross2 (u, u)
instance (Data.Basis.HasBasis a, Data.MemoTrie.HasTrie (Data.Basis.Basis a), Data.VectorSpace.VectorSpace v, Data.Cross.HasCross2 v) => Data.Cross.HasCross2 (a Data.Maclaurin.:> v)
instance (Data.Basis.HasBasis s, Data.MemoTrie.HasTrie (Data.Basis.Basis s), Data.Basis.Basis s ~ ()) => Data.Cross.HasNormal (Data.Cross.One s Data.Maclaurin.:> Data.Cross.Two s)
instance (GHC.Num.Num s, Data.VectorSpace.VectorSpace s, Data.Basis.HasBasis s, Data.MemoTrie.HasTrie (Data.Basis.Basis s), Data.Basis.Basis s ~ ()) => Data.Cross.HasNormal (Data.Cross.Two (Data.Cross.One s Data.Maclaurin.:> s))
instance GHC.Num.Num s => Data.Cross.HasCross3 (s, s, s)
instance (Data.Basis.HasBasis a, Data.MemoTrie.HasTrie (Data.Basis.Basis a), Data.VectorSpace.VectorSpace v, Data.Cross.HasCross3 v) => Data.Cross.HasCross3 (a Data.Maclaurin.:> v)
instance (GHC.Num.Num s, Data.MemoTrie.HasTrie (Data.Basis.Basis (s, s)), Data.Basis.HasBasis s, Data.Basis.Basis s ~ ()) => Data.Cross.HasNormal (Data.Cross.Two s Data.Maclaurin.:> Data.Cross.Three s)
instance (GHC.Num.Num s, Data.VectorSpace.VectorSpace s, Data.Basis.HasBasis s, Data.MemoTrie.HasTrie (Data.Basis.Basis s), Data.Cross.HasNormal (Data.Cross.Two s Data.Maclaurin.:> Data.Cross.Three s)) => Data.Cross.HasNormal (Data.Cross.Three (Data.Cross.Two s Data.Maclaurin.:> s))
