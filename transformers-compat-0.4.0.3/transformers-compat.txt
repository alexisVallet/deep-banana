-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A small compatibility shim exposing the new types from transformers 0.3 and 0.4 to older Haskell platforms.
--   
--   This package includes backported versions of types that were added to
--   transformers in transformers 0.3 and 0.4 for users who need strict
--   transformers 0.2 or 0.3 compatibility to run on old versions of the
--   platform, but also need those types.
--   
--   Those users should be able to just depend on <tt>transformers &gt;=
--   0.2</tt> and <tt>transformers-compat &gt;= 0.3</tt>.
--   
--   Note: missing methods are not supplied, but this at least permits the
--   types to be used.
@package transformers-compat
@version 0.4.0.3


-- | Prelude classes, lifted to unary type constructors.
module Data.Functor.Classes

-- | Lifting of the <a>Eq</a> class to unary type constructors.
class Eq1 f
eq1 :: (Eq1 f, Eq a) => f a -> f a -> Bool

-- | Lifting of the <a>Ord</a> class to unary type constructors.
class Eq1 f => Ord1 f
compare1 :: (Ord1 f, Ord a) => f a -> f a -> Ordering

-- | Lifting of the <a>Read</a> class to unary type constructors.
class Read1 f
readsPrec1 :: (Read1 f, Read a) => Int -> ReadS (f a)

-- | Lifting of the <a>Show</a> class to unary type constructors.
class Show1 f
showsPrec1 :: (Show1 f, Show a) => Int -> f a -> ShowS

-- | <tt><a>readsData</a> p d</tt> is a parser for datatypes where each
--   alternative begins with a data constructor. It parses the constructor
--   and passes it to <tt>p</tt>. Parsers for various constructors can be
--   constructed with <a>readsUnary</a>, <a>readsUnary1</a> and
--   <a>readsBinary1</a>, and combined with <tt>mappend</tt> from the
--   <tt>Monoid</tt> class.
readsData :: (String -> ReadS a) -> Int -> ReadS a

-- | <tt><a>readsUnary</a> n c n'</tt> matches the name of a unary data
--   constructor and then parses its argument using <a>readsPrec</a>.
readsUnary :: Read a => String -> (a -> t) -> String -> ReadS t

-- | <tt><a>readsUnary1</a> n c n'</tt> matches the name of a unary data
--   constructor and then parses its argument using <a>readsPrec1</a>.
readsUnary1 :: (Read1 f, Read a) => String -> (f a -> t) -> String -> ReadS t

-- | <tt><a>readsBinary1</a> n c n'</tt> matches the name of a binary data
--   constructor and then parses its arguments using <a>readsPrec1</a>.
readsBinary1 :: (Read1 f, Read1 g, Read a) => String -> (f a -> g a -> t) -> String -> ReadS t

-- | <tt><a>showsUnary</a> n d x</tt> produces the string representation of
--   a unary data constructor with name <tt>n</tt> and argument <tt>x</tt>,
--   in precedence context <tt>d</tt>.
showsUnary :: Show a => String -> Int -> a -> ShowS

-- | <tt><a>showsUnary1</a> n d x</tt> produces the string representation
--   of a unary data constructor with name <tt>n</tt> and argument
--   <tt>x</tt>, in precedence context <tt>d</tt>.
showsUnary1 :: (Show1 f, Show a) => String -> Int -> f a -> ShowS

-- | <tt><a>showsBinary1</a> n d x</tt> produces the string representation
--   of a binary data constructor with name <tt>n</tt> and arguments
--   <tt>x</tt> and <tt>y</tt>, in precedence context <tt>d</tt>.
showsBinary1 :: (Show1 f, Show1 g, Show a) => String -> Int -> f a -> g a -> ShowS
instance Show1 f => Show1 (Reverse f)
instance Read1 f => Read1 (Reverse f)
instance Ord1 f => Ord1 (Reverse f)
instance Eq1 f => Eq1 (Reverse f)
instance (Show1 f, Show a) => Show (Reverse f a)
instance (Read1 f, Read a) => Read (Reverse f a)
instance (Ord1 f, Ord a) => Ord (Reverse f a)
instance (Eq1 f, Eq a) => Eq (Reverse f a)
instance Show1 f => Show1 (Backwards f)
instance Read1 f => Read1 (Backwards f)
instance Ord1 f => Ord1 (Backwards f)
instance Eq1 f => Eq1 (Backwards f)
instance (Show1 f, Show a) => Show (Backwards f a)
instance (Read1 f, Read a) => Read (Backwards f a)
instance (Ord1 f, Ord a) => Ord (Backwards f a)
instance (Eq1 f, Eq a) => Eq (Backwards f a)
instance Show1 f => Show1 (Lift f)
instance Read1 f => Read1 (Lift f)
instance Ord1 f => Ord1 (Lift f)
instance Eq1 f => Eq1 (Lift f)
instance (Show1 f, Show a) => Show (Lift f a)
instance (Read1 f, Read a) => Read (Lift f a)
instance (Ord1 f, Ord a) => Ord (Lift f a)
instance (Eq1 f, Eq a) => Eq (Lift f a)
instance (Show1 g, Show a) => Show (Apply g a)
instance (Read1 g, Read a) => Read (Apply g a)
instance (Ord1 g, Ord a) => Ord (Apply g a)
instance (Eq1 g, Eq a) => Eq (Apply g a)
instance Show1 Identity
instance Read1 Identity
instance Ord1 Identity
instance Eq1 Identity
instance Show a => Show1 (Constant a)
instance Read a => Read1 (Constant a)
instance Ord a => Ord1 (Constant a)
instance Eq a => Eq1 (Constant a)
instance (Show1 f, Show1 g) => Show1 (Product f g)
instance (Read1 f, Read1 g) => Read1 (Product f g)
instance (Ord1 f, Ord1 g) => Ord1 (Product f g)
instance (Eq1 f, Eq1 g) => Eq1 (Product f g)
instance (Show1 f, Show1 g, Show a) => Show (Product f g a)
instance (Read1 f, Read1 g, Read a) => Read (Product f g a)
instance (Ord1 f, Ord1 g, Ord a) => Ord (Product f g a)
instance (Eq1 f, Eq1 g, Eq a) => Eq (Product f g a)
instance (Functor f, Show1 f, Show1 g) => Show1 (Compose f g)
instance (Functor f, Read1 f, Read1 g) => Read1 (Compose f g)
instance (Functor f, Ord1 f, Ord1 g) => Ord1 (Compose f g)
instance (Functor f, Eq1 f, Eq1 g) => Eq1 (Compose f g)
instance (Functor f, Show1 f, Show1 g, Show a) => Show (Compose f g a)
instance (Functor f, Read1 f, Read1 g, Read a) => Read (Compose f g a)
instance (Functor f, Ord1 f, Ord1 g, Ord a) => Ord (Compose f g a)
instance (Functor f, Eq1 f, Eq1 g, Eq a) => Eq (Compose f g a)
instance (Show w, Show1 m) => Show1 (WriterT w m)
instance (Read w, Read1 m) => Read1 (WriterT w m)
instance (Ord w, Ord1 m) => Ord1 (WriterT w m)
instance (Eq w, Eq1 m) => Eq1 (WriterT w m)
instance (Show w, Show1 m, Show a) => Show (WriterT w m a)
instance (Read w, Read1 m, Read a) => Read (WriterT w m a)
instance (Ord w, Ord1 m, Ord a) => Ord (WriterT w m a)
instance (Eq w, Eq1 m, Eq a) => Eq (WriterT w m a)
instance (Show w, Show1 m) => Show1 (WriterT w m)
instance (Read w, Read1 m) => Read1 (WriterT w m)
instance (Ord w, Ord1 m) => Ord1 (WriterT w m)
instance (Eq w, Eq1 m) => Eq1 (WriterT w m)
instance (Show w, Show1 m, Show a) => Show (WriterT w m a)
instance (Read w, Read1 m, Read a) => Read (WriterT w m a)
instance (Ord w, Ord1 m, Ord a) => Ord (WriterT w m a)
instance (Eq w, Eq1 m, Eq a) => Eq (WriterT w m a)
instance Show1 m => Show1 (MaybeT m)
instance Read1 m => Read1 (MaybeT m)
instance Ord1 m => Ord1 (MaybeT m)
instance Eq1 m => Eq1 (MaybeT m)
instance (Show1 m, Show a) => Show (MaybeT m a)
instance (Read1 m, Read a) => Read (MaybeT m a)
instance (Ord1 m, Ord a) => Ord (MaybeT m a)
instance (Eq1 m, Eq a) => Eq (MaybeT m a)
instance Show1 m => Show1 (ListT m)
instance Read1 m => Read1 (ListT m)
instance Ord1 m => Ord1 (ListT m)
instance Eq1 m => Eq1 (ListT m)
instance (Show1 m, Show a) => Show (ListT m a)
instance (Read1 m, Read a) => Read (ListT m a)
instance (Ord1 m, Ord a) => Ord (ListT m a)
instance (Eq1 m, Eq a) => Eq (ListT m a)
instance Show1 f => Show1 (IdentityT f)
instance Read1 f => Read1 (IdentityT f)
instance Ord1 f => Ord1 (IdentityT f)
instance Eq1 f => Eq1 (IdentityT f)
instance (Show1 f, Show a) => Show (IdentityT f a)
instance (Read1 f, Read a) => Read (IdentityT f a)
instance (Ord1 f, Ord a) => Ord (IdentityT f a)
instance (Eq1 f, Eq a) => Eq (IdentityT f a)
instance (Show e, Show1 m) => Show1 (ErrorT e m)
instance (Read e, Read1 m) => Read1 (ErrorT e m)
instance (Ord e, Ord1 m) => Ord1 (ErrorT e m)
instance (Eq e, Eq1 m) => Eq1 (ErrorT e m)
instance (Show e, Show1 m, Show a) => Show (ErrorT e m a)
instance (Read e, Read1 m, Read a) => Read (ErrorT e m a)
instance (Ord e, Ord1 m, Ord a) => Ord (ErrorT e m a)
instance (Eq e, Eq1 m, Eq a) => Eq (ErrorT e m a)
instance Show a => Show1 (Either a)
instance Read a => Read1 (Either a)
instance Ord a => Ord1 (Either a)
instance Eq a => Eq1 (Either a)
instance Show a => Show1 ((,) a)
instance Read a => Read1 ((,) a)
instance Ord a => Ord1 ((,) a)
instance Eq a => Eq1 ((,) a)
instance Show1 []
instance Read1 []
instance Ord1 []
instance Eq1 []
instance Show1 Maybe
instance Read1 Maybe
instance Ord1 Maybe
instance Eq1 Maybe
instance Ord a => Ord (Constant a b)
instance Eq a => Eq (Constant a b)
instance Read a => Read (Constant a b)
instance Show a => Show (Constant a b)
instance Ord a => Ord (Identity a)
instance Eq a => Eq (Identity a)
instance Read a => Read (Identity a)
instance Show a => Show (Identity a)


-- | Sums, lifted to functors.
module Data.Functor.Sum

-- | Lifted sum of functors.
data Sum f g a
InL :: (f a) -> Sum f g a
InR :: (g a) -> Sum f g a
instance (Traversable f, Traversable g) => Traversable (Sum f g)
instance (Foldable f, Foldable g) => Foldable (Sum f g)
instance (Functor f, Functor g) => Functor (Sum f g)
instance (Show1 f, Show1 g) => Show1 (Sum f g)
instance (Read1 f, Read1 g) => Read1 (Sum f g)
instance (Ord1 f, Ord1 g) => Ord1 (Sum f g)
instance (Eq1 f, Eq1 g) => Eq1 (Sum f g)
instance (Show1 f, Show1 g, Show a) => Show (Sum f g a)
instance (Read1 f, Read1 g, Read a) => Read (Sum f g a)
instance (Ord1 f, Ord1 g, Ord a) => Ord (Sum f g a)
instance (Eq1 f, Eq1 g, Eq a) => Eq (Sum f g a)


-- | Signatures for monad operations that require specialized lifting.
module Control.Monad.Signatures

-- | Signature of the <tt>callCC</tt> operation, introduced in
--   <a>Control.Monad.Trans.Cont</a>.
type CallCC m a b = ((a -> m b) -> m a) -> m a

-- | Signature of the <tt>catchE</tt> operation, introduced in
--   <a>Control.Monad.Trans.Except</a>.
type Catch e m a = m a -> (e -> m a) -> m a

-- | Signature of the <tt>listen</tt> operation, introduced in
--   <a>Control.Monad.Trans.Writer</a>.
type Listen w m a = m a -> m (a, w)

-- | Signature of the <tt>pass</tt> operation, introduced in
--   <a>Control.Monad.Trans.Writer</a>.
type Pass w m a = m (a, w -> w) -> m a


-- | This monad transformer extends a monad with the ability throw
--   exceptions.
--   
--   A sequence of actions terminates normally, producing a value, only if
--   none of the actions in the sequence throws an exception. If one throws
--   an exception, the rest of the sequence is skipped and the composite
--   action exits with that exception.
--   
--   If the value of the exception is not required, the variant in
--   <a>Control.Monad.Trans.Maybe</a> may be used instead.
module Control.Monad.Trans.Except

-- | The parameterizable exception monad.
--   
--   Computations are either exceptions or normal values.
--   
--   The <a>return</a> function returns a normal value, while
--   <tt>&gt;&gt;=</tt> exits on the first exception.
type Except e = ExceptT e Identity

-- | Constructor for computations in the exception monad. (The inverse of
--   <a>runExcept</a>).
except :: Either e a -> Except e a

-- | Extractor for computations in the exception monad. (The inverse of
--   <a>except</a>).
runExcept :: Except e a -> Either e a

-- | Map the unwrapped computation using the given function.
--   
--   <ul>
--   <li><pre><a>runExcept</a> (<a>mapExcept</a> f m) = f (<a>runExcept</a>
--   m)</pre></li>
--   </ul>
mapExcept :: (Either e a -> Either e' b) -> Except e a -> Except e' b

-- | Transform any exceptions thrown by the computation using the given
--   function (a specialization of <a>withExceptT</a>).
withExcept :: (e -> e') -> Except e a -> Except e' a

-- | A monad transformer that adds exceptions to other monads.
--   
--   <tt>ExceptT</tt> constructs a monad parameterized over two things:
--   
--   <ul>
--   <li>e - The exception type.</li>
--   <li>m - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function yields a computation that produces the
--   given value, while <tt>&gt;&gt;=</tt> sequences two subcomputations,
--   exiting on the first exception.
newtype ExceptT e m a
ExceptT :: m (Either e a) -> ExceptT e m a
runExceptT :: ExceptT e m a -> m (Either e a)

-- | Map the unwrapped computation using the given function.
--   
--   <ul>
--   <li><pre><a>runExceptT</a> (<a>mapExceptT</a> f m) = f
--   (<a>runExceptT</a> m)</pre></li>
--   </ul>
mapExceptT :: (m (Either e a) -> n (Either e' b)) -> ExceptT e m a -> ExceptT e' n b

-- | Transform any exceptions thrown by the computation using the given
--   function.
withExceptT :: Functor m => (e -> e') -> ExceptT e m a -> ExceptT e' m a

-- | Signal an exception value <tt>e</tt>.
--   
--   <ul>
--   <li><pre><a>runExceptT</a> (<a>throwE</a> e) = <a>return</a>
--   (<a>Left</a> e)</pre></li>
--   <li><pre><a>throwE</a> e &gt;&gt;= m = <a>throwE</a> e</pre></li>
--   </ul>
throwE :: Monad m => e -> ExceptT e m a

-- | Handle an exception.
--   
--   <ul>
--   <li><pre><a>catchE</a> h (<a>lift</a> m) = <a>lift</a> m</pre></li>
--   <li><pre><a>catchE</a> h (<a>throwE</a> e) = h e</pre></li>
--   </ul>
catchE :: Monad m => ExceptT e m a -> (e -> ExceptT e' m a) -> ExceptT e' m a

-- | Lift a <tt>callCC</tt> operation to the new monad.
liftCallCC :: CallCC m (Either e a) (Either e b) -> CallCC (ExceptT e m) a b

-- | Lift a <tt>listen</tt> operation to the new monad.
liftListen :: Monad m => Listen w m (Either e a) -> Listen w (ExceptT e m) a

-- | Lift a <tt>pass</tt> operation to the new monad.
liftPass :: Monad m => Pass w m (Either e a) -> Pass w (ExceptT e m) a
instance MonadCont m => MonadCont (ExceptT e m)
instance MonadRWS r w s m => MonadRWS r w s (ExceptT e m)
instance MonadReader r m => MonadReader r (ExceptT e m)
instance MonadState s m => MonadState s (ExceptT e m)
instance MonadWriter w m => MonadWriter w (ExceptT e m)
instance Monad m => MonadError e (ExceptT e m)
instance MonadIO m => MonadIO (ExceptT e m)
instance MonadTrans (ExceptT e)
instance MonadFix m => MonadFix (ExceptT e m)
instance (Monad m, Monoid e) => MonadPlus (ExceptT e m)
instance Monad m => Monad (ExceptT e m)
instance (Functor m, Monad m, Monoid e) => Alternative (ExceptT e m)
instance (Functor m, Monad m) => Applicative (ExceptT e m)
instance Traversable f => Traversable (ExceptT e f)
instance Foldable f => Foldable (ExceptT e f)
instance Functor m => Functor (ExceptT e m)
instance (Show e, Show1 m) => Show1 (ExceptT e m)
instance (Read e, Read1 m) => Read1 (ExceptT e m)
instance (Ord e, Ord1 m) => Ord1 (ExceptT e m)
instance (Eq e, Eq1 m) => Eq1 (ExceptT e m)
instance (Show e, Show1 m, Show a) => Show (ExceptT e m a)
instance (Read e, Read1 m, Read a) => Read (ExceptT e m a)
instance (Ord e, Ord1 m, Ord a) => Ord (ExceptT e m a)
instance (Eq e, Eq1 m, Eq a) => Eq (ExceptT e m a)
